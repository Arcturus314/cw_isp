        -:    0:Source:dcraw2.c
        -:    0:Graph:dcraw2.gcno
        -:    0:Data:dcraw2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:   dcraw.c -- Dave Coffin's raw photo decoder
        -:    3:   Copyright 1997-2016 by Dave Coffin, dcoffin a cybercom o net
        -:    4:
        -:    5:   This is a command-line ANSI C program to convert raw photos from
        -:    6:   any digital camera on any computer running any operating system.
        -:    7:
        -:    8:   No license is required to download and use dcraw.c.  However,
        -:    9:   to lawfully redistribute dcraw, you must either (a) offer, at
        -:   10:   no extra charge, full source code* for all executable files
        -:   11:   containing RESTRICTED functions, (b) distribute this code under
        -:   12:   the GPL Version 2 or later, (c) remove all RESTRICTED functions,
        -:   13:   re-implement them, or copy them from an earlier, unrestricted
        -:   14:   Revision of dcraw.c, or (d) purchase a license from the author.
        -:   15:
        -:   16:   The functions that process Foveon images have been RESTRICTED
        -:   17:   since Revision 1.237.  All other code remains free for all uses.
        -:   18:
        -:   19:   *If you have not modified dcraw.c in any way, a link to my
        -:   20:   homepage qualifies as "full source code".
        -:   21:
        -:   22:   $Revision: 1.477 $
        -:   23:   $Date: 2016/05/10 21:30:43 $
        -:   24: */
        -:   25:
        -:   26:#define DCRAW_VERSION "9.27"
        -:   27:
        -:   28:#ifndef _GNU_SOURCE
        -:   29:#define _GNU_SOURCE
        -:   30:#endif
        -:   31:#define _USE_MATH_DEFINES
        -:   32:#include <ctype.h>
        -:   33:#include <errno.h>
        -:   34:#include <fcntl.h>
        -:   35:#include <float.h>
        -:   36:#include <limits.h>
        -:   37:#include <math.h>
        -:   38:#include <setjmp.h>
        -:   39:#include <stdio.h>
        -:   40:#include <stdlib.h>
        -:   41:#include <string.h>
        -:   42:#include <time.h>
        -:   43:#include <sys/types.h>
        -:   44:
        -:   45:#if defined(DJGPP) || defined(__MINGW32__)
        -:   46:#define fseeko fseek
        -:   47:#define ftello ftell
        -:   48:#else
        -:   49:#define fgetc getc_unlocked
        -:   50:#endif
        -:   51:#ifdef __CYGWIN__
        -:   52:#include <io.h>
        -:   53:#endif
        -:   54:#ifdef WIN32
        -:   55:#include <sys/utime.h>
        -:   56:#include <winsock2.h>
        -:   57:#pragma comment(lib, "ws2_32.lib")
        -:   58:#define snprintf _snprintf
        -:   59:#define strcasecmp stricmp
        -:   60:#define strncasecmp strnicmp
        -:   61:typedef __int64 INT64;
        -:   62:typedef unsigned __int64 UINT64;
        -:   63:#else
        -:   64:#include <unistd.h>
        -:   65:#include <utime.h>
        -:   66:#include <netinet/in.h>
        -:   67:typedef long long INT64;
        -:   68:typedef unsigned long long UINT64;
        -:   69:#endif
        -:   70:
        -:   71:#ifdef NODEPS
        -:   72:#define NO_JASPER
        -:   73:#define NO_JPEG
        -:   74:#define NO_LCMS
        -:   75:#endif
        -:   76:#ifndef NO_JASPER
        -:   77:#include <jasper/jasper.h>	/* Decode Red camera movies */
        -:   78:#endif
        -:   79:#ifndef NO_JPEG
        -:   80:#include <jpeglib.h>		/* Decode compressed Kodak DC120 photos */
        -:   81:#endif				/* and Adobe Lossy DNGs */
        -:   82:#ifndef NO_LCMS
        -:   83:#include <lcms2.h>		/* Support color profiles */
        -:   84:#endif
        -:   85:#ifdef LOCALEDIR
        -:   86:#include <libintl.h>
        -:   87:#define _(String) gettext(String)
        -:   88:#else
        -:   89:#define _(String) (String)
        -:   90:#endif
        -:   91:
        -:   92:#if !defined(uchar)
        -:   93:#define uchar unsigned char
        -:   94:#endif
        -:   95:#if !defined(ushort)
        -:   96:#define ushort unsigned short
        -:   97:#endif
        -:   98:
        -:   99:/*
        -:  100:   All global variables are defined here, and all functions that
        -:  101:   access them are prefixed with "CLASS".  Note that a thread-safe
        -:  102:   C++ class cannot have non-const static local variables.
        -:  103: */
        -:  104:FILE *ifp, *ofp;
        -:  105:short order;
        -:  106:const char *ifname;
        -:  107:char *meta_data, xtrans[6][6], xtrans_abs[6][6];
        -:  108:char cdesc[5], desc[512], make[64], model[64], model2[64], artist[64];
        -:  109:float flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;
        -:  110:time_t timestamp;
        -:  111:off_t strip_offset, data_offset;
        -:  112:off_t thumb_offset, meta_offset, profile_offset;
        -:  113:unsigned shot_order, kodak_cbpp, exif_cfa, unique_id;
        -:  114:unsigned thumb_length, meta_length, profile_length;
        -:  115:unsigned thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;
        -:  116:unsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;
        -:  117:unsigned black, maximum, mix_green, raw_color, zero_is_bad;
        -:  118:unsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;
        -:  119:unsigned tile_width, tile_length, gpsdata[32], load_flags;
        -:  120:unsigned flip, tiff_flip, filters, colors;
        -:  121:ushort raw_height, raw_width, height, width, top_margin, left_margin;
        -:  122:ushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;
        -:  123:ushort *raw_image, (*image)[4], cblack[4102];
        -:  124:ushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];
        -:  125:double pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };
        -:  126:float bright=1, user_mul[4]={0,0,0,0}, threshold=0;
        -:  127:int mask[8][4];
        -:  128:int half_size=0, four_color_rgb=0, document_mode=0, highlight=0;
        -:  129:int verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=1;
        -:  130:int output_color=1, output_bps=8, output_tiff=0, med_passes=0;
        -:  131:int no_auto_bright=0;
        -:  132:unsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };
        -:  133:float cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];
        -:  134:const double xyz_rgb[3][3] = {			/* XYZ from RGB */
        -:  135:  { 0.412453, 0.357580, 0.180423 },
        -:  136:  { 0.212671, 0.715160, 0.072169 },
        -:  137:  { 0.019334, 0.119193, 0.950227 } };
        -:  138:const float d65_white[3] = { 0.950456, 1, 1.088754 };
        -:  139:int histogram[4][0x2000];
        -:  140:void (*write_thumb)(), (*write_fun)();
        -:  141:void (*load_raw)(), (*thumb_load_raw)();
        -:  142:jmp_buf failure;
        -:  143:
        -:  144:struct decode {
        -:  145:  struct decode *branch[2];
        -:  146:  int leaf;
        -:  147:} first_decode[2048], *second_decode, *free_decode;
        -:  148:
        -:  149:struct tiff_ifd {
        -:  150:  int width, height, bps, comp, phint, offset, flip, samples, bytes;
        -:  151:  int tile_width, tile_length;
        -:  152:  float shutter;
        -:  153:} tiff_ifd[10];
        -:  154:
        -:  155:struct ph1 {
        -:  156:  int format, key_off, tag_21a;
        -:  157:  int black, split_col, black_col, split_row, black_row;
        -:  158:  float tag_210;
        -:  159:} ph1;
        -:  160:
        -:  161:#define CLASS
        -:  162:
        -:  163:#define FORC(cnt) for (c=0; c < cnt; c++)
        -:  164:#define FORC3 FORC(3)
        -:  165:#define FORC4 FORC(4)
        -:  166:#define FORCC FORC(colors)
        -:  167:
        -:  168:#define SQR(x) ((x)*(x))
        -:  169:#define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))
        -:  170:#define MIN(a,b) ((a) < (b) ? (a) : (b))
        -:  171:#define MAX(a,b) ((a) > (b) ? (a) : (b))
        -:  172:#define LIM(x,min,max) MAX(min,MIN(x,max))
        -:  173:#define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))
        -:  174:#define CLIP(x) LIM((int)(x),0,65535)
        -:  175:#define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }
        -:  176:
        -:  177:/*
        -:  178:   In order to inline this calculation, I make the risky
        -:  179:   assumption that all filter patterns can be described
        -:  180:   by a repeating pattern of eight rows and two columns
        -:  181:
        -:  182:   Do not use the FC or BAYER macros with the Leaf CatchLight,
        -:  183:   because its pattern is 16x16, not 2x8.
        -:  184:
        -:  185:   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2
        -:  186:
        -:  187:	PowerShot 600	PowerShot A50	PowerShot Pro70	Pro90 & G1
        -:  188:	0xe1e4e1e4:	0x1b4e4b1e:	0x1e4b4e1b:	0xb4b4b4b4:
        -:  189:
        -:  190:	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5
        -:  191:	0 G M G M G M	0 C Y C Y C Y	0 Y C Y C Y C	0 G M G M G M
        -:  192:	1 C Y C Y C Y	1 M G M G M G	1 M G M G M G	1 Y C Y C Y C
        -:  193:	2 M G M G M G	2 Y C Y C Y C	2 C Y C Y C Y
        -:  194:	3 C Y C Y C Y	3 G M G M G M	3 G M G M G M
        -:  195:			4 C Y C Y C Y	4 Y C Y C Y C
        -:  196:	PowerShot A5	5 G M G M G M	5 G M G M G M
        -:  197:	0x1e4e1e4e:	6 Y C Y C Y C	6 C Y C Y C Y
        -:  198:			7 M G M G M G	7 M G M G M G
        -:  199:	  0 1 2 3 4 5
        -:  200:	0 C Y C Y C Y
        -:  201:	1 G M G M G M
        -:  202:	2 C Y C Y C Y
        -:  203:	3 M G M G M G
        -:  204:
        -:  205:   All RGB cameras use one of these Bayer grids:
        -:  206:
        -:  207:	0x16161616:	0x61616161:	0x49494949:	0x94949494:
        -:  208:
        -:  209:	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5	  0 1 2 3 4 5
        -:  210:	0 B G B G B G	0 G R G R G R	0 G B G B G B	0 R G R G R G
        -:  211:	1 G R G R G R	1 B G B G B G	1 R G R G R G	1 G B G B G B
        -:  212:	2 B G B G B G	2 G R G R G R	2 G B G B G B	2 R G R G R G
        -:  213:	3 G R G R G R	3 B G B G B G	3 R G R G R G	3 G B G B G B
        -:  214: */
        -:  215:
        -:  216:#define RAW(row,col) \
        -:  217:	raw_image[(row)*raw_width+(col)]
        -:  218:
        -:  219:#define FC(row,col) \
        -:  220:	(filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3)
        -:  221:
        -:  222:#define BAYER(row,col) \
        -:  223:	image[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]
        -:  224:
        -:  225:#define BAYER2(row,col) \
        -:  226:	image[((row) >> shrink)*iwidth + ((col) >> shrink)][fcol(row,col)]
        -:  227:
 18293400:  228:int CLASS fcol (int row, int col)
        -:  229:{
        -:  230:  static const char filter[16][16] =
        -:  231:  { { 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },
        -:  232:    { 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },
        -:  233:    { 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },
        -:  234:    { 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },
        -:  235:    { 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },
        -:  236:    { 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },
        -:  237:    { 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },
        -:  238:    { 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },
        -:  239:    { 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },
        -:  240:    { 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },
        -:  241:    { 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },
        -:  242:    { 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },
        -:  243:    { 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },
        -:  244:    { 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },
        -:  245:    { 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },
        -:  246:    { 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 } };
        -:  247:
 18293400:  248:  if (filters == 1) return filter[(row+top_margin)&15][(col+left_margin)&15];
 18293400:  249:  if (filters == 9) return xtrans[(row+6) % 6][(col+6) % 6];
 18293400:  250:  return FC(row,col);
        -:  251:}
        -:  252:
        -:  253:#ifndef __GLIBC__
        -:  254:char *my_memmem (char *haystack, size_t haystacklen,
        -:  255:	      char *needle, size_t needlelen)
        -:  256:{
        -:  257:  char *c;
        -:  258:  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)
        -:  259:    if (!memcmp (c, needle, needlelen))
        -:  260:      return c;
        -:  261:  return 0;
        -:  262:}
        -:  263:#define memmem my_memmem
        -:  264:char *my_strcasestr (char *haystack, const char *needle)
        -:  265:{
        -:  266:  char *c;
        -:  267:  for (c = haystack; *c; c++)
        -:  268:    if (!strncasecmp(c, needle, strlen(needle)))
        -:  269:      return c;
        -:  270:  return 0;
        -:  271:}
        -:  272:#define strcasestr my_strcasestr
        -:  273:#endif
        -:  274:
        8:  275:void CLASS merror (void *ptr, const char *where)
        -:  276:{
       16:  277:  if (ptr) return;
    #####:  278:  fprintf (stderr,_("%s: Out of memory in %s\n"), ifname, where);
    #####:  279:  longjmp (failure, 1);
        -:  280:}
        -:  281:
    #####:  282:void CLASS derror()
        -:  283:{
    #####:  284:  if (!data_error) {
    #####:  285:    fprintf (stderr, "%s: ", ifname);
    #####:  286:    if (feof(ifp))
    #####:  287:      fprintf (stderr,_("Unexpected end of file\n"));
        -:  288:    else
    #####:  289:      fprintf (stderr,_("Corrupt data near 0x%llx\n"), (INT64) ftello(ifp));
        -:  290:  }
    #####:  291:  data_error++;
    #####:  292:}
        -:  293:
    #####:  294:ushort CLASS sget2 (uchar *s)
        -:  295:{
      338:  296:  if (order == 0x4949)		/* "II" means little-endian */
      337:  297:    return s[0] | s[1] << 8;
        -:  298:  else				/* "MM" means big-endian */
        1:  299:    return s[0] << 8 | s[1];
        -:  300:}
        -:  301:
      338:  302:ushort CLASS get2()
        -:  303:{
      338:  304:  uchar str[2] = { 0xff,0xff };
      338:  305:  fread (str, 1, 2, ifp);
      338:  306:  return sget2(str);
        -:  307:}
        -:  308:
      231:  309:unsigned CLASS sget4 (uchar *s)
        -:  310:{
      231:  311:  if (order == 0x4949)
      231:  312:    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;
        -:  313:  else
    #####:  314:    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];
        -:  315:}
        -:  316:#define sget4(s) sget4((uchar *)s)
        -:  317:
      231:  318:unsigned CLASS get4()
        -:  319:{
      231:  320:  uchar str[4] = { 0xff,0xff,0xff,0xff };
      231:  321:  fread (str, 1, 4, ifp);
      231:  322:  return sget4(str);
        -:  323:}
        -:  324:
    #####:  325:unsigned CLASS getint (int type)
        -:  326:{
       10:  327:  return type == 3 ? get2() : get4();
        -:  328:}
        -:  329:
    #####:  330:float CLASS int_to_float (int i)
        -:  331:{
        -:  332:  union { int i; float f; } u;
        -:  333:  u.i = i;
    #####:  334:  return u.f;
        -:  335:}
        -:  336:
        5:  337:double CLASS getreal (int type)
        -:  338:{
        -:  339:  union { char c[8]; double d; } u;
        -:  340:  int i, rev;
        -:  341:
        5:  342:  switch (type) {
    #####:  343:    case 3: return (unsigned short) get2();
    #####:  344:    case 4: return (unsigned int) get4();
        4:  345:    case 5:  u.d = (unsigned int) get4();
        4:  346:      return u.d / (unsigned int) get4();
    #####:  347:    case 8: return (signed short) get2();
    #####:  348:    case 9: return (signed int) get4();
        1:  349:    case 10: u.d = (signed int) get4();
        1:  350:      return u.d / (signed int) get4();
    #####:  351:    case 11: return int_to_float (get4());
    #####:  352:    case 12:
    #####:  353:      rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));
    #####:  354:      for (i=0; i < 8; i++)
    #####:  355:	u.c[i ^ rev] = fgetc(ifp);
    #####:  356:      return u.d;
    #####:  357:    default: return fgetc(ifp);
        -:  358:  }
        -:  359:}
        -:  360:
        1:  361:void CLASS read_shorts (ushort *pixel, int count)
        -:  362:{
        1:  363:  if (fread (pixel, 2, count, ifp) < count) derror();
        1:  364:  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))
    #####:  365:    swab (pixel, pixel, count*2);
        1:  366:}
        -:  367:
    #####:  368:void CLASS cubic_spline (const int *x_, const int *y_, const int len)
        -:  369:{
        -:  370:  float **A, *b, *c, *d, *x, *y;
        -:  371:  int i, j;
        -:  372:
    #####:  373:  A = (float **) calloc (((2*len + 4)*sizeof **A + sizeof *A), 2*len);
    #####:  374:  if (!A) return;
    #####:  375:  A[0] = (float *) (A + 2*len);
    #####:  376:  for (i = 1; i < 2*len; i++)
    #####:  377:    A[i] = A[0] + 2*len*i;
    #####:  378:  y = len + (x = i + (d = i + (c = i + (b = A[0] + i*i))));
    #####:  379:  for (i = 0; i < len; i++) {
    #####:  380:    x[i] = x_[i] / 65535.0;
    #####:  381:    y[i] = y_[i] / 65535.0;
        -:  382:  }
    #####:  383:  for (i = len-1; i > 0; i--) {
    #####:  384:    b[i] = (y[i] - y[i-1]) / (x[i] - x[i-1]);
    #####:  385:    d[i-1] = x[i] - x[i-1];
        -:  386:  }
    #####:  387:  for (i = 1; i < len-1; i++) {
    #####:  388:    A[i][i] = 2 * (d[i-1] + d[i]);
    #####:  389:    if (i > 1) {
    #####:  390:      A[i][i-1] = d[i-1];
    #####:  391:      A[i-1][i] = d[i-1];
        -:  392:    }
    #####:  393:    A[i][len-1] = 6 * (b[i+1] - b[i]);
        -:  394:  }
    #####:  395:  for(i = 1; i < len-2; i++) {
    #####:  396:    float v = A[i+1][i] / A[i][i];
    #####:  397:    for(j = 1; j <= len-1; j++)
    #####:  398:      A[i+1][j] -= v * A[i][j];
        -:  399:  }
    #####:  400:  for(i = len-2; i > 0; i--) {
        -:  401:    float acc = 0;
    #####:  402:    for(j = i; j <= len-2; j++)
    #####:  403:      acc += A[i][j]*c[j];
    #####:  404:    c[i] = (A[i][len-1] - acc) / A[i][i];
        -:  405:  }
    #####:  406:  for (i = 0; i < 0x10000; i++) {
    #####:  407:    float x_out = (float)(i / 65535.0);
        -:  408:    float y_out = 0;
    #####:  409:    for (j = 0; j < len-1; j++) {
    #####:  410:      if (x[j] <= x_out && x_out <= x[j+1]) {
    #####:  411:	float v = x_out - x[j];
    #####:  412:	y_out = y[j] +
    #####:  413:	  ((y[j+1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j+1] * d[j])/6) * v
    #####:  414:	   + (c[j] * 0.5) * v*v + ((c[j+1] - c[j]) / (6 * d[j])) * v*v*v;
        -:  415:      }
        -:  416:    }
    #####:  417:    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 :
    #####:  418:		(ushort)(y_out * 65535.0 + 0.5));
        -:  419:  }
    #####:  420:  free (A);
        -:  421:}
        -:  422:
    #####:  423:void CLASS canon_600_fixed_wb (int temp)
        -:  424:{
        -:  425:  static const short mul[4][5] = {
        -:  426:    {  667, 358,397,565,452 },
        -:  427:    {  731, 390,367,499,517 },
        -:  428:    { 1119, 396,348,448,537 },
        -:  429:    { 1399, 485,431,508,688 } };
        -:  430:  int lo, hi, i;
        -:  431:  float frac=0;
        -:  432:
    #####:  433:  for (lo=4; --lo; )
    #####:  434:    if (*mul[lo] <= temp) break;
    #####:  435:  for (hi=0; hi < 3; hi++)
    #####:  436:    if (*mul[hi] >= temp) break;
    #####:  437:  if (lo != hi)
    #####:  438:    frac = (float) (temp - *mul[lo]) / (*mul[hi] - *mul[lo]);
    #####:  439:  for (i=1; i < 5; i++)
    #####:  440:    pre_mul[i-1] = 1 / (frac * mul[hi][i] + (1-frac) * mul[lo][i]);
    #####:  441:}
        -:  442:
        -:  443:/* Return values:  0 = white  1 = near white  2 = not white */
    #####:  444:int CLASS canon_600_color (int ratio[2], int mar)
        -:  445:{
        -:  446:  int clipped=0, target, miss;
        -:  447:
    #####:  448:  if (flash_used) {
    #####:  449:    if (ratio[1] < -104)
    #####:  450:      { ratio[1] = -104; clipped = 1; }
    #####:  451:    if (ratio[1] >   12)
    #####:  452:      { ratio[1] =   12; clipped = 1; }
        -:  453:  } else {
    #####:  454:    if (ratio[1] < -264 || ratio[1] > 461) return 2;
    #####:  455:    if (ratio[1] < -50)
    #####:  456:      { ratio[1] = -50; clipped = 1; }
    #####:  457:    if (ratio[1] > 307)
    #####:  458:      { ratio[1] = 307; clipped = 1; }
        -:  459:  }
    #####:  460:  target = flash_used || ratio[1] < 197
    #####:  461:	? -38 - (398 * ratio[1] >> 10)
    #####:  462:	: -123 + (48 * ratio[1] >> 10);
    #####:  463:  if (target - mar <= ratio[0] &&
    #####:  464:      target + 20  >= ratio[0] && !clipped) return 0;
    #####:  465:  miss = target - ratio[0];
    #####:  466:  if (abs(miss) >= mar*4) return 2;
    #####:  467:  if (miss < -20) miss = -20;
    #####:  468:  if (miss > mar) miss = mar;
    #####:  469:  ratio[0] = target - miss;
    #####:  470:  return 1;
        -:  471:}
        -:  472:
    #####:  473:void CLASS canon_600_auto_wb()
        -:  474:{
    #####:  475:  int mar, row, col, i, j, st, count[] = { 0,0 };
        -:  476:  int test[8], total[2][8], ratio[2][2], stat[2];
        -:  477:
    #####:  478:  memset (&total, 0, sizeof total);
    #####:  479:  i = canon_ev + 0.5;
    #####:  480:  if      (i < 10) mar = 150;
    #####:  481:  else if (i > 12) mar = 20;
    #####:  482:  else mar = 280 - 20 * i;
    #####:  483:  if (flash_used) mar = 80;
    #####:  484:  for (row=14; row < height-14; row+=4)
    #####:  485:    for (col=10; col < width; col+=2) {
    #####:  486:      for (i=0; i < 8; i++)
    #####:  487:	test[(i & 4) + FC(row+(i >> 1),col+(i & 1))] =
    #####:  488:		    BAYER(row+(i >> 1),col+(i & 1));
    #####:  489:      for (i=0; i < 8; i++)
    #####:  490:	if (test[i] < 150 || test[i] > 1500) goto next;
    #####:  491:      for (i=0; i < 4; i++)
    #####:  492:	if (abs(test[i] - test[i+4]) > 50) goto next;
    #####:  493:      for (i=0; i < 2; i++) {
    #####:  494:	for (j=0; j < 4; j+=2)
    #####:  495:	  ratio[i][j >> 1] = ((test[i*4+j+1]-test[i*4+j]) << 10) / test[i*4+j];
    #####:  496:	stat[i] = canon_600_color (ratio[i], mar);
        -:  497:      }
    #####:  498:      if ((st = stat[0] | stat[1]) > 1) goto next;
    #####:  499:      for (i=0; i < 2; i++)
    #####:  500:	if (stat[i])
    #####:  501:	  for (j=0; j < 2; j++)
    #####:  502:	    test[i*4+j*2+1] = test[i*4+j*2] * (0x400 + ratio[i][j]) >> 10;
    #####:  503:      for (i=0; i < 8; i++)
    #####:  504:	total[st][i] += test[i];
    #####:  505:      count[st]++;
    #####:  506:next: ;
        -:  507:    }
    #####:  508:  if (count[0] | count[1]) {
    #####:  509:    st = count[0]*200 < count[1];
    #####:  510:    for (i=0; i < 4; i++)
    #####:  511:      pre_mul[i] = 1.0 / (total[st][i] + total[st][i+4]);
        -:  512:  }
    #####:  513:}
        -:  514:
    #####:  515:void CLASS canon_600_coeff()
        -:  516:{
        -:  517:  static const short table[6][12] = {
        -:  518:    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },
        -:  519:    { -1203,1715,-1136,1648, 1388,-876,267,245,  -1641,2153,3921,-3409 },
        -:  520:    { -615,1127,-1563,2075,  1437,-925,509,3,     -756,1268,2519,-2007 },
        -:  521:    { -190,702,-1886,2398,   2153,-1641,763,-251, -452,964,3040,-2528  },
        -:  522:    { -190,702,-1878,2390,   1861,-1349,905,-393, -432,944,2617,-2105  },
        -:  523:    { -807,1319,-1785,2297,  1388,-876,769,-257,  -230,742,2067,-1555  } };
        -:  524:  int t=0, i, c;
        -:  525:  float mc, yc;
        -:  526:
    #####:  527:  mc = pre_mul[1] / pre_mul[2];
    #####:  528:  yc = pre_mul[3] / pre_mul[2];
    #####:  529:  if (mc > 1 && mc <= 1.28 && yc < 0.8789) t=1;
    #####:  530:  if (mc > 1.28 && mc <= 2) {
    #####:  531:    if  (yc < 0.8789) t=3;
    #####:  532:    else if (yc <= 2) t=4;
        -:  533:  }
    #####:  534:  if (flash_used) t=5;
    #####:  535:  for (raw_color = i=0; i < 3; i++)
    #####:  536:    FORCC rgb_cam[i][c] = table[t][i*4 + c] / 1024.0;
    #####:  537:}
        -:  538:
    #####:  539:void CLASS canon_600_load_raw()
        -:  540:{
        -:  541:  uchar  data[1120], *dp;
        -:  542:  ushort *pix;
        -:  543:  int irow, row;
        -:  544:
    #####:  545:  for (irow=row=0; irow < height; irow++) {
    #####:  546:    if (fread (data, 1, 1120, ifp) < 1120) derror();
    #####:  547:    pix = raw_image + row*raw_width;
    #####:  548:    for (dp=data; dp < data+1120;  dp+=10, pix+=8) {
    #####:  549:      pix[0] = (dp[0] << 2) + (dp[1] >> 6    );
    #####:  550:      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);
    #####:  551:      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);
    #####:  552:      pix[3] = (dp[4] << 2) + (dp[1]      & 3);
    #####:  553:      pix[4] = (dp[5] << 2) + (dp[9]      & 3);
    #####:  554:      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);
    #####:  555:      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);
    #####:  556:      pix[7] = (dp[8] << 2) + (dp[9] >> 6    );
        -:  557:    }
    #####:  558:    if ((row+=2) > height) row = 1;
        -:  559:  }
    #####:  560:}
        -:  561:
    #####:  562:void CLASS canon_600_correct()
        -:  563:{
        -:  564:  int row, col, val;
        -:  565:  static const short mul[4][2] =
        -:  566:  { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };
        -:  567:
    #####:  568:  for (row=0; row < height; row++)
    #####:  569:    for (col=0; col < width; col++) {
    #####:  570:      if ((val = BAYER(row,col) - black) < 0) val = 0;
    #####:  571:      val = val * mul[row & 3][col & 1] >> 9;
    #####:  572:      BAYER(row,col) = val;
        -:  573:    }
    #####:  574:  canon_600_fixed_wb(1311);
    #####:  575:  canon_600_auto_wb();
    #####:  576:  canon_600_coeff();
    #####:  577:  maximum = (0x3ff - black) * 1109 >> 9;
    #####:  578:  black = 0;
    #####:  579:}
        -:  580:
    #####:  581:int CLASS canon_s2is()
        -:  582:{
        -:  583:  unsigned row;
        -:  584:
    #####:  585:  for (row=0; row < 100; row++) {
    #####:  586:    fseek (ifp, row*3340 + 3284, SEEK_SET);
    #####:  587:    if (getc(ifp) > 15) return 1;
        -:  588:  }
        -:  589:  return 0;
        -:  590:}
        -:  591:
 38305792:  592:unsigned CLASS getbithuff (int nbits, ushort *huff)
        -:  593:{
        -:  594:  static unsigned bitbuf=0;
        -:  595:  static int vbits=0, reset=0;
        -:  596:  unsigned c;
        -:  597:
 38305792:  598:  if (nbits > 25) return 0;
 38305792:  599:  if (nbits < 0)
        1:  600:    return bitbuf = vbits = reset = 0;
 38305792:  601:  if (nbits == 0 || vbits < 0) return 0;
 99128981:  602:  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&
 20410988:  603:    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {
 20364760:  604:    bitbuf = (bitbuf << 8) + (uchar) c;
 20364760:  605:    vbits += 8;
        -:  606:  }
 38034701:  607:  c = bitbuf << (32-vbits) >> (32-nbits);
 38034701:  608:  if (huff) {
 19152896:  609:    vbits -= huff[c] >> 8;
 19152896:  610:    c = (uchar) huff[c];
        -:  611:  } else
 18881805:  612:    vbits -= nbits;
 38034701:  613:  if (vbits < 0) derror();
        -:  614:  return c;
        -:  615:}
        -:  616:
        -:  617:#define getbits(n) getbithuff(n,0)
        -:  618:#define gethuff(h) getbithuff(*h,h+1)
        -:  619:
        -:  620:/*
        -:  621:   Construct a decode tree according the specification in *source.
        -:  622:   The first 16 bytes specify how many codes should be 1-bit, 2-bit
        -:  623:   3-bit, etc.  Bytes after that are the leaf values.
        -:  624:
        -:  625:   For example, if the source is
        -:  626:
        -:  627:    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
        -:  628:      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },
        -:  629:
        -:  630:   then the code is
        -:  631:
        -:  632:	00		0x04
        -:  633:	010		0x03
        -:  634:	011		0x05
        -:  635:	100		0x06
        -:  636:	101		0x02
        -:  637:	1100		0x07
        -:  638:	1101		0x01
        -:  639:	11100		0x08
        -:  640:	11101		0x09
        -:  641:	11110		0x00
        -:  642:	111110		0x0a
        -:  643:	1111110		0x0b
        -:  644:	1111111		0xff
        -:  645: */
        2:  646:ushort * CLASS make_decoder_ref (const uchar **source)
        -:  647:{
        -:  648:  int max, len, h, i, j;
        -:  649:  const uchar *count;
        -:  650:  ushort *huff;
        -:  651:
        2:  652:  count = (*source += 16) - 17;
        2:  653:  for (max=16; max && !count[max]; max--);
        2:  654:  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);
        2:  655:  merror (huff, "make_decoder()");
        2:  656:  huff[0] = max;
       22:  657:  for (h=len=1; len <= max; len++)
       30:  658:    for (i=0; i < count[len]; i++, ++*source)
     2046:  659:      for (j=0; j < 1 << (max-len); j++)
     2046:  660:	if (h <= 1 << max)
     2046:  661:	  huff[h++] = len << 8 | **source;
        2:  662:  return huff;
        -:  663:}
        -:  664:
    #####:  665:ushort * CLASS make_decoder (const uchar *source)
        -:  666:{
    #####:  667:  return make_decoder_ref (&source);
        -:  668:}
        -:  669:
    #####:  670:void CLASS crw_init_tables (unsigned table, ushort *huff[2])
        -:  671:{
        -:  672:  static const uchar first_tree[3][29] = {
        -:  673:    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
        -:  674:      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },
        -:  675:    { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,
        -:  676:      0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },
        -:  677:    { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,
        -:  678:      0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },
        -:  679:  };
        -:  680:  static const uchar second_tree[3][180] = {
        -:  681:    { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,
        -:  682:      0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,
        -:  683:      0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,
        -:  684:      0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,
        -:  685:      0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,
        -:  686:      0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,
        -:  687:      0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,
        -:  688:      0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,
        -:  689:      0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,
        -:  690:      0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,
        -:  691:      0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,
        -:  692:      0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,
        -:  693:      0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,
        -:  694:      0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,
        -:  695:      0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },
        -:  696:    { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,
        -:  697:      0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,
        -:  698:      0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,
        -:  699:      0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,
        -:  700:      0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,
        -:  701:      0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,
        -:  702:      0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,
        -:  703:      0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,
        -:  704:      0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,
        -:  705:      0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,
        -:  706:      0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,
        -:  707:      0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,
        -:  708:      0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,
        -:  709:      0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,
        -:  710:      0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },
        -:  711:    { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,
        -:  712:      0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,
        -:  713:      0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,
        -:  714:      0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,
        -:  715:      0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,
        -:  716:      0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,
        -:  717:      0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,
        -:  718:      0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,
        -:  719:      0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,
        -:  720:      0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,
        -:  721:      0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,
        -:  722:      0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,
        -:  723:      0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,
        -:  724:      0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,
        -:  725:      0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }
        -:  726:  };
    #####:  727:  if (table > 2) table = 2;
    #####:  728:  huff[0] = make_decoder ( first_tree[table]);
    #####:  729:  huff[1] = make_decoder (second_tree[table]);
    #####:  730:}
        -:  731:
        -:  732:/*
        -:  733:   Return 0 if the image starts with compressed data,
        -:  734:   1 if it starts with uncompressed low-order bits.
        -:  735:
        -:  736:   In Canon compressed data, 0xff is always followed by 0x00.
        -:  737: */
    #####:  738:int CLASS canon_has_lowbits()
        -:  739:{
        -:  740:  uchar test[0x4000];
        -:  741:  int ret=1, i;
        -:  742:
    #####:  743:  fseek (ifp, 0, SEEK_SET);
    #####:  744:  fread (test, 1, sizeof test, ifp);
    #####:  745:  for (i=540; i < sizeof test - 1; i++)
    #####:  746:    if (test[i] == 0xff) {
    #####:  747:      if (test[i+1]) return 1;
        -:  748:      ret=0;
        -:  749:    }
        -:  750:  return ret;
        -:  751:}
        -:  752:
    #####:  753:void CLASS canon_load_raw()
        -:  754:{
        -:  755:  ushort *pixel, *prow, *huff[2];
        -:  756:  int nblocks, lowbits, i, c, row, r, save, val;
        -:  757:  int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];
        -:  758:
    #####:  759:  crw_init_tables (tiff_compress, huff);
    #####:  760:  lowbits = canon_has_lowbits();
    #####:  761:  if (!lowbits) maximum = 0x3ff;
    #####:  762:  fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);
    #####:  763:  zero_after_ff = 1;
        -:  764:  getbits(-1);
    #####:  765:  for (row=0; row < raw_height; row+=8) {
    #####:  766:    pixel = raw_image + row*raw_width;
    #####:  767:    nblocks = MIN (8, raw_height-row) * raw_width >> 6;
    #####:  768:    for (block=0; block < nblocks; block++) {
    #####:  769:      memset (diffbuf, 0, sizeof diffbuf);
    #####:  770:      for (i=0; i < 64; i++ ) {
    #####:  771:	leaf = gethuff(huff[i > 0]);
    #####:  772:	if (leaf == 0 && i) break;
    #####:  773:	if (leaf == 0xff) continue;
    #####:  774:	i  += leaf >> 4;
    #####:  775:	len = leaf & 15;
    #####:  776:	if (len == 0) continue;
    #####:  777:	diff = getbits(len);
    #####:  778:	if ((diff & (1 << (len-1))) == 0)
    #####:  779:	  diff -= (1 << len) - 1;
    #####:  780:	if (i < 64) diffbuf[i] = diff;
        -:  781:      }
    #####:  782:      diffbuf[0] += carry;
        -:  783:      carry = diffbuf[0];
    #####:  784:      for (i=0; i < 64; i++ ) {
    #####:  785:	if (pnum++ % raw_width == 0)
    #####:  786:	  base[0] = base[1] = 512;
    #####:  787:	if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)
    #####:  788:	  derror();
        -:  789:      }
        -:  790:    }
    #####:  791:    if (lowbits) {
    #####:  792:      save = ftell(ifp);
    #####:  793:      fseek (ifp, 26 + row*raw_width/4, SEEK_SET);
    #####:  794:      for (prow=pixel, i=0; i < raw_width*2; i++) {
    #####:  795:	c = fgetc(ifp);
    #####:  796:	for (r=0; r < 8; r+=2, prow++) {
    #####:  797:	  val = (*prow << 2) + ((c >> r) & 3);
    #####:  798:	  if (raw_width == 2672 && val < 512) val += 2;
    #####:  799:	  *prow = val;
        -:  800:	}
        -:  801:      }
    #####:  802:      fseek (ifp, save, SEEK_SET);
        -:  803:    }
        -:  804:  }
    #####:  805:  FORC(2) free (huff[c]);
    #####:  806:}
        -:  807:
        -:  808:struct jhead {
        -:  809:  int algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];
        -:  810:  ushort quant[64], idct[64], *huff[20], *free[20], *row;
        -:  811:};
        -:  812:
        3:  813:int CLASS ljpeg_start (struct jhead *jh, int info_only)
        -:  814:{
        -:  815:  ushort c, tag, len;
        -:  816:  uchar data[0x10000];
        -:  817:  const uchar *dp;
        -:  818:
        3:  819:  memset (jh, 0, sizeof *jh);
        3:  820:  jh->restart = INT_MAX;
        9:  821:  if ((fgetc(ifp),fgetc(ifp)) != 0xd8) return 0;
        -:  822:  do {
       10:  823:    if (!fread (data, 2, 2, ifp)) return 0;
       10:  824:    tag =  data[0] << 8 | data[1];
       10:  825:    len = (data[2] << 8 | data[3]) - 2;
       10:  826:    if (tag <= 0xff00) return 0;
       10:  827:    fread (data, 1, len, ifp);
       10:  828:    switch (tag) {
        2:  829:      case 0xffc3:
        2:  830:	jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;
        3:  831:      case 0xffc1:
        -:  832:      case 0xffc0:
        3:  833:	jh->algo = tag & 0xff;
        3:  834:	jh->bits = data[0];
        3:  835:	jh->high = data[1] << 8 | data[2];
        3:  836:	jh->wide = data[3] << 8 | data[4];
        3:  837:	jh->clrs = data[5] + jh->sraw;
        3:  838:	if (len == 9 && !dng_version) getc(ifp);
        -:  839:	break;
        3:  840:      case 0xffc4:
        3:  841:	if (info_only) break;
        4:  842:	for (dp = data; dp < data+len && !((c = *dp++) & -20); )
        2:  843:	  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);
        -:  844:	break;
        3:  845:      case 0xffda:
        3:  846:	jh->psv = data[1+data[0]*2];
        3:  847:	jh->bits -= data[3+data[0]*2] & 15;
        3:  848:	break;
        -:  849:      case 0xffdb:
       64:  850:	FORC(64) jh->quant[c] = data[c*2+1] << 8 | data[c*2+2];
        -:  851:	break;
    #####:  852:      case 0xffdd:
    #####:  853:	jh->restart = data[0] << 8 | data[1];
        -:  854:    }
       10:  855:  } while (tag != 0xffda);
        3:  856:  if (jh->bits > 16 || jh->clrs > 6 ||
        3:  857:     !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0;
        3:  858:  if (info_only) return 1;
        1:  859:  if (!jh->huff[0]) return 0;
       19:  860:  FORC(19) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];
        1:  861:  if (jh->sraw) {
    #####:  862:    FORC(4)        jh->huff[2+c] = jh->huff[1];
    #####:  863:    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];
        -:  864:  }
        1:  865:  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);
        1:  866:  merror (jh->row, "ljpeg_start()");
        1:  867:  return zero_after_ff = 1;
        -:  868:}
        -:  869:
        1:  870:void CLASS ljpeg_end (struct jhead *jh)
        -:  871:{
        -:  872:  int c;
        1:  873:  FORC4 if (jh->free[c]) free (jh->free[c]);
        1:  874:  free (jh->row);
        1:  875:}
        -:  876:
 19152896:  877:int CLASS ljpeg_diff (ushort *huff)
        -:  878:{
        -:  879:  int len, diff;
        -:  880:
 19152896:  881:  len = gethuff(huff);
 19152896:  882:  if (len == 16 && (!dng_version || dng_version >= 0x1010000))
        -:  883:    return -32768;
 19152896:  884:  diff = getbits(len);
 19152896:  885:  if ((diff & (1 << (len-1))) == 0)
  9804713:  886:    diff -= (1 << len) - 1;
        -:  887:  return diff;
        -:  888:}
        -:  889:
     3584:  890:ushort * CLASS ljpeg_row (int jrow, struct jhead *jh)
        -:  891:{
        -:  892:  int col, c, diff, pred, spred=0;
        -:  893:  ushort mark=0, *row[3];
        -:  894:
     3584:  895:  if (jrow * jh->wide % jh->restart == 0) {
        6:  896:    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);
        1:  897:    if (jrow) {
    #####:  898:      fseek (ifp, -2, SEEK_CUR);
    #####:  899:      do mark = (mark << 8) + (c = fgetc(ifp));
    #####:  900:      while (c != EOF && mark >> 4 != 0xffd);
        -:  901:    }
        -:  902:    getbits(-1);
        -:  903:  }
    10752:  904:  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);
  9576448:  905:  for (col=0; col < jh->wide; col++)
 19152896:  906:    FORC(jh->clrs) {
 19152896:  907:      diff = ljpeg_diff (jh->huff[c]);
 19152896:  908:      if (jh->sraw && c <= jh->sraw && (col | c))
        -:  909:		    pred = spred;
 19152896:  910:      else if (col) pred = row[0][-jh->clrs];
     7168:  911:      else	    pred = (jh->vpred[c] += diff) - diff;
 38293282:  912:      if (jrow && col) switch (jh->psv) {
        -:  913:	case 1:	break;
    #####:  914:	case 2: pred = row[1][0];					break;
    #####:  915:	case 3: pred = row[1][-jh->clrs];				break;
    #####:  916:	case 4: pred = pred +   row[1][0] - row[1][-jh->clrs];		break;
    #####:  917:	case 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);	break;
    #####:  918:	case 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);	break;
    #####:  919:	case 7: pred = (pred + row[1][0]) >> 1;				break;
    #####:  920:	default: pred = 0;
        -:  921:      }
 19165406:  922:      if ((**row = pred + diff) >> jh->bits) derror();
 19152896:  923:      if (c <= jh->sraw) spred = **row;
 19152896:  924:      row[0]++; row[1]++;
        -:  925:    }
     3584:  926:  return row[2];
        -:  927:}
        -:  928:
        1:  929:void CLASS lossless_jpeg_load_raw()
        -:  930:{
        -:  931:  int jwide, jrow, jcol, val, jidx, i, j, row=0, col=0;
        -:  932:  struct jhead jh;
        -:  933:  ushort *rp;
        -:  934:
        1:  935:  if (!ljpeg_start (&jh, 0)) return;
        1:  936:  jwide = jh.wide * jh.clrs;
        -:  937:
     3585:  938:  for (jrow=0; jrow < jh.high; jrow++) {
     3584:  939:    rp = ljpeg_row (jrow, &jh);
     3584:  940:    if (load_flags & 1)
    #####:  941:      row = jrow & 1 ? height-1-jrow/2 : jrow/2;
 19152896:  942:    for (jcol=0; jcol < jwide; jcol++) {
 19152896:  943:      val = curve[*rp++];
 19152896:  944:      if (cr2_slice[0]) {
 19152896:  945:	jidx = jrow*jwide + jcol;
 19152896:  946:	i = jidx / (cr2_slice[1]*raw_height);
 19152896:  947:	if ((j = i >= cr2_slice[0]))
        -:  948:		 i  = cr2_slice[0];
 19152896:  949:	jidx -= i * (cr2_slice[1]*raw_height);
 19152896:  950:	row = jidx / cr2_slice[1+j];
 19152896:  951:	col = jidx % cr2_slice[1+j] + i*cr2_slice[1];
        -:  952:      }
 19152896:  953:      if (raw_width == 3984 && (col -= 2) < 0)
    #####:  954:	col += (row--,raw_width);
 19152896:  955:      if ((unsigned) row < raw_height) RAW(row,col) = val;
 19152896:  956:      if (++col >= raw_width)
     3584:  957:	col = (row++,0);
        -:  958:    }
        -:  959:  }
        1:  960:  ljpeg_end (&jh);
        -:  961:}
        -:  962:
    #####:  963:void CLASS canon_sraw_load_raw()
        -:  964:{
        -:  965:  struct jhead jh;
        -:  966:  short *rp=0, (*ip)[4];
        -:  967:  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;
    #####:  968:  int v[3]={0,0,0}, ver, hue;
        -:  969:  char *cp;
        -:  970:
    #####:  971:  if (!ljpeg_start (&jh, 0) || jh.clrs < 4) return;
    #####:  972:  jwide = (jh.wide >>= 1) * jh.clrs;
        -:  973:
    #####:  974:  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {
        -:  975:    scol = ecol;
    #####:  976:    ecol += cr2_slice[1] * 2 / jh.clrs;
    #####:  977:    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;
    #####:  978:    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {
    #####:  979:      ip = (short (*)[4]) image + row*width;
    #####:  980:      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {
    #####:  981:	if ((jcol %= jwide) == 0)
    #####:  982:	  rp = (short *) ljpeg_row (jrow++, &jh);
    #####:  983:	if (col >= width) continue;
    #####:  984:	FORC (jh.clrs-2)
    #####:  985:	  ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];
    #####:  986:	ip[col][1] = rp[jcol+jh.clrs-2] - 16384;
    #####:  987:	ip[col][2] = rp[jcol+jh.clrs-1] - 16384;
        -:  988:      }
        -:  989:    }
        -:  990:  }
    #####:  991:  for (cp=model2; *cp && !isdigit(*cp); cp++);
    #####:  992:  sscanf (cp, "%d.%d.%d", v, v+1, v+2);
    #####:  993:  ver = (v[0]*1000 + v[1])*1000 + v[2];
    #####:  994:  hue = (jh.sraw+1) << 2;
    #####:  995:  if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))
    #####:  996:    hue = jh.sraw << 1;
    #####:  997:  ip = (short (*)[4]) image;
        -:  998:  rp = ip[0];
    #####:  999:  for (row=0; row < height; row++, ip+=width) {
    #####: 1000:    if (row & (jh.sraw >> 1))
    #####: 1001:      for (col=0; col < width; col+=2)
    #####: 1002:	for (c=1; c < 3; c++)
    #####: 1003:	  if (row == height-1)
    #####: 1004:	       ip[col][c] =  ip[col-width][c];
    #####: 1005:	  else ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;
    #####: 1006:    for (col=1; col < width; col+=2)
    #####: 1007:      for (c=1; c < 3; c++)
    #####: 1008:	if (col == width-1)
    #####: 1009:	     ip[col][c] =  ip[col-1][c];
    #####: 1010:	else ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;
        -: 1011:  }
    #####: 1012:  for ( ; rp < ip[0]; rp+=4) {
    #####: 1013:    if (unique_id == 0x80000218 ||
    #####: 1014:	unique_id == 0x80000250 ||
    #####: 1015:	unique_id == 0x80000261 ||
    #####: 1016:	unique_id == 0x80000281 ||
        -: 1017:	unique_id == 0x80000287) {
    #####: 1018:      rp[1] = (rp[1] << 2) + hue;
    #####: 1019:      rp[2] = (rp[2] << 2) + hue;
    #####: 1020:      pix[0] = rp[0] + ((   50*rp[1] + 22929*rp[2]) >> 14);
    #####: 1021:      pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);
    #####: 1022:      pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);
        -: 1023:    } else {
    #####: 1024:      if (unique_id < 0x80000218) rp[0] -= 512;
    #####: 1025:      pix[0] = rp[0] + rp[2];
    #####: 1026:      pix[2] = rp[0] + rp[1];
    #####: 1027:      pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12);
        -: 1028:    }
    #####: 1029:    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);
        -: 1030:  }
    #####: 1031:  ljpeg_end (&jh);
    #####: 1032:  maximum = 0x3fff;
        -: 1033:}
        -: 1034:
    #####: 1035:void CLASS adobe_copy_pixel (unsigned row, unsigned col, ushort **rp)
        -: 1036:{
        -: 1037:  int c;
        -: 1038:
    #####: 1039:  if (tiff_samples == 2 && shot_select) (*rp)++;
    #####: 1040:  if (raw_image) {
    #####: 1041:    if (row < raw_height && col < raw_width)
    #####: 1042:      RAW(row,col) = curve[**rp];
    #####: 1043:    *rp += tiff_samples;
        -: 1044:  } else {
    #####: 1045:    if (row < height && col < width)
    #####: 1046:      FORC(tiff_samples)
    #####: 1047:	image[row*width+col][c] = curve[(*rp)[c]];
    #####: 1048:    *rp += tiff_samples;
        -: 1049:  }
    #####: 1050:  if (tiff_samples == 2 && shot_select) (*rp)--;
    #####: 1051:}
        -: 1052:
    #####: 1053:void CLASS ljpeg_idct (struct jhead *jh)
        -: 1054:{
        -: 1055:  int c, i, j, len, skip, coef;
        -: 1056:  float work[3][8][8];
        -: 1057:  static float cs[106] = { 0 };
        -: 1058:  static const uchar zigzag[80] =
        -: 1059:  {  0, 1, 8,16, 9, 2, 3,10,17,24,32,25,18,11, 4, 5,12,19,26,33,
        -: 1060:    40,48,41,34,27,20,13, 6, 7,14,21,28,35,42,49,56,57,50,43,36,
        -: 1061:    29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,
        -: 1062:    47,55,62,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63 };
        -: 1063:
    #####: 1064:  if (!cs[0])
    #####: 1065:    FORC(106) cs[c] = cos((c & 31)*M_PI/16)/2;
    #####: 1066:  memset (work, 0, sizeof work);
    #####: 1067:  work[0][0][0] = jh->vpred[0] += ljpeg_diff (jh->huff[0]) * jh->quant[0];
    #####: 1068:  for (i=1; i < 64; i++ ) {
    #####: 1069:    len = gethuff (jh->huff[16]);
    #####: 1070:    i += skip = len >> 4;
    #####: 1071:    if (!(len &= 15) && skip < 15) break;
    #####: 1072:    coef = getbits(len);
    #####: 1073:    if ((coef & (1 << (len-1))) == 0)
    #####: 1074:      coef -= (1 << len) - 1;
    #####: 1075:    ((float *)work)[zigzag[i]] = coef * jh->quant[i];
        -: 1076:  }
    #####: 1077:  FORC(8) work[0][0][c] *= M_SQRT1_2;
    #####: 1078:  FORC(8) work[0][c][0] *= M_SQRT1_2;
    #####: 1079:  for (i=0; i < 8; i++)
    #####: 1080:    for (j=0; j < 8; j++)
    #####: 1081:      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j*2+1)*c];
    #####: 1082:  for (i=0; i < 8; i++)
    #####: 1083:    for (j=0; j < 8; j++)
    #####: 1084:      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i*2+1)*c];
        -: 1085:
    #####: 1086:  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c]+0.5);
    #####: 1087:}
        -: 1088:
    #####: 1089:void CLASS lossless_dng_load_raw()
        -: 1090:{
        -: 1091:  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col, i, j;
        -: 1092:  struct jhead jh;
        -: 1093:  ushort *rp;
        -: 1094:
    #####: 1095:  while (trow < raw_height) {
    #####: 1096:    save = ftell(ifp);
    #####: 1097:    if (tile_length < INT_MAX)
    #####: 1098:      fseek (ifp, get4(), SEEK_SET);
    #####: 1099:    if (!ljpeg_start (&jh, 0)) break;
    #####: 1100:    jwide = jh.wide;
    #####: 1101:    if (filters) jwide *= jh.clrs;
    #####: 1102:    jwide /= MIN (is_raw, tiff_samples);
    #####: 1103:    switch (jh.algo) {
    #####: 1104:      case 0xc1:
    #####: 1105:	jh.vpred[0] = 16384;
        -: 1106:	getbits(-1);
    #####: 1107:	for (jrow=0; jrow+7 < jh.high; jrow += 8) {
    #####: 1108:	  for (jcol=0; jcol+7 < jh.wide; jcol += 8) {
    #####: 1109:	    ljpeg_idct (&jh);
    #####: 1110:	    rp = jh.idct;
    #####: 1111:	    row = trow + jcol/tile_width + jrow*2;
    #####: 1112:	    col = tcol + jcol%tile_width;
    #####: 1113:	    for (i=0; i < 16; i+=2)
    #####: 1114:	      for (j=0; j < 8; j++)
    #####: 1115:		adobe_copy_pixel (row+i, col+j, &rp);
        -: 1116:	  }
        -: 1117:	}
        -: 1118:	break;
        -: 1119:      case 0xc3:
    #####: 1120:	for (row=col=jrow=0; jrow < jh.high; jrow++) {
    #####: 1121:	  rp = ljpeg_row (jrow, &jh);
    #####: 1122:	  for (jcol=0; jcol < jwide; jcol++) {
    #####: 1123:	    adobe_copy_pixel (trow+row, tcol+col, &rp);
    #####: 1124:	    if (++col >= tile_width || col >= raw_width)
    #####: 1125:	      row += 1 + (col = 0);
        -: 1126:	  }
        -: 1127:	}
        -: 1128:    }
    #####: 1129:    fseek (ifp, save+4, SEEK_SET);
    #####: 1130:    if ((tcol += tile_width) >= raw_width)
    #####: 1131:      trow += tile_length + (tcol = 0);
    #####: 1132:    ljpeg_end (&jh);
        -: 1133:  }
    #####: 1134:}
        -: 1135:
    #####: 1136:void CLASS packed_dng_load_raw()
        -: 1137:{
        -: 1138:  ushort *pixel, *rp;
        -: 1139:  int row, col;
        -: 1140:
    #####: 1141:  pixel = (ushort *) calloc (raw_width, tiff_samples*sizeof *pixel);
    #####: 1142:  merror (pixel, "packed_dng_load_raw()");
    #####: 1143:  for (row=0; row < raw_height; row++) {
    #####: 1144:    if (tiff_bps == 16)
    #####: 1145:      read_shorts (pixel, raw_width * tiff_samples);
        -: 1146:    else {
        -: 1147:      getbits(-1);
    #####: 1148:      for (col=0; col < raw_width * tiff_samples; col++)
    #####: 1149:	pixel[col] = getbits(tiff_bps);
        -: 1150:    }
    #####: 1151:    for (rp=pixel, col=0; col < raw_width; col++)
    #####: 1152:      adobe_copy_pixel (row, col, &rp);
        -: 1153:  }
    #####: 1154:  free (pixel);
    #####: 1155:}
        -: 1156:
    #####: 1157:void CLASS pentax_load_raw()
        -: 1158:{
        -: 1159:  ushort bit[2][15], huff[4097];
        -: 1160:  int dep, row, col, diff, c, i;
    #####: 1161:  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];
        -: 1162:
    #####: 1163:  fseek (ifp, meta_offset, SEEK_SET);
    #####: 1164:  dep = (get2() + 12) & 15;
    #####: 1165:  fseek (ifp, 12, SEEK_CUR);
    #####: 1166:  FORC(dep) bit[0][c] = get2();
    #####: 1167:  FORC(dep) bit[1][c] = fgetc(ifp);
    #####: 1168:  FORC(dep)
    #####: 1169:    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )
    #####: 1170:      huff[++i] = bit[1][c] << 8 | c;
    #####: 1171:  huff[0] = 12;
    #####: 1172:  fseek (ifp, data_offset, SEEK_SET);
        -: 1173:  getbits(-1);
    #####: 1174:  for (row=0; row < raw_height; row++)
    #####: 1175:    for (col=0; col < raw_width; col++) {
    #####: 1176:      diff = ljpeg_diff (huff);
    #####: 1177:      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
    #####: 1178:      else	   hpred[col & 1] += diff;
    #####: 1179:      RAW(row,col) = hpred[col & 1];
    #####: 1180:      if (hpred[col & 1] >> tiff_bps) derror();
        -: 1181:    }
    #####: 1182:}
        -: 1183:
    #####: 1184:void CLASS nikon_load_raw()
        -: 1185:{
        -: 1186:  static const uchar nikon_tree[][32] = {
        -: 1187:    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy */
        -: 1188:      5,4,3,6,2,7,1,0,8,9,11,10,12 },
        -: 1189:    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy after split */
        -: 1190:      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },
        -: 1191:    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */
        -: 1192:      5,4,6,3,7,2,8,1,9,0,10,11,12 },
        -: 1193:    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,	/* 14-bit lossy */
        -: 1194:      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },
        -: 1195:    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,	/* 14-bit lossy after split */
        -: 1196:      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },
        -: 1197:    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,	/* 14-bit lossless */
        -: 1198:      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };
        -: 1199:  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;
        -: 1200:  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;
        -: 1201:
    #####: 1202:  fseek (ifp, meta_offset, SEEK_SET);
    #####: 1203:  ver0 = fgetc(ifp);
    #####: 1204:  ver1 = fgetc(ifp);
    #####: 1205:  if (ver0 == 0x49 || ver1 == 0x58)
    #####: 1206:    fseek (ifp, 2110, SEEK_CUR);
    #####: 1207:  if (ver0 == 0x46) tree = 2;
    #####: 1208:  if (tiff_bps == 14) tree += 3;
    #####: 1209:  read_shorts (vpred[0], 4);
    #####: 1210:  max = 1 << tiff_bps & 0x7fff;
    #####: 1211:  if ((csize = get2()) > 1)
    #####: 1212:    step = max / (csize-1);
    #####: 1213:  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {
    #####: 1214:    for (i=0; i < csize; i++)
    #####: 1215:      curve[i*step] = get2();
    #####: 1216:    for (i=0; i < max; i++)
    #####: 1217:      curve[i] = ( curve[i-i%step]*(step-i%step) +
    #####: 1218:		   curve[i-i%step+step]*(i%step) ) / step;
    #####: 1219:    fseek (ifp, meta_offset+562, SEEK_SET);
    #####: 1220:    split = get2();
    #####: 1221:  } else if (ver0 != 0x46 && csize <= 0x4001)
    #####: 1222:    read_shorts (curve, max=csize);
    #####: 1223:  while (curve[max-2] == curve[max-1]) max--;
    #####: 1224:  huff = make_decoder (nikon_tree[tree]);
    #####: 1225:  fseek (ifp, data_offset, SEEK_SET);
        -: 1226:  getbits(-1);
    #####: 1227:  for (min=row=0; row < height; row++) {
    #####: 1228:    if (split && row == split) {
    #####: 1229:      free (huff);
    #####: 1230:      huff = make_decoder (nikon_tree[tree+1]);
    #####: 1231:      max += (min = 16) << 1;
        -: 1232:    }
    #####: 1233:    for (col=0; col < raw_width; col++) {
    #####: 1234:      i = gethuff(huff);
    #####: 1235:      len = i & 15;
    #####: 1236:      shl = i >> 4;
    #####: 1237:      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;
    #####: 1238:      if ((diff & (1 << (len-1))) == 0)
    #####: 1239:	diff -= (1 << len) - !shl;
    #####: 1240:      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
    #####: 1241:      else	   hpred[col & 1] += diff;
    #####: 1242:      if ((ushort)(hpred[col & 1] + min) >= max) derror();
    #####: 1243:      RAW(row,col) = curve[LIM((short)hpred[col & 1],0,0x3fff)];
        -: 1244:    }
        -: 1245:  }
    #####: 1246:  free (huff);
    #####: 1247:}
        -: 1248:
    #####: 1249:void CLASS nikon_yuv_load_raw()
        -: 1250:{
        -: 1251:  int row, col, yuv[4], rgb[3], b, c;
        -: 1252:  UINT64 bitbuf=0;
        -: 1253:
    #####: 1254:  for (row=0; row < raw_height; row++)
    #####: 1255:    for (col=0; col < raw_width; col++) {
    #####: 1256:      if (!(b = col & 1)) {
        -: 1257:	bitbuf = 0;
    #####: 1258:	FORC(6) bitbuf |= (UINT64) fgetc(ifp) << c*8;
    #####: 1259:	FORC(4) yuv[c] = (bitbuf >> c*12 & 0xfff) - (c >> 1 << 11);
        -: 1260:      }
    #####: 1261:      rgb[0] = yuv[b] + 1.370705*yuv[3];
    #####: 1262:      rgb[1] = yuv[b] - 0.337633*yuv[2] - 0.698001*yuv[3];
    #####: 1263:      rgb[2] = yuv[b] + 1.732446*yuv[2];
    #####: 1264:      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,0xfff)] / cam_mul[c];
        -: 1265:    }
    #####: 1266:}
        -: 1267:
        -: 1268:/*
        -: 1269:   Returns 1 for a Coolpix 995, 0 for anything else.
        -: 1270: */
    #####: 1271:int CLASS nikon_e995()
        -: 1272:{
        -: 1273:  int i, histo[256];
    #####: 1274:  const uchar often[] = { 0x00, 0x55, 0xaa, 0xff };
        -: 1275:
    #####: 1276:  memset (histo, 0, sizeof histo);
    #####: 1277:  fseek (ifp, -2000, SEEK_END);
    #####: 1278:  for (i=0; i < 2000; i++)
    #####: 1279:    histo[fgetc(ifp)]++;
    #####: 1280:  for (i=0; i < 4; i++)
    #####: 1281:    if (histo[often[i]] < 200)
        -: 1282:      return 0;
        -: 1283:  return 1;
        -: 1284:}
        -: 1285:
        -: 1286:/*
        -: 1287:   Returns 1 for a Coolpix 2100, 0 for anything else.
        -: 1288: */
    #####: 1289:int CLASS nikon_e2100()
        -: 1290:{
        -: 1291:  uchar t[12];
        -: 1292:  int i;
        -: 1293:
    #####: 1294:  fseek (ifp, 0, SEEK_SET);
    #####: 1295:  for (i=0; i < 1024; i++) {
    #####: 1296:    fread (t, 1, 12, ifp);
    #####: 1297:    if (((t[2] & t[4] & t[7] & t[9]) >> 4
    #####: 1298:	& t[1] & t[6] & t[8] & t[11] & 3) != 3)
        -: 1299:      return 0;
        -: 1300:  }
        -: 1301:  return 1;
        -: 1302:}
        -: 1303:
    #####: 1304:void CLASS nikon_3700()
        -: 1305:{
        -: 1306:  int bits, i;
        -: 1307:  uchar dp[24];
        -: 1308:  static const struct {
        -: 1309:    int bits;
        -: 1310:    char make[12], model[15];
        -: 1311:  } table[] = {
        -: 1312:    { 0x00, "Pentax",  "Optio 33WR" },
        -: 1313:    { 0x03, "Nikon",   "E3200" },
        -: 1314:    { 0x32, "Nikon",   "E3700" },
        -: 1315:    { 0x33, "Olympus", "C740UZ" } };
        -: 1316:
    #####: 1317:  fseek (ifp, 3072, SEEK_SET);
    #####: 1318:  fread (dp, 1, 24, ifp);
    #####: 1319:  bits = (dp[8] & 3) << 4 | (dp[20] & 3);
    #####: 1320:  for (i=0; i < sizeof table / sizeof *table; i++)
    #####: 1321:    if (bits == table[i].bits) {
    #####: 1322:      strcpy (make,  table[i].make );
    #####: 1323:      strcpy (model, table[i].model);
        -: 1324:    }
    #####: 1325:}
        -: 1326:
        -: 1327:/*
        -: 1328:   Separates a Minolta DiMAGE Z2 from a Nikon E4300.
        -: 1329: */
    #####: 1330:int CLASS minolta_z2()
        -: 1331:{
        -: 1332:  int i, nz;
        -: 1333:  char tail[424];
        -: 1334:
    #####: 1335:  fseek (ifp, -sizeof tail, SEEK_END);
    #####: 1336:  fread (tail, 1, sizeof tail, ifp);
    #####: 1337:  for (nz=i=0; i < sizeof tail; i++)
    #####: 1338:    if (tail[i]) nz++;
    #####: 1339:  return nz > 20;
        -: 1340:}
        -: 1341:
        -: 1342:void CLASS jpeg_thumb();
        -: 1343:
    #####: 1344:void CLASS ppm_thumb()
        -: 1345:{
        -: 1346:  char *thumb;
    #####: 1347:  thumb_length = thumb_width*thumb_height*3;
    #####: 1348:  thumb = (char *) malloc (thumb_length);
    #####: 1349:  merror (thumb, "ppm_thumb()");
    #####: 1350:  fprintf (ofp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
    #####: 1351:  fread  (thumb, 1, thumb_length, ifp);
    #####: 1352:  fwrite (thumb, 1, thumb_length, ofp);
    #####: 1353:  free (thumb);
    #####: 1354:}
        -: 1355:
    #####: 1356:void CLASS ppm16_thumb()
        -: 1357:{
        -: 1358:  int i;
        -: 1359:  char *thumb;
    #####: 1360:  thumb_length = thumb_width*thumb_height*3;
    #####: 1361:  thumb = (char *) calloc (thumb_length, 2);
    #####: 1362:  merror (thumb, "ppm16_thumb()");
    #####: 1363:  read_shorts ((ushort *) thumb, thumb_length);
    #####: 1364:  for (i=0; i < thumb_length; i++)
    #####: 1365:    thumb[i] = ((ushort *) thumb)[i] >> 8;
    #####: 1366:  fprintf (ofp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
    #####: 1367:  fwrite (thumb, 1, thumb_length, ofp);
    #####: 1368:  free (thumb);
    #####: 1369:}
        -: 1370:
    #####: 1371:void CLASS layer_thumb()
        -: 1372:{
        -: 1373:  int i, c;
    #####: 1374:  char *thumb, map[][4] = { "012","102" };
        -: 1375:
    #####: 1376:  colors = thumb_misc >> 5 & 7;
    #####: 1377:  thumb_length = thumb_width*thumb_height;
    #####: 1378:  thumb = (char *) calloc (colors, thumb_length);
    #####: 1379:  merror (thumb, "layer_thumb()");
    #####: 1380:  fprintf (ofp, "P%d\n%d %d\n255\n",
    #####: 1381:	5 + (colors >> 1), thumb_width, thumb_height);
    #####: 1382:  fread (thumb, thumb_length, colors, ifp);
    #####: 1383:  for (i=0; i < thumb_length; i++)
    #####: 1384:    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);
    #####: 1385:  free (thumb);
    #####: 1386:}
        -: 1387:
    #####: 1388:void CLASS rollei_thumb()
        -: 1389:{
        -: 1390:  unsigned i;
        -: 1391:  ushort *thumb;
        -: 1392:
    #####: 1393:  thumb_length = thumb_width * thumb_height;
    #####: 1394:  thumb = (ushort *) calloc (thumb_length, 2);
    #####: 1395:  merror (thumb, "rollei_thumb()");
    #####: 1396:  fprintf (ofp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
    #####: 1397:  read_shorts (thumb, thumb_length);
    #####: 1398:  for (i=0; i < thumb_length; i++) {
    #####: 1399:    putc (thumb[i] << 3, ofp);
    #####: 1400:    putc (thumb[i] >> 5  << 2, ofp);
    #####: 1401:    putc (thumb[i] >> 11 << 3, ofp);
        -: 1402:  }
    #####: 1403:  free (thumb);
    #####: 1404:}
        -: 1405:
    #####: 1406:void CLASS rollei_load_raw()
        -: 1407:{
        -: 1408:  uchar pixel[10];
        -: 1409:  unsigned iten=0, isix, i, buffer=0, todo[16];
        -: 1410:
    #####: 1411:  isix = raw_width * raw_height * 5 / 8;
    #####: 1412:  while (fread (pixel, 1, 10, ifp) == 10) {
    #####: 1413:    for (i=0; i < 10; i+=2) {
    #####: 1414:      todo[i]   = iten++;
    #####: 1415:      todo[i+1] = pixel[i] << 8 | pixel[i+1];
    #####: 1416:      buffer    = pixel[i] >> 2 | buffer << 6;
        -: 1417:    }
    #####: 1418:    for (   ; i < 16; i+=2) {
    #####: 1419:      todo[i]   = isix++;
    #####: 1420:      todo[i+1] = buffer >> (14-i)*5;
        -: 1421:    }
    #####: 1422:    for (i=0; i < 16; i+=2)
    #####: 1423:      raw_image[todo[i]] = (todo[i+1] & 0x3ff);
        -: 1424:  }
    #####: 1425:  maximum = 0x3ff;
    #####: 1426:}
        -: 1427:
    #####: 1428:int CLASS raw (unsigned row, unsigned col)
        -: 1429:{
    #####: 1430:  return (row < raw_height && col < raw_width) ? RAW(row,col) : 0;
        -: 1431:}
        -: 1432:
    #####: 1433:void CLASS phase_one_flat_field (int is_float, int nc)
        -: 1434:{
        -: 1435:  ushort head[8];
        -: 1436:  unsigned wide, high, y, x, c, rend, cend, row, col;
        -: 1437:  float *mrow, num, mult[4];
        -: 1438:
    #####: 1439:  read_shorts (head, 8);
    #####: 1440:  if (head[2] * head[3] * head[4] * head[5] == 0) return;
    #####: 1441:  wide = head[2] / head[4] + (head[2] % head[4] != 0);
    #####: 1442:  high = head[3] / head[5] + (head[3] % head[5] != 0);
    #####: 1443:  mrow = (float *) calloc (nc*wide, sizeof *mrow);
    #####: 1444:  merror (mrow, "phase_one_flat_field()");
    #####: 1445:  for (y=0; y < high; y++) {
    #####: 1446:    for (x=0; x < wide; x++)
    #####: 1447:      for (c=0; c < nc; c+=2) {
    #####: 1448:	num = is_float ? getreal(11) : get2()/32768.0;
    #####: 1449:	if (y==0) mrow[c*wide+x] = num;
    #####: 1450:	else mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) / head[5];
        -: 1451:      }
    #####: 1452:    if (y==0) continue;
    #####: 1453:    rend = head[1] + y*head[5];
    #####: 1454:    for (row = rend-head[5];
    #####: 1455:	 row < raw_height && row < rend &&
    #####: 1456:	 row < head[1]+head[3]-head[5]; row++) {
    #####: 1457:      for (x=1; x < wide; x++) {
    #####: 1458:	for (c=0; c < nc; c+=2) {
    #####: 1459:	  mult[c] = mrow[c*wide+x-1];
    #####: 1460:	  mult[c+1] = (mrow[c*wide+x] - mult[c]) / head[4];
        -: 1461:	}
    #####: 1462:	cend = head[0] + x*head[4];
    #####: 1463:	for (col = cend-head[4];
    #####: 1464:	     col < raw_width &&
    #####: 1465:	     col < cend && col < head[0]+head[2]-head[4]; col++) {
    #####: 1466:	  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;
    #####: 1467:	  if (!(c & 1)) {
    #####: 1468:	    c = RAW(row,col) * mult[c];
    #####: 1469:	    RAW(row,col) = LIM(c,0,65535);
        -: 1470:	  }
    #####: 1471:	  for (c=0; c < nc; c+=2)
    #####: 1472:	    mult[c] += mult[c+1];
        -: 1473:	}
        -: 1474:      }
    #####: 1475:      for (x=0; x < wide; x++)
    #####: 1476:	for (c=0; c < nc; c+=2)
    #####: 1477:	  mrow[c*wide+x] += mrow[(c+1)*wide+x];
        -: 1478:    }
        -: 1479:  }
    #####: 1480:  free (mrow);
        -: 1481:}
        -: 1482:
    #####: 1483:void CLASS phase_one_correct()
        -: 1484:{
        -: 1485:  unsigned entries, tag, data, save, col, row, type;
        -: 1486:  int len, i, j, k, cip, val[4], dev[4], sum, max;
        -: 1487:  int head[9], diff, mindiff=INT_MAX, off_412=0;
        -: 1488:  static const signed char dir[12][2] =
        -: 1489:    { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},
        -: 1490:      {-2,-2}, {-2,2}, {2,-2}, {2,2} };
        -: 1491:  float poly[8], num, cfrac, frac, mult[2], *yval[2];
        -: 1492:  ushort *xval[2];
        -: 1493:  int qmult_applied = 0, qlin_applied = 0;
        -: 1494:
    #####: 1495:  if (half_size || !meta_length) return;
    #####: 1496:  if (verbose) fprintf (stderr,_("Phase One correction...\n"));
    #####: 1497:  fseek (ifp, meta_offset, SEEK_SET);
    #####: 1498:  order = get2();
    #####: 1499:  fseek (ifp, 6, SEEK_CUR);
    #####: 1500:  fseek (ifp, meta_offset+get4(), SEEK_SET);
    #####: 1501:  entries = get4();  get4();
    #####: 1502:  while (entries--) {
    #####: 1503:    tag  = get4();
    #####: 1504:    len  = get4();
    #####: 1505:    data = get4();
    #####: 1506:    save = ftell(ifp);
    #####: 1507:    fseek (ifp, meta_offset+data, SEEK_SET);
    #####: 1508:    if (tag == 0x419) {				/* Polynomial curve */
    #####: 1509:      for (get4(), i=0; i < 8; i++)
    #####: 1510:	poly[i] = getreal(11);
    #####: 1511:      poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;
    #####: 1512:      for (i=0; i < 0x10000; i++) {
    #####: 1513:	num = (poly[5]*i + poly[3])*i + poly[1];
    #####: 1514:	curve[i] = LIM(num,0,65535);
        -: 1515:      } goto apply;				/* apply to right half */
    #####: 1516:    } else if (tag == 0x41a) {			/* Polynomial curve */
    #####: 1517:      for (i=0; i < 4; i++)
    #####: 1518:	poly[i] = getreal(11);
    #####: 1519:      for (i=0; i < 0x10000; i++) {
    #####: 1520:	for (num=0, j=4; j--; )
    #####: 1521:	  num = num * i + poly[j];
    #####: 1522:	curve[i] = LIM(num+i,0,65535);
    #####: 1523:      } apply:					/* apply to whole image */
    #####: 1524:      for (row=0; row < raw_height; row++)
    #####: 1525:	for (col = (tag & 1)*ph1.split_col; col < raw_width; col++)
    #####: 1526:	  RAW(row,col) = curve[RAW(row,col)];
    #####: 1527:    } else if (tag == 0x400) {			/* Sensor defects */
    #####: 1528:      while ((len -= 8) >= 0) {
    #####: 1529:	col  = get2();
    #####: 1530:	row  = get2();
    #####: 1531:	type = get2(); get2();
    #####: 1532:	if (col >= raw_width) continue;
    #####: 1533:	if (type == 131 || type == 137)		/* Bad column */
    #####: 1534:	  for (row=0; row < raw_height; row++)
    #####: 1535:	    if (FC(row-top_margin,col-left_margin) == 1) {
    #####: 1536:	      for (sum=i=0; i < 4; i++)
    #####: 1537:		sum += val[i] = raw (row+dir[i][0], col+dir[i][1]);
    #####: 1538:	      for (max=i=0; i < 4; i++) {
    #####: 1539:		dev[i] = abs((val[i] << 2) - sum);
    #####: 1540:		if (dev[max] < dev[i]) max = i;
        -: 1541:	      }
    #####: 1542:	      RAW(row,col) = (sum - val[max])/3.0 + 0.5;
        -: 1543:	    } else {
    #####: 1544:	      for (sum=0, i=8; i < 12; i++)
    #####: 1545:		sum += raw (row+dir[i][0], col+dir[i][1]);
    #####: 1546:	      RAW(row,col) = 0.5 + sum * 0.0732233 +
    #####: 1547:		(raw(row,col-2) + raw(row,col+2)) * 0.3535534;
        -: 1548:	    }
    #####: 1549:	else if (type == 129) {			/* Bad pixel */
    #####: 1550:	  if (row >= raw_height) continue;
    #####: 1551:	  j = (FC(row-top_margin,col-left_margin) != 1) * 4;
    #####: 1552:	  for (sum=0, i=j; i < j+8; i++)
    #####: 1553:	    sum += raw (row+dir[i][0], col+dir[i][1]);
    #####: 1554:	  RAW(row,col) = (sum + 4) >> 3;
        -: 1555:	}
        -: 1556:      }
    #####: 1557:    } else if (tag == 0x401) {			/* All-color flat fields */
    #####: 1558:      phase_one_flat_field (1, 2);
    #####: 1559:    } else if (tag == 0x416 || tag == 0x410) {
    #####: 1560:      phase_one_flat_field (0, 2);
    #####: 1561:    } else if (tag == 0x40b) {			/* Red+blue flat field */
    #####: 1562:      phase_one_flat_field (0, 4);
    #####: 1563:    } else if (tag == 0x412) {
    #####: 1564:      fseek (ifp, 36, SEEK_CUR);
    #####: 1565:      diff = abs (get2() - ph1.tag_21a);
    #####: 1566:      if (mindiff > diff) {
        -: 1567:	mindiff = diff;
    #####: 1568:	off_412 = ftell(ifp) - 38;
        -: 1569:      }
    #####: 1570:    } else if (tag == 0x41f && !qlin_applied) { /* Quadrant linearization */
        -: 1571:      ushort lc[2][2][16], ref[16];
        -: 1572:      int qr, qc;
    #####: 1573:      for (qr = 0; qr < 2; qr++)
    #####: 1574:	for (qc = 0; qc < 2; qc++)
    #####: 1575:	  for (i = 0; i < 16; i++)
    #####: 1576:	    lc[qr][qc][i] = get4();
    #####: 1577:      for (i = 0; i < 16; i++) {
        -: 1578:	int v = 0;
    #####: 1579:	for (qr = 0; qr < 2; qr++)
    #####: 1580:	  for (qc = 0; qc < 2; qc++)
    #####: 1581:	    v += lc[qr][qc][i];
    #####: 1582:	ref[i] = (v + 2) >> 2;
        -: 1583:      }
    #####: 1584:      for (qr = 0; qr < 2; qr++) {
    #####: 1585:	for (qc = 0; qc < 2; qc++) {
        -: 1586:	  int cx[19], cf[19];
    #####: 1587:	  for (i = 0; i < 16; i++) {
    #####: 1588:	    cx[1+i] = lc[qr][qc][i];
    #####: 1589:	    cf[1+i] = ref[i];
        -: 1590:	  }
    #####: 1591:	  cx[0] = cf[0] = 0;
    #####: 1592:	  cx[17] = cf[17] = ((unsigned) ref[15] * 65535) / lc[qr][qc][15];
    #####: 1593:	  cx[18] = cf[18] = 65535;
    #####: 1594:	  cubic_spline(cx, cf, 19);
    #####: 1595:	  for (row = (qr ? ph1.split_row : 0);
    #####: 1596:	       row < (qr ? raw_height : ph1.split_row); row++)
    #####: 1597:	    for (col = (qc ? ph1.split_col : 0);
    #####: 1598:		 col < (qc ? raw_width : ph1.split_col); col++)
    #####: 1599:	      RAW(row,col) = curve[RAW(row,col)];
        -: 1600:	}
        -: 1601:      }
        -: 1602:      qlin_applied = 1;
    #####: 1603:    } else if (tag == 0x41e && !qmult_applied) { /* Quadrant multipliers */
        -: 1604:      float qmult[2][2] = { { 1, 1 }, { 1, 1 } };
    #####: 1605:      get4(); get4(); get4(); get4();
    #####: 1606:      qmult[0][0] = 1.0 + getreal(11);
    #####: 1607:      get4(); get4(); get4(); get4(); get4();
    #####: 1608:      qmult[0][1] = 1.0 + getreal(11);
    #####: 1609:      get4(); get4(); get4();
    #####: 1610:      qmult[1][0] = 1.0 + getreal(11);
    #####: 1611:      get4(); get4(); get4();
    #####: 1612:      qmult[1][1] = 1.0 + getreal(11);
    #####: 1613:      for (row=0; row < raw_height; row++)
    #####: 1614:	for (col=0; col < raw_width; col++) {
    #####: 1615:	  i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row,col);
    #####: 1616:	  RAW(row,col) = LIM(i,0,65535);
        -: 1617:	}
        -: 1618:      qmult_applied = 1;
    #####: 1619:    } else if (tag == 0x431 && !qmult_applied) { /* Quadrant combined */
        -: 1620:      ushort lc[2][2][7], ref[7];
        -: 1621:      int qr, qc;
    #####: 1622:      for (i = 0; i < 7; i++)
    #####: 1623:	ref[i] = get4();
    #####: 1624:      for (qr = 0; qr < 2; qr++)
    #####: 1625:	for (qc = 0; qc < 2; qc++)
    #####: 1626:	  for (i = 0; i < 7; i++)
    #####: 1627:	    lc[qr][qc][i] = get4();
    #####: 1628:      for (qr = 0; qr < 2; qr++) {
    #####: 1629:	for (qc = 0; qc < 2; qc++) {
        -: 1630:	  int cx[9], cf[9];
    #####: 1631:	  for (i = 0; i < 7; i++) {
    #####: 1632:	    cx[1+i] = ref[i];
    #####: 1633:	    cf[1+i] = ((unsigned) ref[i] * lc[qr][qc][i]) / 10000;
        -: 1634:	  }
    #####: 1635:	  cx[0] = cf[0] = 0;
    #####: 1636:	  cx[8] = cf[8] = 65535;
    #####: 1637:	  cubic_spline(cx, cf, 9);
    #####: 1638:	  for (row = (qr ? ph1.split_row : 0);
    #####: 1639:	       row < (qr ? raw_height : ph1.split_row); row++)
    #####: 1640:	    for (col = (qc ? ph1.split_col : 0);
    #####: 1641:		 col < (qc ? raw_width : ph1.split_col); col++)
    #####: 1642:	      RAW(row,col) = curve[RAW(row,col)];
        -: 1643:        }
        -: 1644:      }
        -: 1645:      qmult_applied = 1;
        -: 1646:      qlin_applied = 1;
        -: 1647:    }
    #####: 1648:    fseek (ifp, save, SEEK_SET);
        -: 1649:  }
    #####: 1650:  if (off_412) {
    #####: 1651:    fseek (ifp, off_412, SEEK_SET);
    #####: 1652:    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;
    #####: 1653:    yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);
    #####: 1654:    merror (yval[0], "phase_one_correct()");
    #####: 1655:    yval[1] = (float  *) (yval[0] + head[1]*head[3]);
    #####: 1656:    xval[0] = (ushort *) (yval[1] + head[2]*head[4]);
    #####: 1657:    xval[1] = (ushort *) (xval[0] + head[1]*head[3]);
    #####: 1658:    get2();
    #####: 1659:    for (i=0; i < 2; i++)
    #####: 1660:      for (j=0; j < head[i+1]*head[i+3]; j++)
    #####: 1661:	yval[i][j] = getreal(11);
    #####: 1662:    for (i=0; i < 2; i++)
    #####: 1663:      for (j=0; j < head[i+1]*head[i+3]; j++)
    #####: 1664:	xval[i][j] = get2();
    #####: 1665:    for (row=0; row < raw_height; row++)
    #####: 1666:      for (col=0; col < raw_width; col++) {
    #####: 1667:	cfrac = (float) col * head[3] / raw_width;
    #####: 1668:	cfrac -= cip = cfrac;
    #####: 1669:	num = RAW(row,col) * 0.5;
    #####: 1670:	for (i=cip; i < cip+2; i++) {
    #####: 1671:	  for (k=j=0; j < head[1]; j++)
    #####: 1672:	    if (num < xval[0][k = head[1]*i+j]) break;
    #####: 1673:	  frac = (j == 0 || j == head[1]) ? 0 :
    #####: 1674:		(xval[0][k] - num) / (xval[0][k] - xval[0][k-1]);
    #####: 1675:	  mult[i-cip] = yval[0][k-1] * frac + yval[0][k] * (1-frac);
        -: 1676:	}
    #####: 1677:	i = ((mult[0] * (1-cfrac) + mult[1] * cfrac) * row + num) * 2;
    #####: 1678:	RAW(row,col) = LIM(i,0,65535);
        -: 1679:      }
    #####: 1680:    free (yval[0]);
        -: 1681:  }
        -: 1682:}
        -: 1683:
    #####: 1684:void CLASS phase_one_load_raw()
        -: 1685:{
        -: 1686:  int a, b, i;
        -: 1687:  ushort akey, bkey, mask;
        -: 1688:
    #####: 1689:  fseek (ifp, ph1.key_off, SEEK_SET);
    #####: 1690:  akey = get2();
    #####: 1691:  bkey = get2();
    #####: 1692:  mask = ph1.format == 1 ? 0x5555:0x1354;
    #####: 1693:  fseek (ifp, data_offset, SEEK_SET);
    #####: 1694:  read_shorts (raw_image, raw_width*raw_height);
    #####: 1695:  if (ph1.format)
    #####: 1696:    for (i=0; i < raw_width*raw_height; i+=2) {
    #####: 1697:      a = raw_image[i+0] ^ akey;
    #####: 1698:      b = raw_image[i+1] ^ bkey;
    #####: 1699:      raw_image[i+0] = (a & mask) | (b & ~mask);
    #####: 1700:      raw_image[i+1] = (b & mask) | (a & ~mask);
        -: 1701:    }
    #####: 1702:}
        -: 1703:
    #####: 1704:unsigned CLASS ph1_bithuff (int nbits, ushort *huff)
        -: 1705:{
        -: 1706:  static UINT64 bitbuf=0;
        -: 1707:  static int vbits=0;
        -: 1708:  unsigned c;
        -: 1709:
    #####: 1710:  if (nbits == -1)
    #####: 1711:    return bitbuf = vbits = 0;
    #####: 1712:  if (nbits == 0) return 0;
    #####: 1713:  if (vbits < nbits) {
    #####: 1714:    bitbuf = bitbuf << 32 | get4();
    #####: 1715:    vbits += 32;
        -: 1716:  }
    #####: 1717:  c = bitbuf << (64-vbits) >> (64-nbits);
    #####: 1718:  if (huff) {
    #####: 1719:    vbits -= huff[c] >> 8;
    #####: 1720:    return (uchar) huff[c];
        -: 1721:  }
    #####: 1722:  vbits -= nbits;
    #####: 1723:  return c;
        -: 1724:}
        -: 1725:#define ph1_bits(n) ph1_bithuff(n,0)
        -: 1726:#define ph1_huff(h) ph1_bithuff(*h,h+1)
        -: 1727:
    #####: 1728:void CLASS phase_one_load_raw_c()
        -: 1729:{
        -: 1730:  static const int length[] = { 8,7,6,9,11,10,5,12,14,13 };
        -: 1731:  int *offset, len[2], pred[2], row, col, i, j;
        -: 1732:  ushort *pixel;
        -: 1733:  short (*cblack)[2], (*rblack)[2];
        -: 1734:
    #####: 1735:  pixel = (ushort *) calloc (raw_width*3 + raw_height*4, 2);
    #####: 1736:  merror (pixel, "phase_one_load_raw_c()");
    #####: 1737:  offset = (int *) (pixel + raw_width);
    #####: 1738:  fseek (ifp, strip_offset, SEEK_SET);
    #####: 1739:  for (row=0; row < raw_height; row++)
    #####: 1740:    offset[row] = get4();
    #####: 1741:  cblack = (short (*)[2]) (offset + raw_height);
    #####: 1742:  fseek (ifp, ph1.black_col, SEEK_SET);
    #####: 1743:  if (ph1.black_col)
    #####: 1744:    read_shorts ((ushort *) cblack[0], raw_height*2);
    #####: 1745:  rblack = cblack + raw_height;
    #####: 1746:  fseek (ifp, ph1.black_row, SEEK_SET);
    #####: 1747:  if (ph1.black_row)
    #####: 1748:    read_shorts ((ushort *) rblack[0], raw_width*2);
    #####: 1749:  for (i=0; i < 256; i++)
    #####: 1750:    curve[i] = i*i / 3.969 + 0.5;
    #####: 1751:  for (row=0; row < raw_height; row++) {
    #####: 1752:    fseek (ifp, data_offset + offset[row], SEEK_SET);
        -: 1753:    ph1_bits(-1);
    #####: 1754:    pred[0] = pred[1] = 0;
    #####: 1755:    for (col=0; col < raw_width; col++) {
    #####: 1756:      if (col >= (raw_width & -8))
    #####: 1757:	len[0] = len[1] = 14;
    #####: 1758:      else if ((col & 7) == 0)
    #####: 1759:	for (i=0; i < 2; i++) {
    #####: 1760:	  for (j=0; j < 5 && !ph1_bits(1); j++);
    #####: 1761:	  if (j--) len[i] = length[j*2 + ph1_bits(1)];
        -: 1762:	}
    #####: 1763:      if ((i = len[col & 1]) == 14)
    #####: 1764:	pixel[col] = pred[col & 1] = ph1_bits(16);
        -: 1765:      else
    #####: 1766:	pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));
    #####: 1767:      if (pred[col & 1] >> 16) derror();
    #####: 1768:      if (ph1.format == 5 && pixel[col] < 256)
    #####: 1769:	pixel[col] = curve[pixel[col]];
        -: 1770:    }
    #####: 1771:    for (col=0; col < raw_width; col++) {
    #####: 1772:      i = (pixel[col] << 2*(ph1.format != 8)) - ph1.black
    #####: 1773:	+ cblack[row][col >= ph1.split_col]
    #####: 1774:	+ rblack[col][row >= ph1.split_row];
    #####: 1775:      if (i > 0) RAW(row,col) = i;
        -: 1776:    }
        -: 1777:  }
    #####: 1778:  free (pixel);
    #####: 1779:  maximum = 0xfffc - ph1.black;
    #####: 1780:}
        -: 1781:
    #####: 1782:void CLASS hasselblad_load_raw()
        -: 1783:{
        -: 1784:  struct jhead jh;
        -: 1785:  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;
        -: 1786:  unsigned upix, urow, ucol;
        -: 1787:  ushort *ip;
        -: 1788:
    #####: 1789:  if (!ljpeg_start (&jh, 0)) return;
    #####: 1790:  order = 0x4949;
        -: 1791:  ph1_bits(-1);
    #####: 1792:  back[4] = (int *) calloc (raw_width, 3*sizeof **back);
    #####: 1793:  merror (back[4], "hasselblad_load_raw()");
    #####: 1794:  FORC3 back[c] = back[4] + c*raw_width;
    #####: 1795:  cblack[6] >>= sh = tiff_samples > 1;
    #####: 1796:  shot = LIM(shot_select, 1, tiff_samples) - 1;
    #####: 1797:  for (row=0; row < raw_height; row++) {
    #####: 1798:    FORC4 back[(c+3) & 3] = back[c];
    #####: 1799:    for (col=0; col < raw_width; col+=2) {
    #####: 1800:      for (s=0; s < tiff_samples*2; s+=2) {
    #####: 1801:	FORC(2) len[c] = ph1_huff(jh.huff[0]);
    #####: 1802:	FORC(2) {
    #####: 1803:	  diff[s+c] = ph1_bits(len[c]);
    #####: 1804:	  if ((diff[s+c] & (1 << (len[c]-1))) == 0)
    #####: 1805:	    diff[s+c] -= (1 << len[c]) - 1;
    #####: 1806:	  if (diff[s+c] == 65535) diff[s+c] = -32768;
        -: 1807:	}
        -: 1808:      }
    #####: 1809:      for (s=col; s < col+2; s++) {
    #####: 1810:	pred = 0x8000 + load_flags;
    #####: 1811:	if (col) pred = back[2][s-2];
    #####: 1812:	if (col && row > 1) switch (jh.psv) {
    #####: 1813:	  case 11: pred += back[0][s]/2 - back[0][s-2]/2;  break;
        -: 1814:	}
    #####: 1815:	f = (row & 1)*3 ^ ((col+s) & 1);
    #####: 1816:	FORC (tiff_samples) {
    #####: 1817:	  pred += diff[(s & 1)*tiff_samples+c];
    #####: 1818:	  upix = pred >> sh & 0xffff;
    #####: 1819:	  if (raw_image && c == shot)
    #####: 1820:	    RAW(row,s) = upix;
    #####: 1821:	  if (image) {
    #####: 1822:	    urow = row-top_margin  + (c & 1);
    #####: 1823:	    ucol = col-left_margin - ((c >> 1) & 1);
    #####: 1824:	    ip = &image[urow*width+ucol][f];
    #####: 1825:	    if (urow < height && ucol < width)
    #####: 1826:	      *ip = c < 4 ? upix : (*ip + upix) >> 1;
        -: 1827:	  }
        -: 1828:	}
    #####: 1829:	back[2][s] = pred;
        -: 1830:      }
        -: 1831:    }
        -: 1832:  }
    #####: 1833:  free (back[4]);
    #####: 1834:  ljpeg_end (&jh);
    #####: 1835:  if (image) mix_green = 1;
        -: 1836:}
        -: 1837:
    #####: 1838:void CLASS leaf_hdr_load_raw()
        -: 1839:{
        -: 1840:  ushort *pixel=0;
        -: 1841:  unsigned tile=0, r, c, row, col;
        -: 1842:
    #####: 1843:  if (!filters) {
    #####: 1844:    pixel = (ushort *) calloc (raw_width, sizeof *pixel);
    #####: 1845:    merror (pixel, "leaf_hdr_load_raw()");
        -: 1846:  }
    #####: 1847:  FORC(tiff_samples)
    #####: 1848:    for (r=0; r < raw_height; r++) {
    #####: 1849:      if (r % tile_length == 0) {
    #####: 1850:	fseek (ifp, data_offset + 4*tile++, SEEK_SET);
    #####: 1851:	fseek (ifp, get4(), SEEK_SET);
        -: 1852:      }
    #####: 1853:      if (filters && c != shot_select) continue;
    #####: 1854:      if (filters) pixel = raw_image + r*raw_width;
    #####: 1855:      read_shorts (pixel, raw_width);
    #####: 1856:      if (!filters && (row = r - top_margin) < height)
    #####: 1857:	for (col=0; col < width; col++)
    #####: 1858:	  image[row*width+col][c] = pixel[col+left_margin];
        -: 1859:    }
    #####: 1860:  if (!filters) {
    #####: 1861:    maximum = 0xffff;
    #####: 1862:    raw_color = 1;
    #####: 1863:    free (pixel);
        -: 1864:  }
    #####: 1865:}
        -: 1866:
    #####: 1867:void CLASS unpacked_load_raw()
        -: 1868:{
        -: 1869:  int row, col, bits=0;
        -: 1870:
    #####: 1871:  while (1 << ++bits < maximum);
    #####: 1872:  read_shorts (raw_image, raw_width*raw_height);
    #####: 1873:  for (row=0; row < raw_height; row++)
    #####: 1874:    for (col=0; col < raw_width; col++)
    #####: 1875:      if ((RAW(row,col) >>= load_flags) >> bits
    #####: 1876:	&& (unsigned) (row-top_margin) < height
    #####: 1877:	&& (unsigned) (col-left_margin) < width) derror();
    #####: 1878:}
        -: 1879:
    #####: 1880:void CLASS sinar_4shot_load_raw()
        -: 1881:{
        -: 1882:  ushort *pixel;
        -: 1883:  unsigned shot, row, col, r, c;
        -: 1884:
    #####: 1885:  if (raw_image) {
    #####: 1886:    shot = LIM (shot_select, 1, 4) - 1;
    #####: 1887:    fseek (ifp, data_offset + shot*4, SEEK_SET);
    #####: 1888:    fseek (ifp, get4(), SEEK_SET);
    #####: 1889:    unpacked_load_raw();
    #####: 1890:    return;
        -: 1891:  }
    #####: 1892:  pixel = (ushort *) calloc (raw_width, sizeof *pixel);
    #####: 1893:  merror (pixel, "sinar_4shot_load_raw()");
    #####: 1894:  for (shot=0; shot < 4; shot++) {
    #####: 1895:    fseek (ifp, data_offset + shot*4, SEEK_SET);
    #####: 1896:    fseek (ifp, get4(), SEEK_SET);
    #####: 1897:    for (row=0; row < raw_height; row++) {
    #####: 1898:      read_shorts (pixel, raw_width);
    #####: 1899:      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;
    #####: 1900:      for (col=0; col < raw_width; col++) {
    #####: 1901:	if ((c = col-left_margin - (shot & 1)) >= width) continue;
    #####: 1902:	image[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];
        -: 1903:      }
        -: 1904:    }
        -: 1905:  }
    #####: 1906:  free (pixel);
    #####: 1907:  mix_green = 1;
        -: 1908:}
        -: 1909:
    #####: 1910:void CLASS imacon_full_load_raw()
        -: 1911:{
        -: 1912:  int row, col;
        -: 1913:
    #####: 1914:  if (!image) return;
    #####: 1915:  for (row=0; row < height; row++)
    #####: 1916:    for (col=0; col < width; col++)
    #####: 1917:      read_shorts (image[row*width+col], 3);
        -: 1918:}
        -: 1919:
    #####: 1920:void CLASS packed_load_raw()
        -: 1921:{
        -: 1922:  int vbits=0, bwide, rbits, bite, half, irow, row, col, val, i;
        -: 1923:  UINT64 bitbuf=0;
        -: 1924:
    #####: 1925:  bwide = raw_width * tiff_bps / 8;
    #####: 1926:  bwide += bwide & load_flags >> 7;
    #####: 1927:  rbits = bwide * 8 - raw_width * tiff_bps;
    #####: 1928:  if (load_flags & 1) bwide = bwide * 16 / 15;
    #####: 1929:  bite = 8 + (load_flags & 24);
    #####: 1930:  half = (raw_height+1) >> 1;
    #####: 1931:  for (irow=0; irow < raw_height; irow++) {
        -: 1932:    row = irow;
    #####: 1933:    if (load_flags & 2 &&
    #####: 1934:	(row = irow % half * 2 + irow / half) == 1 &&
    #####: 1935:	load_flags & 4) {
    #####: 1936:      if (vbits=0, tiff_compress)
    #####: 1937:	fseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);
        -: 1938:      else {
    #####: 1939:	fseek (ifp, 0, SEEK_END);
    #####: 1940:	fseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);
        -: 1941:      }
        -: 1942:    }
    #####: 1943:    for (col=0; col < raw_width; col++) {
    #####: 1944:      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {
    #####: 1945:	bitbuf <<= bite;
    #####: 1946:	for (i=0; i < bite; i+=8)
    #####: 1947:	  bitbuf |= (unsigned) (fgetc(ifp) << i);
        -: 1948:      }
    #####: 1949:      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);
    #####: 1950:      RAW(row,col ^ (load_flags >> 6 & 1)) = val;
    #####: 1951:      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) &&
    #####: 1952:	row < height+top_margin && col < width+left_margin) derror();
        -: 1953:    }
    #####: 1954:    vbits -= rbits;
        -: 1955:  }
    #####: 1956:}
        -: 1957:
    #####: 1958:void CLASS nokia_load_raw()
        -: 1959:{
        -: 1960:  uchar  *data,  *dp;
        -: 1961:  int rev, dwide, row, col, c;
    #####: 1962:  double sum[]={0,0};
        -: 1963:
    #####: 1964:  rev = 3 * (order == 0x4949);
    #####: 1965:  dwide = (raw_width * 5 + 1) / 4;
    #####: 1966:  data = (uchar *) malloc (dwide*2);
    #####: 1967:  merror (data, "nokia_load_raw()");
    #####: 1968:  for (row=0; row < raw_height; row++) {
    #####: 1969:    if (fread (data+dwide, 1, dwide, ifp) < dwide) derror();
    #####: 1970:    FORC(dwide) data[c] = data[dwide+(c ^ rev)];
    #####: 1971:    for (dp=data, col=0; col < raw_width; dp+=5, col+=4)
    #####: 1972:      FORC4 RAW(row,col+c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);
        -: 1973:  }
    #####: 1974:  free (data);
    #####: 1975:  maximum = 0x3ff;
    #####: 1976:  if (strcmp(make,"OmniVision")) return;
    #####: 1977:  row = raw_height/2;
    #####: 1978:  FORC(width-1) {
    #####: 1979:    sum[ c & 1] += SQR(RAW(row,c)-RAW(row+1,c+1));
    #####: 1980:    sum[~c & 1] += SQR(RAW(row+1,c)-RAW(row,c+1));
        -: 1981:  }
    #####: 1982:  if (sum[1] > sum[0]) filters = 0x4b4b4b4b;
        -: 1983:}
        -: 1984:
    #####: 1985:void CLASS canon_rmf_load_raw()
        -: 1986:{
        -: 1987:  int row, col, bits, orow, ocol, c;
        -: 1988:
    #####: 1989:  for (row=0; row < raw_height; row++)
    #####: 1990:    for (col=0; col < raw_width-2; col+=3) {
    #####: 1991:      bits = get4();
    #####: 1992:      FORC3 {
        -: 1993:	orow = row;
    #####: 1994:	if ((ocol = col+c-4) < 0) {
    #####: 1995:	  ocol += raw_width;
    #####: 1996:	  if ((orow -= 2) < 0)
    #####: 1997:	    orow += raw_height;
        -: 1998:	}
    #####: 1999:	RAW(orow,ocol) = curve[bits >> (10*c+2) & 0x3ff];
        -: 2000:      }
        -: 2001:    }
    #####: 2002:  maximum = curve[0x3ff];
    #####: 2003:}
        -: 2004:
    #####: 2005:unsigned CLASS pana_bits (int nbits)
        -: 2006:{
        -: 2007:  static uchar buf[0x4000];
        -: 2008:  static int vbits;
        -: 2009:  int byte;
        -: 2010:
    #####: 2011:  if (!nbits) return vbits=0;
    #####: 2012:  if (!vbits) {
    #####: 2013:    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);
    #####: 2014:    fread (buf, 1, load_flags, ifp);
        -: 2015:  }
    #####: 2016:  vbits = (vbits - nbits) & 0x1ffff;
    #####: 2017:  byte = vbits >> 3 ^ 0x3ff0;
    #####: 2018:  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);
        -: 2019:}
        -: 2020:
    #####: 2021:void CLASS panasonic_load_raw()
        -: 2022:{
        -: 2023:  int row, col, i, j, sh=0, pred[2], nonz[2];
        -: 2024:
        -: 2025:  pana_bits(0);
    #####: 2026:  for (row=0; row < height; row++)
    #####: 2027:    for (col=0; col < raw_width; col++) {
    #####: 2028:      if ((i = col % 14) == 0)
    #####: 2029:	pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
    #####: 2030:      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));
    #####: 2031:      if (nonz[i & 1]) {
    #####: 2032:	if ((j = pana_bits(8))) {
    #####: 2033:	  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)
    #####: 2034:	       pred[i & 1] &= ~(-1 << sh);
    #####: 2035:	  pred[i & 1] += j << sh;
        -: 2036:	}
    #####: 2037:      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
    #####: 2038:	pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
    #####: 2039:      if ((RAW(row,col) = pred[col & 1]) > 4098 && col < width) derror();
        -: 2040:    }
    #####: 2041:}
        -: 2042:
    #####: 2043:void CLASS olympus_load_raw()
        -: 2044:{
        -: 2045:  ushort huff[4096];
        -: 2046:  int row, col, nbits, sign, low, high, i, c, w, n, nw;
        -: 2047:  int acarry[2][3], *carry, pred, diff;
        -: 2048:
    #####: 2049:  huff[n=0] = 0xc0c;
    #####: 2050:  for (i=12; i--; )
    #####: 2051:    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;
    #####: 2052:  fseek (ifp, 7, SEEK_CUR);
        -: 2053:  getbits(-1);
    #####: 2054:  for (row=0; row < height; row++) {
    #####: 2055:    memset (acarry, 0, sizeof acarry);
    #####: 2056:    for (col=0; col < raw_width; col++) {
    #####: 2057:      carry = acarry[col & 1];
    #####: 2058:      i = 2 * (carry[2] < 3);
    #####: 2059:      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);
    #####: 2060:      low = (sign = getbits(3)) & 3;
    #####: 2061:      sign = sign << 29 >> 31;
    #####: 2062:      if ((high = getbithuff(12,huff)) == 12)
    #####: 2063:	high = getbits(16-nbits) >> 1;
    #####: 2064:      carry[0] = (high << nbits) | getbits(nbits);
    #####: 2065:      diff = (carry[0] ^ sign) + carry[1];
    #####: 2066:      carry[1] = (diff*3 + carry[1]) >> 5;
    #####: 2067:      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;
    #####: 2068:      if (col >= width) continue;
    #####: 2069:      if (row < 2 && col < 2) pred = 0;
    #####: 2070:      else if (row < 2) pred = RAW(row,col-2);
    #####: 2071:      else if (col < 2) pred = RAW(row-2,col);
        -: 2072:      else {
    #####: 2073:	w  = RAW(row,col-2);
    #####: 2074:	n  = RAW(row-2,col);
    #####: 2075:	nw = RAW(row-2,col-2);
    #####: 2076:	if ((w < nw && nw < n) || (n < nw && nw < w)) {
    #####: 2077:	  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)
    #####: 2078:	    pred = w + n - nw;
    #####: 2079:	  else pred = (w + n) >> 1;
    #####: 2080:	} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;
        -: 2081:      }
    #####: 2082:      if ((RAW(row,col) = pred + ((diff << 2) | low)) >> 12) derror();
        -: 2083:    }
        -: 2084:  }
    #####: 2085:}
        -: 2086:
    #####: 2087:void CLASS minolta_rd175_load_raw()
        -: 2088:{
        -: 2089:  uchar pixel[768];
        -: 2090:  unsigned irow, box, row, col;
        -: 2091:
    #####: 2092:  for (irow=0; irow < 1481; irow++) {
    #####: 2093:    if (fread (pixel, 1, 768, ifp) < 768) derror();
    #####: 2094:    box = irow / 82;
    #####: 2095:    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    #####: 2096:    switch (irow) {
    #####: 2097:      case 1477: case 1479: continue;
    #####: 2098:      case 1476: row = 984; break;
    #####: 2099:      case 1480: row = 985; break;
        -: 2100:      case 1478: row = 985; box = 1;
        -: 2101:    }
    #####: 2102:    if ((box < 12) && (box & 1)) {
    #####: 2103:      for (col=0; col < 1533; col++, row ^= 1)
    #####: 2104:	if (col != 1) RAW(row,col) = (col+1) & 2 ?
    #####: 2105:		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
    #####: 2106:      RAW(row,1)    = pixel[1]   << 1;
    #####: 2107:      RAW(row,1533) = pixel[765] << 1;
        -: 2108:    } else
    #####: 2109:      for (col=row & 1; col < 1534; col+=2)
    #####: 2110:	RAW(row,col) = pixel[col/2] << 1;
        -: 2111:  }
    #####: 2112:  maximum = 0xff << 1;
    #####: 2113:}
        -: 2114:
    #####: 2115:void CLASS quicktake_100_load_raw()
        -: 2116:{
        -: 2117:  uchar pixel[484][644];
        -: 2118:  static const short gstep[16] =
        -: 2119:  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };
        -: 2120:  static const short rstep[6][4] =
        -: 2121:  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },
        -: 2122:    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };
        -: 2123:  static const short curve[256] =
        -: 2124:  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
        -: 2125:    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,
        -: 2126:    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,
        -: 2127:    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,
        -: 2128:    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,
        -: 2129:    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,
        -: 2130:    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,
        -: 2131:    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,
        -: 2132:    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,
        -: 2133:    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,
        -: 2134:    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,
        -: 2135:    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,
        -: 2136:    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };
        -: 2137:  int rb, row, col, sharp, val=0;
        -: 2138:
        -: 2139:  getbits(-1);
    #####: 2140:  memset (pixel, 0x80, sizeof pixel);
    #####: 2141:  for (row=2; row < height+2; row++) {
    #####: 2142:    for (col=2+(row & 1); col < width+2; col+=2) {
    #####: 2143:      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +
    #####: 2144:		pixel[row][col-2]) >> 2) + gstep[getbits(4)];
    #####: 2145:      pixel[row][col] = val = LIM(val,0,255);
    #####: 2146:      if (col < 4)
    #####: 2147:	pixel[row][col-2] = pixel[row+1][~row & 1] = val;
    #####: 2148:      if (row == 2)
    #####: 2149:	pixel[row-1][col+1] = pixel[row-1][col+3] = val;
        -: 2150:    }
    #####: 2151:    pixel[row][col] = val;
        -: 2152:  }
    #####: 2153:  for (rb=0; rb < 2; rb++)
    #####: 2154:    for (row=2+rb; row < height+2; row+=2)
    #####: 2155:      for (col=3-(row & 1); col < width+2; col+=2) {
    #####: 2156:	if (row < 4 || col < 4) sharp = 2;
        -: 2157:	else {
    #####: 2158:	  val = ABS(pixel[row-2][col] - pixel[row][col-2])
    #####: 2159:	      + ABS(pixel[row-2][col] - pixel[row-2][col-2])
    #####: 2160:	      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);
    #####: 2161:	  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :
    #####: 2162:		  val < 32 ? 3 : val < 48 ? 4 : 5;
        -: 2163:	}
    #####: 2164:	val = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)
    #####: 2165:	      + rstep[sharp][getbits(2)];
    #####: 2166:	pixel[row][col] = val = LIM(val,0,255);
    #####: 2167:	if (row < 4) pixel[row-2][col+2] = val;
    #####: 2168:	if (col < 4) pixel[row+2][col-2] = val;
        -: 2169:      }
    #####: 2170:  for (row=2; row < height+2; row++)
    #####: 2171:    for (col=3-(row & 1); col < width+2; col+=2) {
    #####: 2172:      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +
    #####: 2173:	      pixel[row][col+1]) >> 1) - 0x100;
    #####: 2174:      pixel[row][col] = LIM(val,0,255);
        -: 2175:    }
    #####: 2176:  for (row=0; row < height; row++)
    #####: 2177:    for (col=0; col < width; col++)
    #####: 2178:      RAW(row,col) = curve[pixel[row+2][col+2]];
    #####: 2179:  maximum = 0x3ff;
    #####: 2180:}
        -: 2181:
        -: 2182:#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))
        -: 2183:
        -: 2184:#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)
        -: 2185:
        -: 2186:#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \
        -: 2187:: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)
        -: 2188:
    #####: 2189:void CLASS kodak_radc_load_raw()
        -: 2190:{
        -: 2191:  static const char src[] = {
        -: 2192:    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,
        -: 2193:    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,
        -: 2194:    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,
        -: 2195:    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,
        -: 2196:    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,
        -: 2197:    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,
        -: 2198:    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,
        -: 2199:    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,
        -: 2200:    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,
        -: 2201:    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,
        -: 2202:    1,0, 2,2, 2,-2,
        -: 2203:    1,-3, 1,3,
        -: 2204:    2,-17, 2,-5, 2,5, 2,17,
        -: 2205:    2,-7, 2,2, 2,9, 2,18,
        -: 2206:    2,-18, 2,-9, 2,-2, 2,7,
        -: 2207:    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,
        -: 2208:    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,
        -: 2209:    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37
        -: 2210:  };
        -: 2211:  ushort huff[19][256];
        -: 2212:  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;
    #####: 2213:  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];
        -: 2214:  static const ushort pt[] =
        -: 2215:    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };
        -: 2216:
    #####: 2217:  for (i=2; i < 12; i+=2)
    #####: 2218:    for (c=pt[i-2]; c <= pt[i]; c++)
    #####: 2219:      curve[c] = (float)
    #####: 2220:	(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;
    #####: 2221:  for (s=i=0; i < sizeof src; i+=2)
    #####: 2222:    FORC(256 >> src[i])
    #####: 2223:      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];
    #####: 2224:  s = kodak_cbpp == 243 ? 2 : 3;
    #####: 2225:  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);
        -: 2226:  getbits(-1);
    #####: 2227:  for (i=0; i < sizeof(buf)/sizeof(short); i++)
    #####: 2228:    ((short *)buf)[i] = 2048;
    #####: 2229:  for (row=0; row < height; row+=4) {
    #####: 2230:    FORC3 mul[c] = getbits(6);
    #####: 2231:    FORC3 {
    #####: 2232:      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];
    #####: 2233:      s = val > 65564 ? 10:12;
    #####: 2234:      x = ~(-1 << (s-1));
    #####: 2235:      val <<= 12-s;
    #####: 2236:      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)
    #####: 2237:	((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;
    #####: 2238:      last[c] = mul[c];
    #####: 2239:      for (r=0; r <= !c; r++) {
    #####: 2240:	buf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;
    #####: 2241:	for (tree=1, col=width/2; col > 0; ) {
    #####: 2242:	  if ((tree = radc_token(tree))) {
    #####: 2243:	    col -= 2;
    #####: 2244:	    if (tree == 8)
    #####: 2245:	      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];
        -: 2246:	    else
    #####: 2247:	      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;
        -: 2248:	  } else
        -: 2249:	    do {
    #####: 2250:	      nreps = (col > 2) ? radc_token(9) + 1 : 1;
    #####: 2251:	      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {
    #####: 2252:		col -= 2;
    #####: 2253:		FORYX buf[c][y][x] = PREDICTOR;
    #####: 2254:		if (rep & 1) {
    #####: 2255:		  step = radc_token(10) << 4;
    #####: 2256:		  FORYX buf[c][y][x] += step;
        -: 2257:		}
        -: 2258:	      }
    #####: 2259:	    } while (nreps == 9);
        -: 2260:	}
    #####: 2261:	for (y=0; y < 2; y++)
    #####: 2262:	  for (x=0; x < width/2; x++) {
    #####: 2263:	    val = (buf[c][y+1][x] << 4) / mul[c];
    #####: 2264:	    if (val < 0) val = 0;
    #####: 2265:	    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;
    #####: 2266:	    else   RAW(row+r*2+y,x*2+y) = val;
        -: 2267:	  }
    #####: 2268:	memcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);
        -: 2269:      }
        -: 2270:    }
    #####: 2271:    for (y=row; y < row+4; y++)
    #####: 2272:      for (x=0; x < width; x++)
    #####: 2273:	if ((x+y) & 1) {
    #####: 2274:	  r = x ? x-1 : x+1;
    #####: 2275:	  s = x+1 < width ? x+1 : x-1;
    #####: 2276:	  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;
    #####: 2277:	  if (val < 0) val = 0;
    #####: 2278:	  RAW(y,x) = val;
        -: 2279:	}
        -: 2280:  }
    #####: 2281:  for (i=0; i < height*width; i++)
    #####: 2282:    raw_image[i] = curve[raw_image[i]];
    #####: 2283:  maximum = 0x3fff;
    #####: 2284:}
        -: 2285:
        -: 2286:#undef FORYX
        -: 2287:#undef PREDICTOR
        -: 2288:
        -: 2289:#ifdef NO_JPEG
        -: 2290:void CLASS kodak_jpeg_load_raw() {}
        -: 2291:void CLASS lossy_dng_load_raw() {}
        -: 2292:#else
        -: 2293:
        -: 2294:METHODDEF(boolean)
    #####: 2295:fill_input_buffer (j_decompress_ptr cinfo)
        -: 2296:{
        -: 2297:  static uchar jpeg_buffer[4096];
        -: 2298:  size_t nbytes;
        -: 2299:
    #####: 2300:  nbytes = fread (jpeg_buffer, 1, 4096, ifp);
    #####: 2301:  swab (jpeg_buffer, jpeg_buffer, nbytes);
    #####: 2302:  cinfo->src->next_input_byte = jpeg_buffer;
    #####: 2303:  cinfo->src->bytes_in_buffer = nbytes;
    #####: 2304:  return TRUE;
        -: 2305:}
        -: 2306:
    #####: 2307:void CLASS kodak_jpeg_load_raw()
        -: 2308:{
        -: 2309:  struct jpeg_decompress_struct cinfo;
        -: 2310:  struct jpeg_error_mgr jerr;
        -: 2311:  JSAMPARRAY buf;
        -: 2312:  JSAMPLE (*pixel)[3];
        -: 2313:  int row, col;
        -: 2314:
    #####: 2315:  cinfo.err = jpeg_std_error (&jerr);
    #####: 2316:  jpeg_create_decompress (&cinfo);
    #####: 2317:  jpeg_stdio_src (&cinfo, ifp);
    #####: 2318:  cinfo.src->fill_input_buffer = fill_input_buffer;
    #####: 2319:  jpeg_read_header (&cinfo, TRUE);
    #####: 2320:  jpeg_start_decompress (&cinfo);
    #####: 2321:  if ((cinfo.output_width      != width  ) ||
    #####: 2322:      (cinfo.output_height*2   != height ) ||
    #####: 2323:      (cinfo.output_components != 3      )) {
    #####: 2324:    fprintf (stderr,_("%s: incorrect JPEG dimensions\n"), ifname);
    #####: 2325:    jpeg_destroy_decompress (&cinfo);
    #####: 2326:    longjmp (failure, 3);
        -: 2327:  }
    #####: 2328:  buf = (*cinfo.mem->alloc_sarray)
    #####: 2329:		((j_common_ptr) &cinfo, JPOOL_IMAGE, width*3, 1);
        -: 2330:
    #####: 2331:  while (cinfo.output_scanline < cinfo.output_height) {
    #####: 2332:    row = cinfo.output_scanline * 2;
    #####: 2333:    jpeg_read_scanlines (&cinfo, buf, 1);
    #####: 2334:    pixel = (JSAMPLE (*)[3]) buf[0];
    #####: 2335:    for (col=0; col < width; col+=2) {
    #####: 2336:      RAW(row+0,col+0) = pixel[col+0][1] << 1;
    #####: 2337:      RAW(row+1,col+1) = pixel[col+1][1] << 1;
    #####: 2338:      RAW(row+0,col+1) = pixel[col][0] + pixel[col+1][0];
    #####: 2339:      RAW(row+1,col+0) = pixel[col][2] + pixel[col+1][2];
        -: 2340:    }
        -: 2341:  }
    #####: 2342:  jpeg_finish_decompress (&cinfo);
    #####: 2343:  jpeg_destroy_decompress (&cinfo);
    #####: 2344:  maximum = 0xff << 1;
    #####: 2345:}
        -: 2346:
        -: 2347:void CLASS gamma_curve (double pwr, double ts, int mode, int imax);
        -: 2348:
    #####: 2349:void CLASS lossy_dng_load_raw()
        -: 2350:{
        -: 2351:  struct jpeg_decompress_struct cinfo;
        -: 2352:  struct jpeg_error_mgr jerr;
        -: 2353:  JSAMPARRAY buf;
        -: 2354:  JSAMPLE (*pixel)[3];
    #####: 2355:  unsigned sorder=order, ntags, opcode, deg, i, j, c;
    #####: 2356:  unsigned save=data_offset-4, trow=0, tcol=0, row, col;
        -: 2357:  ushort cur[3][256];
        -: 2358:  double coeff[9], tot;
        -: 2359:
    #####: 2360:  if (meta_offset) {
    #####: 2361:    fseek (ifp, meta_offset, SEEK_SET);
    #####: 2362:    order = 0x4d4d;
    #####: 2363:    ntags = get4();
    #####: 2364:    while (ntags--) {
    #####: 2365:      opcode = get4(); get4(); get4();
    #####: 2366:      if (opcode != 8)
    #####: 2367:      { fseek (ifp, get4(), SEEK_CUR); continue; }
    #####: 2368:      fseek (ifp, 20, SEEK_CUR);
    #####: 2369:      if ((c = get4()) > 2) break;
    #####: 2370:      fseek (ifp, 12, SEEK_CUR);
    #####: 2371:      if ((deg = get4()) > 8) break;
    #####: 2372:      for (i=0; i <= deg && i < 9; i++)
    #####: 2373:	coeff[i] = getreal(12);
    #####: 2374:      for (i=0; i < 256; i++) {
    #####: 2375:	for (tot=j=0; j <= deg; j++)
    #####: 2376:	  tot += coeff[j] * pow(i/255.0, j);
    #####: 2377:	cur[c][i] = tot*0xffff;
        -: 2378:      }
        -: 2379:    }
    #####: 2380:    order = sorder;
        -: 2381:  } else {
    #####: 2382:    gamma_curve (1/2.4, 12.92, 1, 255);
    #####: 2383:    FORC3 memcpy (cur[c], curve, sizeof cur[0]);
        -: 2384:  }
    #####: 2385:  cinfo.err = jpeg_std_error (&jerr);
    #####: 2386:  jpeg_create_decompress (&cinfo);
    #####: 2387:  while (trow < raw_height) {
    #####: 2388:    fseek (ifp, save+=4, SEEK_SET);
    #####: 2389:    if (tile_length < INT_MAX)
    #####: 2390:      fseek (ifp, get4(), SEEK_SET);
    #####: 2391:    jpeg_stdio_src (&cinfo, ifp);
    #####: 2392:    jpeg_read_header (&cinfo, TRUE);
    #####: 2393:    jpeg_start_decompress (&cinfo);
    #####: 2394:    buf = (*cinfo.mem->alloc_sarray)
    #####: 2395:	((j_common_ptr) &cinfo, JPOOL_IMAGE, cinfo.output_width*3, 1);
    #####: 2396:    while (cinfo.output_scanline < cinfo.output_height &&
    #####: 2397:	(row = trow + cinfo.output_scanline) < height) {
    #####: 2398:      jpeg_read_scanlines (&cinfo, buf, 1);
    #####: 2399:      pixel = (JSAMPLE (*)[3]) buf[0];
    #####: 2400:      for (col=0; col < cinfo.output_width && tcol+col < width; col++) {
    #####: 2401:	FORC3 image[row*width+tcol+col][c] = cur[c][pixel[col][c]];
        -: 2402:      }
        -: 2403:    }
    #####: 2404:    jpeg_abort_decompress (&cinfo);
    #####: 2405:    if ((tcol += tile_width) >= raw_width)
    #####: 2406:      trow += tile_length + (tcol = 0);
        -: 2407:  }
    #####: 2408:  jpeg_destroy_decompress (&cinfo);
    #####: 2409:  maximum = 0xffff;
    #####: 2410:}
        -: 2411:#endif
        -: 2412:
    #####: 2413:void CLASS kodak_dc120_load_raw()
        -: 2414:{
        -: 2415:  static const int mul[4] = { 162, 192, 187,  92 };
        -: 2416:  static const int add[4] = {   0, 636, 424, 212 };
        -: 2417:  uchar pixel[848];
        -: 2418:  int row, shift, col;
        -: 2419:
    #####: 2420:  for (row=0; row < height; row++) {
    #####: 2421:    if (fread (pixel, 1, 848, ifp) < 848) derror();
    #####: 2422:    shift = row * mul[row & 3] + add[row & 3];
    #####: 2423:    for (col=0; col < width; col++)
    #####: 2424:      RAW(row,col) = (ushort) pixel[(col + shift) % 848];
        -: 2425:  }
    #####: 2426:  maximum = 0xff;
    #####: 2427:}
        -: 2428:
    #####: 2429:void CLASS eight_bit_load_raw()
        -: 2430:{
        -: 2431:  uchar *pixel;
        -: 2432:  unsigned row, col;
        -: 2433:
    #####: 2434:  pixel = (uchar *) calloc (raw_width, sizeof *pixel);
    #####: 2435:  merror (pixel, "eight_bit_load_raw()");
    #####: 2436:  for (row=0; row < raw_height; row++) {
    #####: 2437:    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();
    #####: 2438:    for (col=0; col < raw_width; col++)
    #####: 2439:      RAW(row,col) = curve[pixel[col]];
        -: 2440:  }
    #####: 2441:  free (pixel);
    #####: 2442:  maximum = curve[0xff];
    #####: 2443:}
        -: 2444:
    #####: 2445:void CLASS kodak_c330_load_raw()
        -: 2446:{
        -: 2447:  uchar *pixel;
        -: 2448:  int row, col, y, cb, cr, rgb[3], c;
        -: 2449:
    #####: 2450:  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);
    #####: 2451:  merror (pixel, "kodak_c330_load_raw()");
    #####: 2452:  for (row=0; row < height; row++) {
    #####: 2453:    if (fread (pixel, raw_width, 2, ifp) < 2) derror();
    #####: 2454:    if (load_flags && (row & 31) == 31)
    #####: 2455:      fseek (ifp, raw_width*32, SEEK_CUR);
    #####: 2456:    for (col=0; col < width; col++) {
    #####: 2457:      y  = pixel[col*2];
    #####: 2458:      cb = pixel[(col*2 & -4) | 1] - 128;
    #####: 2459:      cr = pixel[(col*2 & -4) | 3] - 128;
    #####: 2460:      rgb[1] = y - ((cb + cr + 2) >> 2);
    #####: 2461:      rgb[2] = rgb[1] + cb;
    #####: 2462:      rgb[0] = rgb[1] + cr;
    #####: 2463:      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
        -: 2464:    }
        -: 2465:  }
    #####: 2466:  free (pixel);
    #####: 2467:  maximum = curve[0xff];
    #####: 2468:}
        -: 2469:
    #####: 2470:void CLASS kodak_c603_load_raw()
        -: 2471:{
        -: 2472:  uchar *pixel;
        -: 2473:  int row, col, y, cb, cr, rgb[3], c;
        -: 2474:
    #####: 2475:  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);
    #####: 2476:  merror (pixel, "kodak_c603_load_raw()");
    #####: 2477:  for (row=0; row < height; row++) {
    #####: 2478:    if (~row & 1)
    #####: 2479:      if (fread (pixel, raw_width, 3, ifp) < 3) derror();
    #####: 2480:    for (col=0; col < width; col++) {
    #####: 2481:      y  = pixel[width*2*(row & 1) + col];
    #####: 2482:      cb = pixel[width + (col & -2)]   - 128;
    #####: 2483:      cr = pixel[width + (col & -2)+1] - 128;
    #####: 2484:      rgb[1] = y - ((cb + cr + 2) >> 2);
    #####: 2485:      rgb[2] = rgb[1] + cb;
    #####: 2486:      rgb[0] = rgb[1] + cr;
    #####: 2487:      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
        -: 2488:    }
        -: 2489:  }
    #####: 2490:  free (pixel);
    #####: 2491:  maximum = curve[0xff];
    #####: 2492:}
        -: 2493:
    #####: 2494:void CLASS kodak_262_load_raw()
        -: 2495:{
        -: 2496:  static const uchar kodak_tree[2][26] =
        -: 2497:  { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },
        -: 2498:    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };
        -: 2499:  ushort *huff[2];
        -: 2500:  uchar *pixel;
        -: 2501:  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;
        -: 2502:
    #####: 2503:  FORC(2) huff[c] = make_decoder (kodak_tree[c]);
    #####: 2504:  ns = (raw_height+63) >> 5;
    #####: 2505:  pixel = (uchar *) malloc (raw_width*32 + ns*4);
    #####: 2506:  merror (pixel, "kodak_262_load_raw()");
    #####: 2507:  strip = (int *) (pixel + raw_width*32);
    #####: 2508:  order = 0x4d4d;
    #####: 2509:  FORC(ns) strip[c] = get4();
    #####: 2510:  for (row=0; row < raw_height; row++) {
    #####: 2511:    if ((row & 31) == 0) {
    #####: 2512:      fseek (ifp, strip[row >> 5], SEEK_SET);
        -: 2513:      getbits(-1);
        -: 2514:      pi = 0;
        -: 2515:    }
    #####: 2516:    for (col=0; col < raw_width; col++) {
    #####: 2517:      chess = (row + col) & 1;
    #####: 2518:      pi1 = chess ? pi-2           : pi-raw_width-1;
    #####: 2519:      pi2 = chess ? pi-2*raw_width : pi-raw_width+1;
    #####: 2520:      if (col <= chess) pi1 = -1;
    #####: 2521:      if (pi1 < 0) pi1 = pi2;
    #####: 2522:      if (pi2 < 0) pi2 = pi1;
    #####: 2523:      if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;
    #####: 2524:      pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;
    #####: 2525:      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);
    #####: 2526:      if (val >> 8) derror();
    #####: 2527:      val = curve[pixel[pi++]];
    #####: 2528:      RAW(row,col) = val;
        -: 2529:    }
        -: 2530:  }
    #####: 2531:  free (pixel);
    #####: 2532:  FORC(2) free (huff[c]);
    #####: 2533:}
        -: 2534:
    #####: 2535:int CLASS kodak_65000_decode (short *out, int bsize)
        -: 2536:{
        -: 2537:  uchar c, blen[768];
        -: 2538:  ushort raw[6];
        -: 2539:  INT64 bitbuf=0;
        -: 2540:  int save, bits=0, i, j, len, diff;
        -: 2541:
    #####: 2542:  save = ftell(ifp);
    #####: 2543:  bsize = (bsize + 3) & -4;
    #####: 2544:  for (i=0; i < bsize; i+=2) {
    #####: 2545:    c = fgetc(ifp);
    #####: 2546:    if ((blen[i  ] = c & 15) > 12 ||
    #####: 2547:	(blen[i+1] = c >> 4) > 12 ) {
    #####: 2548:      fseek (ifp, save, SEEK_SET);
    #####: 2549:      for (i=0; i < bsize; i+=8) {
    #####: 2550:	read_shorts (raw, 6);
    #####: 2551:	out[i  ] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;
    #####: 2552:	out[i+1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;
    #####: 2553:	for (j=0; j < 6; j++)
    #####: 2554:	  out[i+2+j] = raw[j] & 0xfff;
        -: 2555:      }
        -: 2556:      return 1;
        -: 2557:    }
        -: 2558:  }
    #####: 2559:  if ((bsize & 7) == 4) {
    #####: 2560:    bitbuf  = fgetc(ifp) << 8;
    #####: 2561:    bitbuf += fgetc(ifp);
        -: 2562:    bits = 16;
        -: 2563:  }
    #####: 2564:  for (i=0; i < bsize; i++) {
    #####: 2565:    len = blen[i];
    #####: 2566:    if (bits < len) {
    #####: 2567:      for (j=0; j < 32; j+=8)
    #####: 2568:	bitbuf += (INT64) fgetc(ifp) << (bits+(j^8));
    #####: 2569:      bits += 32;
        -: 2570:    }
    #####: 2571:    diff = bitbuf & (0xffff >> (16-len));
    #####: 2572:    bitbuf >>= len;
    #####: 2573:    bits -= len;
    #####: 2574:    if ((diff & (1 << (len-1))) == 0)
    #####: 2575:      diff -= (1 << len) - 1;
    #####: 2576:    out[i] = diff;
        -: 2577:  }
        -: 2578:  return 0;
        -: 2579:}
        -: 2580:
    #####: 2581:void CLASS kodak_65000_load_raw()
        -: 2582:{
        -: 2583:  short buf[256];
        -: 2584:  int row, col, len, pred[2], ret, i;
        -: 2585:
    #####: 2586:  for (row=0; row < height; row++)
    #####: 2587:    for (col=0; col < width; col+=256) {
    #####: 2588:      pred[0] = pred[1] = 0;
    #####: 2589:      len = MIN (256, width-col);
    #####: 2590:      ret = kodak_65000_decode (buf, len);
    #####: 2591:      for (i=0; i < len; i++)
    #####: 2592:	if ((RAW(row,col+i) =	curve[ret ? buf[i] :
    #####: 2593:		(pred[i & 1] += buf[i])]) >> 12) derror();
        -: 2594:    }
    #####: 2595:}
        -: 2596:
    #####: 2597:void CLASS kodak_ycbcr_load_raw()
        -: 2598:{
        -: 2599:  short buf[384], *bp;
        -: 2600:  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];
        -: 2601:  ushort *ip;
        -: 2602:
    #####: 2603:  if (!image) return;
    #####: 2604:  for (row=0; row < height; row+=2)
    #####: 2605:    for (col=0; col < width; col+=128) {
    #####: 2606:      len = MIN (128, width-col);
    #####: 2607:      kodak_65000_decode (buf, len*3);
    #####: 2608:      y[0][1] = y[1][1] = cb = cr = 0;
    #####: 2609:      for (bp=buf, i=0; i < len; i+=2, bp+=2) {
    #####: 2610:	cb += bp[4];
    #####: 2611:	cr += bp[5];
    #####: 2612:	rgb[1] = -((cb + cr + 2) >> 2);
    #####: 2613:	rgb[2] = rgb[1] + cb;
    #####: 2614:	rgb[0] = rgb[1] + cr;
    #####: 2615:	for (j=0; j < 2; j++)
    #####: 2616:	  for (k=0; k < 2; k++) {
    #####: 2617:	    if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();
    #####: 2618:	    ip = image[(row+j)*width + col+i+k];
    #####: 2619:	    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];
        -: 2620:	  }
        -: 2621:      }
        -: 2622:    }
        -: 2623:}
        -: 2624:
    #####: 2625:void CLASS kodak_rgb_load_raw()
        -: 2626:{
        -: 2627:  short buf[768], *bp;
        -: 2628:  int row, col, len, c, i, rgb[3];
    #####: 2629:  ushort *ip=image[0];
        -: 2630:
    #####: 2631:  for (row=0; row < height; row++)
    #####: 2632:    for (col=0; col < width; col+=256) {
    #####: 2633:      len = MIN (256, width-col);
    #####: 2634:      kodak_65000_decode (buf, len*3);
    #####: 2635:      memset (rgb, 0, sizeof rgb);
    #####: 2636:      for (bp=buf, i=0; i < len; i++, ip+=4)
    #####: 2637:	FORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();
        -: 2638:    }
    #####: 2639:}
        -: 2640:
    #####: 2641:void CLASS kodak_thumb_load_raw()
        -: 2642:{
        -: 2643:  int row, col;
    #####: 2644:  colors = thumb_misc >> 5;
    #####: 2645:  for (row=0; row < height; row++)
    #####: 2646:    for (col=0; col < width; col++)
    #####: 2647:      read_shorts (image[row*width+col], colors);
    #####: 2648:  maximum = (1 << (thumb_misc & 31)) - 1;
    #####: 2649:}
        -: 2650:
    #####: 2651:void CLASS sony_decrypt (unsigned *data, int len, int start, int key)
        -: 2652:{
        -: 2653:  static unsigned pad[128], p;
        -: 2654:
    #####: 2655:  if (start) {
    #####: 2656:    for (p=0; p < 4; p++)
    #####: 2657:      pad[p] = key = key * 48828125 + 1;
    #####: 2658:    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;
    #####: 2659:    for (p=4; p < 127; p++)
    #####: 2660:      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;
    #####: 2661:    for (p=0; p < 127; p++)
    #####: 2662:      pad[p] = htonl(pad[p]);
        -: 2663:  }
    #####: 2664:  while (len-- && p++)
    #####: 2665:    *data++ ^= pad[(p-1) & 127] = pad[p & 127] ^ pad[(p+64) & 127];
    #####: 2666:}
        -: 2667:
    #####: 2668:void CLASS sony_load_raw()
        -: 2669:{
        -: 2670:  uchar head[40];
        -: 2671:  ushort *pixel;
        -: 2672:  unsigned i, key, row, col;
        -: 2673:
    #####: 2674:  fseek (ifp, 200896, SEEK_SET);
    #####: 2675:  fseek (ifp, (unsigned) fgetc(ifp)*4 - 1, SEEK_CUR);
    #####: 2676:  order = 0x4d4d;
    #####: 2677:  key = get4();
    #####: 2678:  fseek (ifp, 164600, SEEK_SET);
    #####: 2679:  fread (head, 1, 40, ifp);
    #####: 2680:  sony_decrypt ((unsigned *) head, 10, 1, key);
    #####: 2681:  for (i=26; i-- > 22; )
    #####: 2682:    key = key << 8 | head[i];
    #####: 2683:  fseek (ifp, data_offset, SEEK_SET);
    #####: 2684:  for (row=0; row < raw_height; row++) {
    #####: 2685:    pixel = raw_image + row*raw_width;
    #####: 2686:    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();
    #####: 2687:    sony_decrypt ((unsigned *) pixel, raw_width/2, !row, key);
    #####: 2688:    for (col=0; col < raw_width; col++)
    #####: 2689:      if ((pixel[col] = ntohs(pixel[col])) >> 14) derror();
        -: 2690:  }
    #####: 2691:  maximum = 0x3ff0;
    #####: 2692:}
        -: 2693:
    #####: 2694:void CLASS sony_arw_load_raw()
        -: 2695:{
        -: 2696:  ushort huff[32770];
        -: 2697:  static const ushort tab[18] =
        -: 2698:  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,
        -: 2699:    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };
        -: 2700:  int i, c, n, col, row, sum=0;
        -: 2701:
    #####: 2702:  huff[0] = 15;
    #####: 2703:  for (n=i=0; i < 18; i++)
    #####: 2704:    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];
        -: 2705:  getbits(-1);
    #####: 2706:  for (col = raw_width; col--; )
    #####: 2707:    for (row=0; row < raw_height+1; row+=2) {
    #####: 2708:      if (row == raw_height) row = 1;
    #####: 2709:      if ((sum += ljpeg_diff(huff)) >> 12) derror();
    #####: 2710:      if (row < height) RAW(row,col) = sum;
        -: 2711:    }
    #####: 2712:}
        -: 2713:
    #####: 2714:void CLASS sony_arw2_load_raw()
        -: 2715:{
        -: 2716:  uchar *data, *dp;
        -: 2717:  ushort pix[16];
        -: 2718:  int row, col, val, max, min, imax, imin, sh, bit, i;
        -: 2719:
    #####: 2720:  data = (uchar *) malloc (raw_width+1);
    #####: 2721:  merror (data, "sony_arw2_load_raw()");
    #####: 2722:  for (row=0; row < height; row++) {
    #####: 2723:    fread (data, 1, raw_width, ifp);
    #####: 2724:    for (dp=data, col=0; col < raw_width-30; dp+=16) {
    #####: 2725:      max = 0x7ff & (val = sget4(dp));
    #####: 2726:      min = 0x7ff & val >> 11;
    #####: 2727:      imax = 0x0f & val >> 22;
    #####: 2728:      imin = 0x0f & val >> 26;
    #####: 2729:      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);
    #####: 2730:      for (bit=30, i=0; i < 16; i++)
    #####: 2731:	if      (i == imax) pix[i] = max;
    #####: 2732:	else if (i == imin) pix[i] = min;
        -: 2733:	else {
    #####: 2734:	  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;
    #####: 2735:	  if (pix[i] > 0x7ff) pix[i] = 0x7ff;
    #####: 2736:	  bit += 7;
        -: 2737:	}
    #####: 2738:      for (i=0; i < 16; i++, col+=2)
    #####: 2739:	RAW(row,col) = curve[pix[i] << 1] >> 2;
    #####: 2740:      col -= col & 1 ? 1:31;
        -: 2741:    }
        -: 2742:  }
    #####: 2743:  free (data);
    #####: 2744:}
        -: 2745:
    #####: 2746:void CLASS samsung_load_raw()
        -: 2747:{
        -: 2748:  int row, col, c, i, dir, op[4], len[4];
        -: 2749:
    #####: 2750:  order = 0x4949;
    #####: 2751:  for (row=0; row < raw_height; row++) {
    #####: 2752:    fseek (ifp, strip_offset+row*4, SEEK_SET);
    #####: 2753:    fseek (ifp, data_offset+get4(), SEEK_SET);
        -: 2754:    ph1_bits(-1);
    #####: 2755:    FORC4 len[c] = row < 2 ? 7:4;
    #####: 2756:    for (col=0; col < raw_width; col+=16) {
    #####: 2757:      dir = ph1_bits(1);
    #####: 2758:      FORC4 op[c] = ph1_bits(2);
    #####: 2759:      FORC4 switch (op[c]) {
    #####: 2760:	case 3: len[c] = ph1_bits(4);	break;
    #####: 2761:	case 2: len[c]--;		break;
    #####: 2762:	case 1: len[c]++;
        -: 2763:      }
    #####: 2764:      for (c=0; c < 16; c+=2) {
    #####: 2765:	i = len[((c & 1) << 1) | (c >> 3)];
    #####: 2766:        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +
    #####: 2767:	  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);
    #####: 2768:	if (c == 14) c = -1;
        -: 2769:      }
        -: 2770:    }
        -: 2771:  }
    #####: 2772:  for (row=0; row < raw_height-1; row+=2)
    #####: 2773:    for (col=0; col < raw_width-1; col+=2)
    #####: 2774:      SWAP (RAW(row,col+1), RAW(row+1,col));
    #####: 2775:}
        -: 2776:
    #####: 2777:void CLASS samsung2_load_raw()
        -: 2778:{
        -: 2779:  static const ushort tab[14] =
        -: 2780:  { 0x304,0x307,0x206,0x205,0x403,0x600,0x709,
        -: 2781:    0x80a,0x90b,0xa0c,0xa0d,0x501,0x408,0x402 };
    #####: 2782:  ushort huff[1026], vpred[2][2] = {{0,0},{0,0}}, hpred[2];
        -: 2783:  int i, c, n, row, col, diff;
        -: 2784:
    #####: 2785:  huff[0] = 10;
    #####: 2786:  for (n=i=0; i < 14; i++)
    #####: 2787:    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];
        -: 2788:  getbits(-1);
    #####: 2789:  for (row=0; row < raw_height; row++)
    #####: 2790:    for (col=0; col < raw_width; col++) {
    #####: 2791:      diff = ljpeg_diff (huff);
    #####: 2792:      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
    #####: 2793:      else	   hpred[col & 1] += diff;
    #####: 2794:      RAW(row,col) = hpred[col & 1];
    #####: 2795:      if (hpred[col & 1] >> tiff_bps) derror();
        -: 2796:    }
    #####: 2797:}
        -: 2798:
    #####: 2799:void CLASS samsung3_load_raw()
        -: 2800:{
        -: 2801:  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;
        -: 2802:  ushort lent[3][2], len[4], *prow[2];
        -: 2803:
    #####: 2804:  order = 0x4949;
    #####: 2805:  fseek (ifp, 9, SEEK_CUR);
    #####: 2806:  opt = fgetc(ifp);
    #####: 2807:  init = (get2(),get2());
    #####: 2808:  for (row=0; row < raw_height; row++) {
    #####: 2809:    fseek (ifp, (data_offset-ftell(ifp)) & 15, SEEK_CUR);
        -: 2810:    ph1_bits(-1);
        -: 2811:    mag = 0; pmode = 7;
    #####: 2812:    FORC(6) ((ushort *)lent)[c] = row < 2 ? 7:4;
    #####: 2813:    prow[ row & 1] = &RAW(row-1,1-((row & 1) << 1));	// green
    #####: 2814:    prow[~row & 1] = &RAW(row-2,0);			// red and blue
    #####: 2815:    for (tab=0; tab+15 < raw_width; tab+=16) {
    #####: 2816:      if (~opt & 4 && !(tab & 63)) {
    #####: 2817:	i = ph1_bits(2);
    #####: 2818:	mag = i < 3 ? mag-'2'+"204"[i] : ph1_bits(12);
        -: 2819:      }
    #####: 2820:      if (opt & 2)
    #####: 2821:	pmode = 7 - 4*ph1_bits(1);
    #####: 2822:      else if (!ph1_bits(1))
    #####: 2823:	pmode = ph1_bits(3);
    #####: 2824:      if (opt & 1 || !ph1_bits(1)) {
    #####: 2825:	FORC4 len[c] = ph1_bits(2);
    #####: 2826:	FORC4 {
    #####: 2827:	  i = ((row & 1) << 1 | (c & 1)) % 3;
    #####: 2828:	  len[c] = len[c] < 3 ? lent[i][0]-'1'+"120"[len[c]] : ph1_bits(4);
    #####: 2829:	  lent[i][0] = lent[i][1];
    #####: 2830:	  lent[i][1] = len[c];
        -: 2831:	}
        -: 2832:      }
    #####: 2833:      FORC(16) {
    #####: 2834:	col = tab + (((c & 7) << 1)^(c >> 3)^(row & 1));
    #####: 2835:	pred = (pmode == 7 || row < 2)
    #####: 2836:	     ? (tab ? RAW(row,tab-2+(col & 1)) : init)
    #####: 2837:	     : (prow[col & 1][col-'4'+"0224468"[pmode]] +
    #####: 2838:		prow[col & 1][col-'4'+"0244668"[pmode]] + 1) >> 1;
    #####: 2839:	diff = ph1_bits (i = len[c >> 2]);
    #####: 2840:	if (diff >> (i-1)) diff -= 1 << i;
    #####: 2841:	diff = diff * (mag*2+1) + mag;
    #####: 2842:	RAW(row,col) = pred + diff;
        -: 2843:      }
        -: 2844:    }
        -: 2845:  }
    #####: 2846:}
        -: 2847:
        -: 2848:#define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)
        -: 2849:
        -: 2850:/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */
    #####: 2851:void CLASS smal_decode_segment (unsigned seg[2][2], int holes)
        -: 2852:{
    #####: 2853:  uchar hist[3][13] = {
        -: 2854:    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },
        -: 2855:    { 7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0 },
        -: 2856:    { 3, 3, 0, 0, 63,     47,     31,     15,    0 } };
        -: 2857:  int low, high=0xff, carry=0, nbits=8;
        -: 2858:  int pix, s, count, bin, next, i, sym[3];
    #####: 2859:  uchar diff, pred[]={0,0};
        -: 2860:  ushort data=0, range=0;
        -: 2861:
    #####: 2862:  fseek (ifp, seg[0][1]+1, SEEK_SET);
        -: 2863:  getbits(-1);
    #####: 2864:  if (seg[1][0] > raw_width*raw_height)
    #####: 2865:      seg[1][0] = raw_width*raw_height;
    #####: 2866:  for (pix=seg[0][0]; pix < seg[1][0]; pix++) {
    #####: 2867:    for (s=0; s < 3; s++) {
    #####: 2868:      data = data << nbits | getbits(nbits);
    #####: 2869:      if (carry < 0)
    #####: 2870:	carry = (nbits += carry+1) < 1 ? nbits-1 : 0;
    #####: 2871:      while (--nbits >= 0)
    #####: 2872:	if ((data >> nbits & 0xff) == 0xff) break;
    #####: 2873:      if (nbits > 0)
    #####: 2874:	  data = ((data & ((1 << (nbits-1)) - 1)) << 1) |
    #####: 2875:	((data + (((data & (1 << (nbits-1)))) << 1)) & (-1 << nbits));
    #####: 2876:      if (nbits >= 0) {
    #####: 2877:	data += getbits(1);
    #####: 2878:	carry = nbits - 8;
        -: 2879:      }
    #####: 2880:      count = ((((data-range+1) & 0xffff) << 2) - 1) / (high >> 4);
    #####: 2881:      for (bin=0; hist[s][bin+5] > count; bin++);
    #####: 2882:		low = hist[s][bin+5] * (high >> 4) >> 2;
    #####: 2883:      if (bin) high = hist[s][bin+4] * (high >> 4) >> 2;
    #####: 2884:      high -= low;
    #####: 2885:      for (nbits=0; high << nbits < 128; nbits++);
    #####: 2886:      range = (range+low) << nbits;
        -: 2887:      high <<= nbits;
    #####: 2888:      next = hist[s][1];
    #####: 2889:      if (++hist[s][2] > hist[s][3]) {
    #####: 2890:	next = (next+1) & hist[s][0];
    #####: 2891:	hist[s][3] = (hist[s][next+4] - hist[s][next+5]) >> 2;
    #####: 2892:	hist[s][2] = 1;
        -: 2893:      }
    #####: 2894:      if (hist[s][hist[s][1]+4] - hist[s][hist[s][1]+5] > 1) {
    #####: 2895:	if (bin < hist[s][1])
    #####: 2896:	  for (i=bin; i < hist[s][1]; i++) hist[s][i+5]--;
    #####: 2897:	else if (next <= bin)
    #####: 2898:	  for (i=hist[s][1]; i < bin; i++) hist[s][i+5]++;
        -: 2899:      }
    #####: 2900:      hist[s][1] = next;
    #####: 2901:      sym[s] = bin;
        -: 2902:    }
    #####: 2903:    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);
    #####: 2904:    if (sym[0] & 4)
    #####: 2905:      diff = diff ? -diff : 0x80;
    #####: 2906:    if (ftell(ifp) + 12 >= seg[1][1])
        -: 2907:      diff = 0;
    #####: 2908:    raw_image[pix] = pred[pix & 1] += diff;
    #####: 2909:    if (!(pix & 1) && HOLE(pix / raw_width)) pix += 2;
        -: 2910:  }
    #####: 2911:  maximum = 0xff;
    #####: 2912:}
        -: 2913:
    #####: 2914:void CLASS smal_v6_load_raw()
        -: 2915:{
        -: 2916:  unsigned seg[2][2];
        -: 2917:
    #####: 2918:  fseek (ifp, 16, SEEK_SET);
    #####: 2919:  seg[0][0] = 0;
    #####: 2920:  seg[0][1] = get2();
    #####: 2921:  seg[1][0] = raw_width * raw_height;
    #####: 2922:  seg[1][1] = INT_MAX;
    #####: 2923:  smal_decode_segment (seg, 0);
    #####: 2924:}
        -: 2925:
    #####: 2926:int CLASS median4 (int *p)
        -: 2927:{
        -: 2928:  int min, max, sum, i;
        -: 2929:
    #####: 2930:  min = max = sum = p[0];
    #####: 2931:  for (i=1; i < 4; i++) {
    #####: 2932:    sum += p[i];
    #####: 2933:    if (min > p[i]) min = p[i];
    #####: 2934:    if (max < p[i]) max = p[i];
        -: 2935:  }
    #####: 2936:  return (sum - min - max) >> 1;
        -: 2937:}
        -: 2938:
    #####: 2939:void CLASS fill_holes (int holes)
        -: 2940:{
        -: 2941:  int row, col, val[4];
        -: 2942:
    #####: 2943:  for (row=2; row < height-2; row++) {
    #####: 2944:    if (!HOLE(row)) continue;
    #####: 2945:    for (col=1; col < width-1; col+=4) {
    #####: 2946:      val[0] = RAW(row-1,col-1);
    #####: 2947:      val[1] = RAW(row-1,col+1);
    #####: 2948:      val[2] = RAW(row+1,col-1);
    #####: 2949:      val[3] = RAW(row+1,col+1);
    #####: 2950:      RAW(row,col) = median4(val);
        -: 2951:    }
    #####: 2952:    for (col=2; col < width-2; col+=4)
    #####: 2953:      if (HOLE(row-2) || HOLE(row+2))
    #####: 2954:	RAW(row,col) = (RAW(row,col-2) + RAW(row,col+2)) >> 1;
        -: 2955:      else {
    #####: 2956:	val[0] = RAW(row,col-2);
    #####: 2957:	val[1] = RAW(row,col+2);
    #####: 2958:	val[2] = RAW(row-2,col);
    #####: 2959:	val[3] = RAW(row+2,col);
    #####: 2960:	RAW(row,col) = median4(val);
        -: 2961:      }
        -: 2962:  }
    #####: 2963:}
        -: 2964:
    #####: 2965:void CLASS smal_v9_load_raw()
        -: 2966:{
        -: 2967:  unsigned seg[256][2], offset, nseg, holes, i;
        -: 2968:
    #####: 2969:  fseek (ifp, 67, SEEK_SET);
    #####: 2970:  offset = get4();
    #####: 2971:  nseg = (uchar) fgetc(ifp);
    #####: 2972:  fseek (ifp, offset, SEEK_SET);
    #####: 2973:  for (i=0; i < nseg*2; i++)
    #####: 2974:    ((unsigned *)seg)[i] = get4() + data_offset*(i & 1);
    #####: 2975:  fseek (ifp, 78, SEEK_SET);
    #####: 2976:  holes = fgetc(ifp);
    #####: 2977:  fseek (ifp, 88, SEEK_SET);
    #####: 2978:  seg[nseg][0] = raw_height * raw_width;
    #####: 2979:  seg[nseg][1] = get4() + data_offset;
    #####: 2980:  for (i=0; i < nseg; i++)
    #####: 2981:    smal_decode_segment (seg+i, holes);
    #####: 2982:  if (holes) fill_holes (holes);
    #####: 2983:}
        -: 2984:
    #####: 2985:void CLASS redcine_load_raw()
        -: 2986:{
        -: 2987:#ifndef NO_JASPER
        -: 2988:  int c, row, col;
        -: 2989:  jas_stream_t *in;
        -: 2990:  jas_image_t *jimg;
        -: 2991:  jas_matrix_t *jmat;
        -: 2992:  jas_seqent_t *data;
        -: 2993:  ushort *img, *pix;
        -: 2994:
    #####: 2995:  jas_init();
    #####: 2996:  in = jas_stream_fopen (ifname, "rb");
    #####: 2997:  jas_stream_seek (in, data_offset+20, SEEK_SET);
    #####: 2998:  jimg = jas_image_decode (in, -1, 0);
    #####: 2999:  if (!jimg) longjmp (failure, 3);
    #####: 3000:  jmat = jas_matrix_create (height/2, width/2);
    #####: 3001:  merror (jmat, "redcine_load_raw()");
    #####: 3002:  img = (ushort *) calloc ((height+2), (width+2)*2);
    #####: 3003:  merror (img, "redcine_load_raw()");
    #####: 3004:  FORC4 {
    #####: 3005:    jas_image_readcmpt (jimg, c, 0, 0, width/2, height/2, jmat);
    #####: 3006:    data = jas_matrix_getref (jmat, 0, 0);
    #####: 3007:    for (row = c >> 1; row < height; row+=2)
    #####: 3008:      for (col = c & 1; col < width; col+=2)
    #####: 3009:	img[(row+1)*(width+2)+col+1] = data[(row/2)*(width/2)+col/2];
        -: 3010:  }
    #####: 3011:  for (col=1; col <= width; col++) {
    #####: 3012:    img[col] = img[2*(width+2)+col];
    #####: 3013:    img[(height+1)*(width+2)+col] = img[(height-1)*(width+2)+col];
        -: 3014:  }
    #####: 3015:  for (row=0; row < height+2; row++) {
    #####: 3016:    img[row*(width+2)] = img[row*(width+2)+2];
    #####: 3017:    img[(row+1)*(width+2)-1] = img[(row+1)*(width+2)-3];
        -: 3018:  }
    #####: 3019:  for (row=1; row <= height; row++) {
    #####: 3020:    pix = img + row*(width+2) + (col = 1 + (FC(row,1) & 1));
    #####: 3021:    for (   ; col <= width; col+=2, pix+=2) {
    #####: 3022:      c = (((pix[0] - 0x800) << 3) +
    #####: 3023:	pix[-(width+2)] + pix[width+2] + pix[-1] + pix[1]) >> 2;
    #####: 3024:      pix[0] = LIM(c,0,4095);
        -: 3025:    }
        -: 3026:  }
    #####: 3027:  for (row=0; row < height; row++)
    #####: 3028:    for (col=0; col < width; col++)
    #####: 3029:      RAW(row,col) = curve[img[(row+1)*(width+2)+col+1]];
    #####: 3030:  free (img);
    #####: 3031:  jas_matrix_destroy (jmat);
    #####: 3032:  jas_image_destroy (jimg);
    #####: 3033:  jas_stream_close (in);
        -: 3034:#endif
    #####: 3035:}
        -: 3036:
        -: 3037:/* RESTRICTED code starts here */
        -: 3038:
    #####: 3039:void CLASS foveon_decoder (unsigned size, unsigned code)
        -: 3040:{
        -: 3041:  static unsigned huff[1024];
        -: 3042:  struct decode *cur;
        -: 3043:  int i, len;
        -: 3044:
    #####: 3045:  if (!code) {
    #####: 3046:    for (i=0; i < size; i++)
    #####: 3047:      huff[i] = get4();
    #####: 3048:    memset (first_decode, 0, sizeof first_decode);
    #####: 3049:    free_decode = first_decode;
        -: 3050:  }
    #####: 3051:  cur = free_decode++;
    #####: 3052:  if (free_decode > first_decode+2048) {
    #####: 3053:    fprintf (stderr,_("%s: decoder table overflow\n"), ifname);
    #####: 3054:    longjmp (failure, 2);
        -: 3055:  }
    #####: 3056:  if (code)
    #####: 3057:    for (i=0; i < size; i++)
    #####: 3058:      if (huff[i] == code) {
    #####: 3059:	cur->leaf = i;
    #####: 3060:	return;
        -: 3061:      }
    #####: 3062:  if ((len = code >> 27) > 26) return;
    #####: 3063:  code = (len+1) << 27 | (code & 0x3ffffff) << 1;
        -: 3064:
    #####: 3065:  cur->branch[0] = free_decode;
    #####: 3066:  foveon_decoder (size, code);
    #####: 3067:  cur->branch[1] = free_decode;
    #####: 3068:  foveon_decoder (size, code+1);
        -: 3069:}
        -: 3070:
    #####: 3071:void CLASS foveon_thumb()
        -: 3072:{
        -: 3073:  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;
        -: 3074:  char *buf;
        -: 3075:  struct decode *dindex;
        -: 3076:  short pred[3];
        -: 3077:
    #####: 3078:  bwide = get4();
    #####: 3079:  fprintf (ofp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
    #####: 3080:  if (bwide > 0) {
    #####: 3081:    if (bwide < thumb_width*3) return;
    #####: 3082:    buf = (char *) malloc (bwide);
    #####: 3083:    merror (buf, "foveon_thumb()");
    #####: 3084:    for (row=0; row < thumb_height; row++) {
    #####: 3085:      fread  (buf, 1, bwide, ifp);
    #####: 3086:      fwrite (buf, 3, thumb_width, ofp);
        -: 3087:    }
    #####: 3088:    free (buf);
    #####: 3089:    return;
        -: 3090:  }
    #####: 3091:  foveon_decoder (256, 0);
        -: 3092:
    #####: 3093:  for (row=0; row < thumb_height; row++) {
    #####: 3094:    memset (pred, 0, sizeof pred);
    #####: 3095:    if (!bit) get4();
    #####: 3096:    for (bit=col=0; col < thumb_width; col++)
    #####: 3097:      FORC3 {
    #####: 3098:	for (dindex=first_decode; dindex->branch[0]; ) {
    #####: 3099:	  if ((bit = (bit-1) & 31) == 31)
    #####: 3100:	    for (i=0; i < 4; i++)
    #####: 3101:	      bitbuf = (bitbuf << 8) + fgetc(ifp);
    #####: 3102:	  dindex = dindex->branch[bitbuf >> bit & 1];
        -: 3103:	}
    #####: 3104:	pred[c] += dindex->leaf;
    #####: 3105:	fputc (pred[c], ofp);
        -: 3106:      }
        -: 3107:  }
        -: 3108:}
        -: 3109:
    #####: 3110:void CLASS foveon_sd_load_raw()
        -: 3111:{
        -: 3112:  struct decode *dindex;
        -: 3113:  short diff[1024];
        -: 3114:  unsigned bitbuf=0;
        -: 3115:  int pred[3], row, col, bit=-1, c, i;
        -: 3116:
    #####: 3117:  read_shorts ((ushort *) diff, 1024);
    #####: 3118:  if (!load_flags) foveon_decoder (1024, 0);
        -: 3119:
    #####: 3120:  for (row=0; row < height; row++) {
    #####: 3121:    memset (pred, 0, sizeof pred);
    #####: 3122:    if (!bit && !load_flags && atoi(model+2) < 14) get4();
    #####: 3123:    for (col=bit=0; col < width; col++) {
    #####: 3124:      if (load_flags) {
    #####: 3125:	bitbuf = get4();
    #####: 3126:	FORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];
        -: 3127:      }
    #####: 3128:      else FORC3 {
    #####: 3129:	for (dindex=first_decode; dindex->branch[0]; ) {
    #####: 3130:	  if ((bit = (bit-1) & 31) == 31)
    #####: 3131:	    for (i=0; i < 4; i++)
    #####: 3132:	      bitbuf = (bitbuf << 8) + fgetc(ifp);
    #####: 3133:	  dindex = dindex->branch[bitbuf >> bit & 1];
        -: 3134:	}
    #####: 3135:	pred[c] += diff[dindex->leaf];
    #####: 3136:	if (pred[c] >> 16 && ~pred[c] >> 16) derror();
        -: 3137:      }
    #####: 3138:      FORC3 image[row*width+col][c] = pred[c];
        -: 3139:    }
        -: 3140:  }
    #####: 3141:}
        -: 3142:
    #####: 3143:void CLASS foveon_huff (ushort *huff)
        -: 3144:{
        -: 3145:  int i, j, clen, code;
        -: 3146:
    #####: 3147:  huff[0] = 8;
    #####: 3148:  for (i=0; i < 13; i++) {
    #####: 3149:    clen = getc(ifp);
    #####: 3150:    code = getc(ifp);
    #####: 3151:    for (j=0; j < 256 >> clen; )
    #####: 3152:      huff[code+ ++j] = clen << 8 | i;
        -: 3153:  }
    #####: 3154:  get2();
    #####: 3155:}
        -: 3156:
    #####: 3157:void CLASS foveon_dp_load_raw()
        -: 3158:{
        -: 3159:  unsigned c, roff[4], row, col, diff;
        -: 3160:  ushort huff[512], vpred[2][2], hpred[2];
        -: 3161:
    #####: 3162:  fseek (ifp, 8, SEEK_CUR);
    #####: 3163:  foveon_huff (huff);
    #####: 3164:  roff[0] = 48;
    #####: 3165:  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);
    #####: 3166:  FORC3 {
    #####: 3167:    fseek (ifp, data_offset+roff[c], SEEK_SET);
        -: 3168:    getbits(-1);
    #####: 3169:    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;
    #####: 3170:    for (row=0; row < height; row++) {
    #####: 3171:      for (col=0; col < width; col++) {
    #####: 3172:	diff = ljpeg_diff(huff);
    #####: 3173:	if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
    #####: 3174:	else hpred[col & 1] += diff;
    #####: 3175:	image[row*width+col][c] = hpred[col & 1];
        -: 3176:      }
        -: 3177:    }
        -: 3178:  }
    #####: 3179:}
        -: 3180:
    #####: 3181:void CLASS foveon_load_camf()
        -: 3182:{
        -: 3183:  unsigned type, wide, high, i, j, row, col, diff;
    #####: 3184:  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];
        -: 3185:
    #####: 3186:  fseek (ifp, meta_offset, SEEK_SET);
    #####: 3187:  type = get4();  get4();  get4();
    #####: 3188:  wide = get4();
    #####: 3189:  high = get4();
    #####: 3190:  if (type == 2) {
    #####: 3191:    fread (meta_data, 1, meta_length, ifp);
    #####: 3192:    for (i=0; i < meta_length; i++) {
    #####: 3193:      high = (high * 1597 + 51749) % 244944;
    #####: 3194:      wide = high * (INT64) 301593171 >> 24;
    #####: 3195:      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;
        -: 3196:    }
    #####: 3197:  } else if (type == 4) {
    #####: 3198:    free (meta_data);
    #####: 3199:    meta_data = (char *) malloc (meta_length = wide*high*3/2);
    #####: 3200:    merror (meta_data, "foveon_load_camf()");
    #####: 3201:    foveon_huff (huff);
    #####: 3202:    get4();
        -: 3203:    getbits(-1);
    #####: 3204:    for (j=row=0; row < high; row++) {
    #####: 3205:      for (col=0; col < wide; col++) {
    #####: 3206:	diff = ljpeg_diff(huff);
    #####: 3207:	if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
    #####: 3208:	else         hpred[col & 1] += diff;
    #####: 3209:	if (col & 1) {
    #####: 3210:	  meta_data[j++] = hpred[0] >> 4;
    #####: 3211:	  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;
    #####: 3212:	  meta_data[j++] = hpred[1];
        -: 3213:	}
        -: 3214:      }
        -: 3215:    }
        -: 3216:  } else
    #####: 3217:    fprintf (stderr,_("%s has unknown CAMF type %d.\n"), ifname, type);
    #####: 3218:}
        -: 3219:
    #####: 3220:const char * CLASS foveon_camf_param (const char *block, const char *param)
        -: 3221:{
        -: 3222:  unsigned idx, num;
        -: 3223:  char *pos, *cp, *dp;
        -: 3224:
    #####: 3225:  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {
    #####: 3226:    pos = meta_data + idx;
    #####: 3227:    if (strncmp (pos, "CMb", 3)) break;
    #####: 3228:    if (pos[3] != 'P') continue;
    #####: 3229:    if (strcmp (block, pos+sget4(pos+12))) continue;
    #####: 3230:    cp = pos + sget4(pos+16);
    #####: 3231:    num = sget4(cp);
    #####: 3232:    dp = pos + sget4(cp+4);
    #####: 3233:    while (num--) {
    #####: 3234:      cp += 8;
    #####: 3235:      if (!strcmp (param, dp+sget4(cp)))
    #####: 3236:	return dp+sget4(cp+4);
        -: 3237:    }
        -: 3238:  }
        -: 3239:  return 0;
        -: 3240:}
        -: 3241:
    #####: 3242:void * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)
        -: 3243:{
        -: 3244:  unsigned i, idx, type, ndim, size, *mat;
        -: 3245:  char *pos, *cp, *dp;
        -: 3246:  double dsize;
        -: 3247:
    #####: 3248:  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {
    #####: 3249:    pos = meta_data + idx;
    #####: 3250:    if (strncmp (pos, "CMb", 3)) break;
    #####: 3251:    if (pos[3] != 'M') continue;
    #####: 3252:    if (strcmp (name, pos+sget4(pos+12))) continue;
    #####: 3253:    dim[0] = dim[1] = dim[2] = 1;
    #####: 3254:    cp = pos + sget4(pos+16);
    #####: 3255:    type = sget4(cp);
    #####: 3256:    if ((ndim = sget4(cp+4)) > 3) break;
    #####: 3257:    dp = pos + sget4(cp+8);
    #####: 3258:    for (i=ndim; i--; ) {
    #####: 3259:      cp += 12;
    #####: 3260:      dim[i] = sget4(cp);
        -: 3261:    }
    #####: 3262:    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;
    #####: 3263:    mat = (unsigned *) malloc ((size = dsize) * 4);
    #####: 3264:    merror (mat, "foveon_camf_matrix()");
    #####: 3265:    for (i=0; i < size; i++)
    #####: 3266:      if (type && type != 6)
    #####: 3267:	mat[i] = sget4(dp + i*4);
        -: 3268:      else
    #####: 3269:	mat[i] = sget4(dp + i*2) & 0xffff;
        -: 3270:    return mat;
        -: 3271:  }
    #####: 3272:  fprintf (stderr,_("%s: \"%s\" matrix not found!\n"), ifname, name);
    #####: 3273:  return 0;
        -: 3274:}
        -: 3275:
    #####: 3276:int CLASS foveon_fixed (void *ptr, int size, const char *name)
        -: 3277:{
        -: 3278:  void *dp;
        -: 3279:  unsigned dim[3];
        -: 3280:
    #####: 3281:  if (!name) return 0;
    #####: 3282:  dp = foveon_camf_matrix (dim, name);
    #####: 3283:  if (!dp) return 0;
    #####: 3284:  memcpy (ptr, dp, size*4);
    #####: 3285:  free (dp);
    #####: 3286:  return 1;
        -: 3287:}
        -: 3288:
    #####: 3289:float CLASS foveon_avg (short *pix, int range[2], float cfilt)
        -: 3290:{
        -: 3291:  int i;
        -: 3292:  float val, min=FLT_MAX, max=-FLT_MAX, sum=0;
        -: 3293:
    #####: 3294:  for (i=range[0]; i <= range[1]; i++) {
    #####: 3295:    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;
    #####: 3296:    if (min > val) min = val;
    #####: 3297:    if (max < val) max = val;
        -: 3298:  }
    #####: 3299:  if (range[1] - range[0] == 1) return sum/2;
    #####: 3300:  return (sum - min - max) / (range[1] - range[0] - 1);
        -: 3301:}
        -: 3302:
    #####: 3303:short * CLASS foveon_make_curve (double max, double mul, double filt)
        -: 3304:{
        -: 3305:  short *curve;
        -: 3306:  unsigned i, size;
        -: 3307:  double x;
        -: 3308:
    #####: 3309:  if (!filt) filt = 0.8;
    #####: 3310:  size = 4*M_PI*max / filt;
    #####: 3311:  if (size == UINT_MAX) size--;
    #####: 3312:  curve = (short *) calloc (size+1, sizeof *curve);
    #####: 3313:  merror (curve, "foveon_make_curve()");
    #####: 3314:  curve[0] = size;
    #####: 3315:  for (i=0; i < size; i++) {
    #####: 3316:    x = i*filt/max/4;
    #####: 3317:    curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;
        -: 3318:  }
    #####: 3319:  return curve;
        -: 3320:}
        -: 3321:
    #####: 3322:void CLASS foveon_make_curves
        -: 3323:	(short **curvep, float dq[3], float div[3], float filt)
        -: 3324:{
        -: 3325:  double mul[3], max=0;
        -: 3326:  int c;
        -: 3327:
    #####: 3328:  FORC3 mul[c] = dq[c]/div[c];
    #####: 3329:  FORC3 if (max < mul[c]) max = mul[c];
    #####: 3330:  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);
    #####: 3331:}
        -: 3332:
    #####: 3333:int CLASS foveon_apply_curve (short *curve, int i)
        -: 3334:{
    #####: 3335:  if (abs(i) >= curve[0]) return 0;
    #####: 3336:  return i < 0 ? -curve[1-i] : curve[1+i];
        -: 3337:}
        -: 3338:
        -: 3339:#define image ((short (*)[4]) image)
        -: 3340:
    #####: 3341:void CLASS foveon_interpolate()
        -: 3342:{
        -: 3343:  static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };
        -: 3344:  short *pix, prev[3], *curve[8], (*shrink)[3];
    #####: 3345:  float cfilt=0, ddft[3][3][2], ppm[3][3][3];
        -: 3346:  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];
        -: 3347:  float chroma_dq[3], color_dq[3], diag[3][3], div[3];
        -: 3348:  float (*black)[3], (*sgain)[3], (*sgrow)[3];
        -: 3349:  float fsum[3], val, frow, num;
        -: 3350:  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;
        -: 3351:  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];
        -: 3352:  int work[3][3], smlast, smred, smred_p=0, dev[3];
        -: 3353:  int satlev[3], keep[4], active[4];
        -: 3354:  unsigned dim[3], *badpix;
        -: 3355:  double dsum=0, trsum[3];
        -: 3356:  char str[128];
        -: 3357:  const char* cp;
        -: 3358:
    #####: 3359:  if (verbose)
    #####: 3360:    fprintf (stderr,_("Foveon interpolation...\n"));
        -: 3361:
    #####: 3362:  foveon_load_camf();
    #####: 3363:  foveon_fixed (dscr, 4, "DarkShieldColRange");
    #####: 3364:  foveon_fixed (ppm[0][0], 27, "PostPolyMatrix");
    #####: 3365:  foveon_fixed (satlev, 3, "SaturationLevel");
    #####: 3366:  foveon_fixed (keep, 4, "KeepImageArea");
    #####: 3367:  foveon_fixed (active, 4, "ActiveImageArea");
    #####: 3368:  foveon_fixed (chroma_dq, 3, "ChromaDQ");
    #####: 3369:  foveon_fixed (color_dq, 3,
    #####: 3370:	foveon_camf_param ("IncludeBlocks", "ColorDQ") ?
        -: 3371:		"ColorDQ" : "ColorDQCamRGB");
    #####: 3372:  if (foveon_camf_param ("IncludeBlocks", "ColumnFilter"))
    #####: 3373:		 foveon_fixed (&cfilt, 1, "ColumnFilter");
        -: 3374:
    #####: 3375:  memset (ddft, 0, sizeof ddft);
    #####: 3376:  if (!foveon_camf_param ("IncludeBlocks", "DarkDrift")
    #####: 3377:	 || !foveon_fixed (ddft[1][0], 12, "DarkDrift"))
    #####: 3378:    for (i=0; i < 2; i++) {
    #####: 3379:      foveon_fixed (dstb, 4, i ? "DarkShieldBottom":"DarkShieldTop");
    #####: 3380:      for (row = dstb[1]; row <= dstb[3]; row++)
    #####: 3381:	for (col = dstb[0]; col <= dstb[2]; col++)
    #####: 3382:	  FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];
    #####: 3383:      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);
        -: 3384:    }
        -: 3385:
    #####: 3386:  if (!(cp = foveon_camf_param ("WhiteBalanceIlluminants", model2)))
    #####: 3387:  { fprintf (stderr,_("%s: Invalid white balance \"%s\"\n"), ifname, model2);
    #####: 3388:    return; }
    #####: 3389:  foveon_fixed (cam_xyz, 9, cp);
    #####: 3390:  foveon_fixed (correct, 9,
        -: 3391:	foveon_camf_param ("WhiteBalanceCorrections", model2));
    #####: 3392:  memset (last, 0, sizeof last);
    #####: 3393:  for (i=0; i < 3; i++)
    #####: 3394:    for (j=0; j < 3; j++)
    #####: 3395:      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];
        -: 3396:
        -: 3397:  #define LAST(x,y) last[(i+x)%3][(c+y)%3]
    #####: 3398:  for (i=0; i < 3; i++)
    #####: 3399:    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);
        -: 3400:  #undef LAST
    #####: 3401:  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;
    #####: 3402:  sprintf (str, "%sRGBNeutral", model2);
    #####: 3403:  if (foveon_camf_param ("IncludeBlocks", str))
    #####: 3404:    foveon_fixed (div, 3, str);
        -: 3405:  num = 0;
    #####: 3406:  FORC3 if (num < div[c]) num = div[c];
    #####: 3407:  FORC3 div[c] /= num;
        -: 3408:
    #####: 3409:  memset (trans, 0, sizeof trans);
    #####: 3410:  for (i=0; i < 3; i++)
    #####: 3411:    for (j=0; j < 3; j++)
    #####: 3412:      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];
    #####: 3413:  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];
    #####: 3414:  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;
    #####: 3415:  for (i=0; i < 3; i++)
    #####: 3416:    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];
    #####: 3417:  memset (trans, 0, sizeof trans);
    #####: 3418:  for (i=0; i < 3; i++)
    #####: 3419:    for (j=0; j < 3; j++)
    #####: 3420:      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;
        -: 3421:
    #####: 3422:  foveon_make_curves (curve, color_dq, div, cfilt);
    #####: 3423:  FORC3 chroma_dq[c] /= 3;
    #####: 3424:  foveon_make_curves (curve+3, chroma_dq, div, cfilt);
    #####: 3425:  FORC3 dsum += chroma_dq[c] / div[c];
    #####: 3426:  curve[6] = foveon_make_curve (dsum, dsum, cfilt);
    #####: 3427:  curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);
        -: 3428:
    #####: 3429:  sgain = (float (*)[3]) foveon_camf_matrix (dim, "SpatialGain");
    #####: 3430:  if (!sgain) return;
    #####: 3431:  sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);
    #####: 3432:  sgx = (width + dim[1]-2) / (dim[1]-1);
        -: 3433:
    #####: 3434:  black = (float (*)[3]) calloc (height, sizeof *black);
    #####: 3435:  for (row=0; row < height; row++) {
    #####: 3436:    for (i=0; i < 6; i++)
    #####: 3437:      ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +
    #####: 3438:	row / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);
    #####: 3439:    FORC3 black[row][c] =
    #####: 3440:	( foveon_avg (image[row*width]+c, dscr[0], cfilt) +
    #####: 3441:	  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3
    #####: 3442:	  - ddft[0][c][0] ) / 4 - ddft[0][c][1];
        -: 3443:  }
    #####: 3444:  memcpy (black, black+8, sizeof *black*8);
    #####: 3445:  memcpy (black+height-11, black+height-22, 11*sizeof *black);
    #####: 3446:  memcpy (last, black, sizeof last);
        -: 3447:
    #####: 3448:  for (row=1; row < height-1; row++) {
    #####: 3449:    FORC3 if (last[1][c] > last[0][c]) {
    #####: 3450:	if (last[1][c] > last[2][c])
    #####: 3451:	  black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];
        -: 3452:      } else
    #####: 3453:	if (last[1][c] < last[2][c])
    #####: 3454:	  black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];
    #####: 3455:    memmove (last, last+1, 2*sizeof last[0]);
    #####: 3456:    memcpy (last[2], black[row+1], sizeof last[2]);
        -: 3457:  }
    #####: 3458:  FORC3 black[row][c] = (last[0][c] + last[1][c])/2;
    #####: 3459:  FORC3 black[0][c] = (black[1][c] + black[3][c])/2;
        -: 3460:
        -: 3461:  val = 1 - exp(-1/24.0);
    #####: 3462:  memcpy (fsum, black, sizeof fsum);
    #####: 3463:  for (row=1; row < height; row++)
    #####: 3464:    FORC3 fsum[c] += black[row][c] =
    #####: 3465:	(black[row][c] - black[row-1][c])*val + black[row-1][c];
    #####: 3466:  memcpy (last[0], black[height-1], sizeof last[0]);
    #####: 3467:  FORC3 fsum[c] /= height;
    #####: 3468:  for (row = height; row--; )
    #####: 3469:    FORC3 last[0][c] = black[row][c] =
    #####: 3470:	(black[row][c] - fsum[c] - last[0][c])*val + last[0][c];
        -: 3471:
    #####: 3472:  memset (total, 0, sizeof total);
    #####: 3473:  for (row=2; row < height; row+=4)
    #####: 3474:    for (col=2; col < width; col+=4) {
    #####: 3475:      FORC3 total[c] += (short) image[row*width+col][c];
    #####: 3476:      total[3]++;
        -: 3477:    }
    #####: 3478:  for (row=0; row < height; row++)
    #####: 3479:    FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);
        -: 3480:
    #####: 3481:  for (row=0; row < height; row++) {
    #####: 3482:    for (i=0; i < 6; i++)
    #####: 3483:      ((float *)ddft[0])[i] = ((float *)ddft[1])[i] +
    #####: 3484:	row / (height-1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);
    #####: 3485:    pix = image[row*width];
    #####: 3486:    memcpy (prev, pix, sizeof prev);
    #####: 3487:    frow = row / (height-1.0) * (dim[2]-1);
    #####: 3488:    if ((irow = frow) == dim[2]-1) irow--;
    #####: 3489:    frow -= irow;
    #####: 3490:    for (i=0; i < dim[1]; i++)
    #####: 3491:      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +
    #####: 3492:			  sgain[(irow+1)*dim[1]+i][c] *    frow;
    #####: 3493:    for (col=0; col < width; col++) {
    #####: 3494:      FORC3 {
    #####: 3495:	diff = pix[c] - prev[c];
    #####: 3496:	prev[c] = pix[c];
    #####: 3497:	ipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt
    #####: 3498:		- ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)
    #####: 3499:		- black[row][c] );
        -: 3500:      }
    #####: 3501:      FORC3 {
    #####: 3502:	work[0][c] = ipix[c] * ipix[c] >> 14;
    #####: 3503:	work[2][c] = ipix[c] * work[0][c] >> 14;
    #####: 3504:	work[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;
        -: 3505:      }
    #####: 3506:      FORC3 {
    #####: 3507:	for (val=i=0; i < 3; i++)
    #####: 3508:	  for (  j=0; j < 3; j++)
    #####: 3509:	    val += ppm[c][i][j] * work[i][j];
    #####: 3510:	ipix[c] = floor ((ipix[c] + floor(val)) *
    #####: 3511:		( sgrow[col/sgx  ][c] * (sgx - col%sgx) +
    #####: 3512:		  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);
    #####: 3513:	if (ipix[c] > 32000) ipix[c] = 32000;
    #####: 3514:	pix[c] = ipix[c];
        -: 3515:      }
    #####: 3516:      pix += 4;
        -: 3517:    }
        -: 3518:  }
    #####: 3519:  free (black);
    #####: 3520:  free (sgrow);
    #####: 3521:  free (sgain);
        -: 3522:
    #####: 3523:  if ((badpix = (unsigned *) foveon_camf_matrix (dim, "BadPixels"))) {
    #####: 3524:    for (i=0; i < dim[0]; i++) {
    #####: 3525:      col = (badpix[i] >> 8 & 0xfff) - keep[0];
    #####: 3526:      row = (badpix[i] >> 20       ) - keep[1];
    #####: 3527:      if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)
    #####: 3528:	continue;
    #####: 3529:      memset (fsum, 0, sizeof fsum);
    #####: 3530:      for (sum=j=0; j < 8; j++)
    #####: 3531:	if (badpix[i] & (1 << j)) {
    #####: 3532:	  FORC3 fsum[c] += (short)
    #####: 3533:		image[(row+hood[j*2])*width+col+hood[j*2+1]][c];
    #####: 3534:	  sum++;
        -: 3535:	}
    #####: 3536:      if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;
        -: 3537:    }
    #####: 3538:    free (badpix);
        -: 3539:  }
        -: 3540:
        -: 3541:  /* Array for 5x5 Gaussian averaging of red values */
    #####: 3542:  smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);
    #####: 3543:  merror (smrow[6], "foveon_interpolate()");
    #####: 3544:  for (i=0; i < 5; i++)
    #####: 3545:    smrow[i] = smrow[6] + i*width;
        -: 3546:
        -: 3547:  /* Sharpen the reds against these Gaussian averages */
    #####: 3548:  for (smlast=-1, row=2; row < height-2; row++) {
    #####: 3549:    while (smlast < row+2) {
    #####: 3550:      for (i=0; i < 6; i++)
    #####: 3551:	smrow[(i+5) % 6] = smrow[i];
    #####: 3552:      pix = image[++smlast*width+2];
    #####: 3553:      for (col=2; col < width-2; col++) {
    #####: 3554:	smrow[4][col][0] =
    #####: 3555:	  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;
    #####: 3556:	pix += 4;
        -: 3557:      }
        -: 3558:    }
    #####: 3559:    pix = image[row*width+2];
    #####: 3560:    for (col=2; col < width-2; col++) {
    #####: 3561:      smred = ( 6 *  smrow[2][col][0]
    #####: 3562:	      + 4 * (smrow[1][col][0] + smrow[3][col][0])
    #####: 3563:	      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;
    #####: 3564:      if (col == 2)
        -: 3565:	smred_p = smred;
    #####: 3566:      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);
    #####: 3567:      if (i > 32000) i = 32000;
    #####: 3568:      pix[0] = i;
        -: 3569:      smred_p = smred;
    #####: 3570:      pix += 4;
        -: 3571:    }
        -: 3572:  }
        -: 3573:
        -: 3574:  /* Adjust the brighter pixels for better linearity */
        -: 3575:  min = 0xffff;
    #####: 3576:  FORC3 {
    #####: 3577:    i = satlev[c] / div[c];
    #####: 3578:    if (min > i) min = i;
        -: 3579:  }
    #####: 3580:  limit = min * 9 >> 4;
    #####: 3581:  for (pix=image[0]; pix < image[height*width]; pix+=4) {
    #####: 3582:    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)
    #####: 3583:      continue;
        -: 3584:    min = max = pix[0];
    #####: 3585:    for (c=1; c < 3; c++) {
    #####: 3586:      if (min > pix[c]) min = pix[c];
    #####: 3587:      if (max < pix[c]) max = pix[c];
        -: 3588:    }
    #####: 3589:    if (min >= limit*2) {
    #####: 3590:      pix[0] = pix[1] = pix[2] = max;
        -: 3591:    } else {
    #####: 3592:      i = 0x4000 - ((min - limit) << 14) / limit;
    #####: 3593:      i = 0x4000 - (i*i >> 14);
    #####: 3594:      i = i*i >> 14;
    #####: 3595:      FORC3 pix[c] += (max - pix[c]) * i >> 14;
        -: 3596:    }
        -: 3597:  }
        -: 3598:/*
        -: 3599:   Because photons that miss one detector often hit another,
        -: 3600:   the sum R+G+B is much less noisy than the individual colors.
        -: 3601:   So smooth the hues without smoothing the total.
        -: 3602: */
    #####: 3603:  for (smlast=-1, row=2; row < height-2; row++) {
    #####: 3604:    while (smlast < row+2) {
    #####: 3605:      for (i=0; i < 6; i++)
    #####: 3606:	smrow[(i+5) % 6] = smrow[i];
    #####: 3607:      pix = image[++smlast*width+2];
    #####: 3608:      for (col=2; col < width-2; col++) {
    #####: 3609:	FORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;
    #####: 3610:	pix += 4;
        -: 3611:      }
        -: 3612:    }
    #####: 3613:    pix = image[row*width+2];
    #####: 3614:    for (col=2; col < width-2; col++) {
    #####: 3615:      FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -
    #####: 3616:	((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));
    #####: 3617:      sum = (dev[0] + dev[1] + dev[2]) >> 3;
    #####: 3618:      FORC3 pix[c] += dev[c] - sum;
    #####: 3619:      pix += 4;
        -: 3620:    }
        -: 3621:  }
    #####: 3622:  for (smlast=-1, row=2; row < height-2; row++) {
    #####: 3623:    while (smlast < row+2) {
    #####: 3624:      for (i=0; i < 6; i++)
    #####: 3625:	smrow[(i+5) % 6] = smrow[i];
    #####: 3626:      pix = image[++smlast*width+2];
    #####: 3627:      for (col=2; col < width-2; col++) {
    #####: 3628:	FORC3 smrow[4][col][c] =
    #####: 3629:		(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;
    #####: 3630:	pix += 4;
        -: 3631:      }
        -: 3632:    }
    #####: 3633:    pix = image[row*width+2];
    #####: 3634:    for (col=2; col < width-2; col++) {
    #####: 3635:      for (total[3]=375, sum=60, c=0; c < 3; c++) {
    #####: 3636:	for (total[c]=i=0; i < 5; i++)
    #####: 3637:	  total[c] += smrow[i][col][c];
    #####: 3638:	total[3] += total[c];
    #####: 3639:	sum += pix[c];
        -: 3640:      }
    #####: 3641:      if (sum < 0) sum = 0;
    #####: 3642:      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;
    #####: 3643:      FORC3 pix[c] += foveon_apply_curve (curve[6],
    #####: 3644:		((j*total[c] + 0x8000) >> 16) - pix[c]);
    #####: 3645:      pix += 4;
        -: 3646:    }
        -: 3647:  }
        -: 3648:
        -: 3649:  /* Transform the image to a different colorspace */
    #####: 3650:  for (pix=image[0]; pix < image[height*width]; pix+=4) {
    #####: 3651:    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);
    #####: 3652:    sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;
    #####: 3653:    FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);
    #####: 3654:    FORC3 {
    #####: 3655:      for (dsum=i=0; i < 3; i++)
    #####: 3656:	dsum += trans[c][i] * pix[i];
    #####: 3657:      if (dsum < 0)  dsum = 0;
    #####: 3658:      if (dsum > 24000) dsum = 24000;
    #####: 3659:      ipix[c] = dsum + 0.5;
        -: 3660:    }
    #####: 3661:    FORC3 pix[c] = ipix[c];
        -: 3662:  }
        -: 3663:
        -: 3664:  /* Smooth the image bottom-to-top and save at 1/4 scale */
    #####: 3665:  shrink = (short (*)[3]) calloc ((height/4), (width/4)*sizeof *shrink);
    #####: 3666:  merror (shrink, "foveon_interpolate()");
    #####: 3667:  for (row = height/4; row--; )
    #####: 3668:    for (col=0; col < width/4; col++) {
    #####: 3669:      ipix[0] = ipix[1] = ipix[2] = 0;
    #####: 3670:      for (i=0; i < 4; i++)
    #####: 3671:	for (j=0; j < 4; j++)
    #####: 3672:	  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];
    #####: 3673:      FORC3
    #####: 3674:	if (row+2 > height/4)
    #####: 3675:	  shrink[row*(width/4)+col][c] = ipix[c] >> 4;
        -: 3676:	else
    #####: 3677:	  shrink[row*(width/4)+col][c] =
    #####: 3678:	    (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;
        -: 3679:    }
        -: 3680:  /* From the 1/4-scale image, smooth right-to-left */
    #####: 3681:  for (row=0; row < (height & ~3); row++) {
    #####: 3682:    ipix[0] = ipix[1] = ipix[2] = 0;
    #####: 3683:    if ((row & 3) == 0)
    #####: 3684:      for (col = width & ~3 ; col--; )
    #####: 3685:	FORC3 smrow[0][col][c] = ipix[c] =
    #####: 3686:	  (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;
        -: 3687:
        -: 3688:  /* Then smooth left-to-right */
    #####: 3689:    ipix[0] = ipix[1] = ipix[2] = 0;
    #####: 3690:    for (col=0; col < (width & ~3); col++)
    #####: 3691:      FORC3 smrow[1][col][c] = ipix[c] =
    #####: 3692:	(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;
        -: 3693:
        -: 3694:  /* Smooth top-to-bottom */
    #####: 3695:    if (row == 0)
    #####: 3696:      memcpy (smrow[2], smrow[1], sizeof **smrow * width);
        -: 3697:    else
    #####: 3698:      for (col=0; col < (width & ~3); col++)
    #####: 3699:	FORC3 smrow[2][col][c] =
    #####: 3700:	  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;
        -: 3701:
        -: 3702:  /* Adjust the chroma toward the smooth values */
    #####: 3703:    for (col=0; col < (width & ~3); col++) {
    #####: 3704:      for (i=j=30, c=0; c < 3; c++) {
    #####: 3705:	i += smrow[2][col][c];
    #####: 3706:	j += image[row*width+col][c];
        -: 3707:      }
    #####: 3708:      j = (j << 16) / i;
    #####: 3709:      for (sum=c=0; c < 3; c++) {
    #####: 3710:	ipix[c] = foveon_apply_curve (curve[c+3],
    #####: 3711:	  ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);
    #####: 3712:	sum += ipix[c];
        -: 3713:      }
    #####: 3714:      sum >>= 3;
    #####: 3715:      FORC3 {
    #####: 3716:	i = image[row*width+col][c] + ipix[c] - sum;
    #####: 3717:	if (i < 0) i = 0;
    #####: 3718:	image[row*width+col][c] = i;
        -: 3719:      }
        -: 3720:    }
        -: 3721:  }
    #####: 3722:  free (shrink);
    #####: 3723:  free (smrow[6]);
    #####: 3724:  for (i=0; i < 8; i++)
    #####: 3725:    free (curve[i]);
        -: 3726:
        -: 3727:  /* Trim off the black border */
    #####: 3728:  active[1] -= keep[1];
    #####: 3729:  active[3] -= 2;
    #####: 3730:  i = active[2] - active[0];
    #####: 3731:  for (row=0; row < active[3]-active[1]; row++)
    #####: 3732:    memcpy (image[row*i], image[(row+active[1])*width+active[0]],
        -: 3733:	 i * sizeof *image);
    #####: 3734:  width = i;
    #####: 3735:  height = row;
        -: 3736:}
        -: 3737:#undef image
        -: 3738:
        -: 3739:/* RESTRICTED code ends here */
        -: 3740:
        1: 3741:void CLASS crop_masked_pixels()
        -: 3742:{
        -: 3743:  int row, col;
        -: 3744:  unsigned r, c, m, mblack[8], zero, val;
        -: 3745:
        1: 3746:  if (load_raw == &CLASS phase_one_load_raw ||
        -: 3747:      load_raw == &CLASS phase_one_load_raw_c)
    #####: 3748:    phase_one_correct();
        1: 3749:  if (fuji_width) {
    #####: 3750:    for (row=0; row < raw_height-top_margin*2; row++) {
    #####: 3751:      for (col=0; col < fuji_width << !fuji_layout; col++) {
    #####: 3752:	if (fuji_layout) {
    #####: 3753:	  r = fuji_width - 1 - col + (row >> 1);
    #####: 3754:	  c = col + ((row+1) >> 1);
        -: 3755:	} else {
    #####: 3756:	  r = fuji_width - 1 + row - (col >> 1);
    #####: 3757:	  c = row + ((col+1) >> 1);
        -: 3758:	}
    #####: 3759:	if (r < height && c < width)
    #####: 3760:	  BAYER(r,c) = RAW(row+top_margin,col+left_margin);
        -: 3761:      }
        -: 3762:    }
        -: 3763:  } else {
     3482: 3764:    for (row=0; row < height; row++)
 18169076: 3765:      for (col=0; col < width; col++)
 18169076: 3766:	BAYER2(row,col) = RAW(row+top_margin,col+left_margin);
        -: 3767:  }
        1: 3768:  if (mask[0][3] > 0) goto mask_set;
        1: 3769:  if (load_raw == &CLASS canon_load_raw ||
        -: 3770:      load_raw == &CLASS lossless_jpeg_load_raw) {
        1: 3771:    mask[0][1] = mask[1][1] += 2;
        1: 3772:    mask[0][3] -= 2;
        1: 3773:    goto sides;
        -: 3774:  }
    #####: 3775:  if (load_raw == &CLASS canon_600_load_raw ||
    #####: 3776:      load_raw == &CLASS sony_load_raw ||
    #####: 3777:     (load_raw == &CLASS eight_bit_load_raw && strncmp(model,"DC2",3)) ||
    #####: 3778:      load_raw == &CLASS kodak_262_load_raw ||
    #####: 3779:     (load_raw == &CLASS packed_load_raw && (load_flags & 32))) {
    #####: 3780:sides:
        1: 3781:    mask[0][0] = mask[1][0] = top_margin;
        1: 3782:    mask[0][2] = mask[1][2] = top_margin+height;
        1: 3783:    mask[0][3] += left_margin;
        1: 3784:    mask[1][1] += left_margin+width;
        1: 3785:    mask[1][3] += raw_width;
        -: 3786:  }
        1: 3787:  if (load_raw == &CLASS nokia_load_raw) {
    #####: 3788:    mask[0][2] = top_margin;
    #####: 3789:    mask[0][3] = width;
        -: 3790:  }
        2: 3791:mask_set:
        1: 3792:  memset (mblack, 0, sizeof mblack);
        9: 3793:  for (zero=m=0; m < 8; m++)
     6972: 3794:    for (row=MAX(mask[m][0],0); row < MIN(mask[m][2],raw_height); row++)
   431768: 3795:      for (col=MAX(mask[m][1],0); col < MIN(mask[m][3],raw_width); col++) {
   424804: 3796:	c = FC(row-top_margin,col-left_margin);
   424804: 3797:	mblack[c] += val = RAW(row,col);
   424804: 3798:	mblack[4+c]++;
   424804: 3799:	zero += !val;
        -: 3800:      }
        1: 3801:  if (load_raw == &CLASS canon_600_load_raw && width < raw_width) {
    #####: 3802:    black = (mblack[0]+mblack[1]+mblack[2]+mblack[3]) /
    #####: 3803:	    (mblack[4]+mblack[5]+mblack[6]+mblack[7]) - 4;
    #####: 3804:    canon_600_correct();
        1: 3805:  } else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7]) {
        4: 3806:    FORC4 cblack[c] = mblack[c] / mblack[4+c];
        1: 3807:    cblack[4] = cblack[5] = cblack[6] = 0;
        -: 3808:  }
        1: 3809:}
        -: 3810:
    #####: 3811:void CLASS remove_zeroes()
        -: 3812:{
        -: 3813:  unsigned row, col, tot, n, r, c;
        -: 3814:
    #####: 3815:  for (row=0; row < height; row++)
    #####: 3816:    for (col=0; col < width; col++)
    #####: 3817:      if (BAYER(row,col) == 0) {
        -: 3818:	tot = n = 0;
    #####: 3819:	for (r = row-2; r <= row+2; r++)
    #####: 3820:	  for (c = col-2; c <= col+2; c++)
    #####: 3821:	    if (r < height && c < width &&
    #####: 3822:		FC(r,c) == FC(row,col) && BAYER(r,c))
    #####: 3823:	      tot += (n++,BAYER(r,c));
    #####: 3824:	if (n) BAYER(row,col) = tot/n;
        -: 3825:      }
    #####: 3826:}
        -: 3827:
        -: 3828:/*
        -: 3829:   Seach from the current directory up to the root looking for
        -: 3830:   a ".badpixels" file, and fix those pixels now.
        -: 3831: */
        1: 3832:void CLASS bad_pixels (const char *cfname)
        -: 3833:{
        -: 3834:  FILE *fp=0;
        -: 3835:  char *fname, *cp, line[128];
        -: 3836:  int len, time, row, col, r, c, rad, tot, n, fixed=0;
        -: 3837:
        2: 3838:  if (!filters) return;
        1: 3839:  if (cfname)
    #####: 3840:    fp = fopen (cfname, "r");
        -: 3841:  else {
        1: 3842:    for (len=32 ; ; len *= 2) {
        3: 3843:      fname = (char *) malloc (len);
        2: 3844:      if (!fname) return;
        2: 3845:      if (getcwd (fname, len-16)) break;
        1: 3846:      free (fname);
        1: 3847:      if (errno != ERANGE) return;
        -: 3848:    }
        -: 3849:#if defined(WIN32) || defined(DJGPP)
        -: 3850:    if (fname[1] == ':')
        -: 3851:      memmove (fname, fname+2, len-2);
        -: 3852:    for (cp=fname; *cp; cp++)
        -: 3853:      if (*cp == '\\') *cp = '/';
        -: 3854:#endif
        1: 3855:    cp = fname + strlen(fname);
        1: 3856:    if (cp[-1] == '/') cp--;
        5: 3857:    while (*fname == '/') {
        5: 3858:      strcpy (cp, "/.badpixels");
        5: 3859:      if ((fp = fopen (fname, "r"))) break;
        5: 3860:      if (cp == fname) break;
       28: 3861:      while (*--cp != '/');
        -: 3862:    }
        1: 3863:    free (fname);
        -: 3864:  }
        1: 3865:  if (!fp) return;
    #####: 3866:  while (fgets (line, 128, fp)) {
    #####: 3867:    cp = strchr (line, '#');
    #####: 3868:    if (cp) *cp = 0;
    #####: 3869:    if (sscanf (line, "%d %d %d", &col, &row, &time) != 3) continue;
    #####: 3870:    if ((unsigned) col >= width || (unsigned) row >= height) continue;
    #####: 3871:    if (time > timestamp) continue;
    #####: 3872:    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)
    #####: 3873:      for (r = row-rad; r <= row+rad; r++)
    #####: 3874:	for (c = col-rad; c <= col+rad; c++)
    #####: 3875:	  if ((unsigned) r < height && (unsigned) c < width &&
    #####: 3876:		(r != row || c != col) && fcol(r,c) == fcol(row,col)) {
    #####: 3877:	    tot += BAYER2(r,c);
    #####: 3878:	    n++;
        -: 3879:	  }
    #####: 3880:    BAYER2(row,col) = tot/n;
    #####: 3881:    if (verbose) {
    #####: 3882:      if (!fixed++)
    #####: 3883:	fprintf (stderr,_("Fixed dead pixels at:"));
    #####: 3884:      fprintf (stderr, " %d,%d", col, row);
        -: 3885:    }
        -: 3886:  }
    #####: 3887:  if (fixed) fputc ('\n', stderr);
    #####: 3888:  fclose (fp);
        -: 3889:}
        -: 3890:
    #####: 3891:void CLASS subtract (const char *fname)
        -: 3892:{
        -: 3893:  FILE *fp;
    #####: 3894:  int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;
        -: 3895:  ushort *pixel;
        -: 3896:
    #####: 3897:  if (!(fp = fopen (fname, "rb"))) {
    #####: 3898:    perror (fname);  return;
        -: 3899:  }
    #####: 3900:  if (fgetc(fp) != 'P' || fgetc(fp) != '5') error = 1;
    #####: 3901:  while (!error && nd < 3 && (c = fgetc(fp)) != EOF) {
    #####: 3902:    if (c == '#')  comment = 1;
    #####: 3903:    if (c == '\n') comment = 0;
    #####: 3904:    if (comment) continue;
    #####: 3905:    if (isdigit(c)) number = 1;
    #####: 3906:    if (number) {
    #####: 3907:      if (isdigit(c)) dim[nd] = dim[nd]*10 + c -'0';
    #####: 3908:      else if (isspace(c)) {
    #####: 3909:	number = 0;  nd++;
        -: 3910:      } else error = 1;
        -: 3911:    }
        -: 3912:  }
    #####: 3913:  if (error || nd < 3) {
    #####: 3914:    fprintf (stderr,_("%s is not a valid PGM file!\n"), fname);
    #####: 3915:    fclose (fp);  return;
    #####: 3916:  } else if (dim[0] != width || dim[1] != height || dim[2] != 65535) {
    #####: 3917:    fprintf (stderr,_("%s has the wrong dimensions!\n"), fname);
    #####: 3918:    fclose (fp);  return;
        -: 3919:  }
    #####: 3920:  pixel = (ushort *) calloc (width, sizeof *pixel);
    #####: 3921:  merror (pixel, "subtract()");
    #####: 3922:  for (row=0; row < height; row++) {
    #####: 3923:    fread (pixel, 2, width, fp);
    #####: 3924:    for (col=0; col < width; col++)
    #####: 3925:      BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);
        -: 3926:  }
    #####: 3927:  free (pixel);
    #####: 3928:  fclose (fp);
    #####: 3929:  memset (cblack, 0, sizeof cblack);
    #####: 3930:  black = 0;
        -: 3931:}
        -: 3932:
        2: 3933:void CLASS gamma_curve (double pwr, double ts, int mode, int imax)
        -: 3934:{
        -: 3935:  int i;
        2: 3936:  double g[6], bnd[2]={0,0}, r;
        -: 3937:
        -: 3938:  g[0] = pwr;
        -: 3939:  g[1] = ts;
        -: 3940:  g[2] = g[3] = g[4] = 0;
        2: 3941:  bnd[g[1] >= 1] = 1;
        2: 3942:  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {
       96: 3943:    for (i=0; i < 48; i++) {
       96: 3944:      g[2] = (bnd[0] + bnd[1])/2;
       96: 3945:      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];
    #####: 3946:      else	bnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];
        -: 3947:    }
        2: 3948:    g[3] = g[2] / g[1];
        2: 3949:    if (g[0]) g[4] = g[2] * (1/g[0] - 1);
        -: 3950:  }
        4: 3951:  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +
        4: 3952:		(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;
    #####: 3953:  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1
    #####: 3954:		- g[2] - g[3] -	g[2]*g[3]*(log(g[3]) - 1)) - 1;
        2: 3955:  if (!mode--) {
        1: 3956:    memcpy (gamm, g, sizeof gamm);
        1: 3957:    return;
        -: 3958:  }
    65536: 3959:  for (i=0; i < 0x10000; i++) {
    65536: 3960:    curve[i] = 0xffff;
    65536: 3961:    if ((r = (double) i / imax) < 1)
    99072: 3962:      curve[i] = 0x10000 * ( mode
    49536: 3963:	? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))
    #####: 3964:	: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));
        -: 3965:  }
        -: 3966:}
        -: 3967:
        2: 3968:void CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)
        -: 3969:{
        -: 3970:  double work[3][6], num;
        -: 3971:  int i, j, k;
        -: 3972:
        8: 3973:  for (i=0; i < 3; i++) {
       36: 3974:    for (j=0; j < 6; j++)
       36: 3975:      work[i][j] = j == i+3;
       18: 3976:    for (j=0; j < 3; j++)
       54: 3977:      for (k=0; k < size; k++)
       54: 3978:	work[i][j] += in[k][i] * in[k][j];
        -: 3979:  }
        6: 3980:  for (i=0; i < 3; i++) {
        6: 3981:    num = work[i][i];
       42: 3982:    for (j=0; j < 6; j++)
       36: 3983:      work[i][j] /= num;
       18: 3984:    for (k=0; k < 3; k++) {
       18: 3985:      if (k==i) continue;
       12: 3986:      num = work[k][i];
       84: 3987:      for (j=0; j < 6; j++)
       72: 3988:	work[k][j] -= work[i][j] * num;
        -: 3989:    }
        -: 3990:  }
        6: 3991:  for (i=0; i < size; i++)
       18: 3992:    for (j=0; j < 3; j++)
       72: 3993:      for (out[i][j]=k=0; k < 3; k++)
       54: 3994:	out[i][j] += work[j][k+3] * in[i][k];
        2: 3995:}
        -: 3996:
        1: 3997:void CLASS cam_xyz_coeff (float rgb_cam[3][4], double cam_xyz[4][3])
        -: 3998:{
        -: 3999:  double cam_rgb[4][3], inverse[4][3], num;
        -: 4000:  int i, j, k;
        -: 4001:
        4: 4002:  for (i=0; i < colors; i++)		/* Multiply out XYZ colorspace */
        9: 4003:    for (j=0; j < 3; j++)
       36: 4004:      for (cam_rgb[i][j] = k=0; k < 3; k++)
       27: 4005:	cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];
        -: 4006:
        3: 4007:  for (i=0; i < colors; i++) {		/* Normalize cam_rgb so that */
        9: 4008:    for (num=j=0; j < 3; j++)		/* cam_rgb * (1,1,1) is (1,1,1,1) */
        9: 4009:      num += cam_rgb[i][j];
        9: 4010:    for (j=0; j < 3; j++)
        9: 4011:      cam_rgb[i][j] /= num;
        3: 4012:    pre_mul[i] = 1 / num;
        -: 4013:  }
        1: 4014:  pseudoinverse (cam_rgb, inverse, colors);
        4: 4015:  for (i=0; i < 3; i++)
        9: 4016:    for (j=0; j < colors; j++)
        9: 4017:      rgb_cam[i][j] = inverse[j][i];
        1: 4018:}
        -: 4019:
        -: 4020:#ifdef COLORCHECK
        -: 4021:void CLASS colorcheck()
        -: 4022:{
        -: 4023:#define NSQ 24
        -: 4024:// Coordinates of the GretagMacbeth ColorChecker squares
        -: 4025:// width, height, 1st_column, 1st_row
        -: 4026:  int cut[NSQ][4];			// you must set these
        -: 4027:// ColorChecker Chart under 6500-kelvin illumination
        -: 4028:  static const double gmb_xyY[NSQ][3] = {
        -: 4029:    { 0.400, 0.350, 10.1 },		// Dark Skin
        -: 4030:    { 0.377, 0.345, 35.8 },		// Light Skin
        -: 4031:    { 0.247, 0.251, 19.3 },		// Blue Sky
        -: 4032:    { 0.337, 0.422, 13.3 },		// Foliage
        -: 4033:    { 0.265, 0.240, 24.3 },		// Blue Flower
        -: 4034:    { 0.261, 0.343, 43.1 },		// Bluish Green
        -: 4035:    { 0.506, 0.407, 30.1 },		// Orange
        -: 4036:    { 0.211, 0.175, 12.0 },		// Purplish Blue
        -: 4037:    { 0.453, 0.306, 19.8 },		// Moderate Red
        -: 4038:    { 0.285, 0.202, 6.6 },		// Purple
        -: 4039:    { 0.380, 0.489, 44.3 },		// Yellow Green
        -: 4040:    { 0.473, 0.438, 43.1 },		// Orange Yellow
        -: 4041:    { 0.187, 0.129, 6.1 },		// Blue
        -: 4042:    { 0.305, 0.478, 23.4 },		// Green
        -: 4043:    { 0.539, 0.313, 12.0 },		// Red
        -: 4044:    { 0.448, 0.470, 59.1 },		// Yellow
        -: 4045:    { 0.364, 0.233, 19.8 },		// Magenta
        -: 4046:    { 0.196, 0.252, 19.8 },		// Cyan
        -: 4047:    { 0.310, 0.316, 90.0 },		// White
        -: 4048:    { 0.310, 0.316, 59.1 },		// Neutral 8
        -: 4049:    { 0.310, 0.316, 36.2 },		// Neutral 6.5
        -: 4050:    { 0.310, 0.316, 19.8 },		// Neutral 5
        -: 4051:    { 0.310, 0.316, 9.0 },		// Neutral 3.5
        -: 4052:    { 0.310, 0.316, 3.1 } };		// Black
        -: 4053:  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];
        -: 4054:  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;
        -: 4055:  int c, i, j, k, sq, row, col, pass, count[4];
        -: 4056:
        -: 4057:  memset (gmb_cam, 0, sizeof gmb_cam);
        -: 4058:  for (sq=0; sq < NSQ; sq++) {
        -: 4059:    FORCC count[c] = 0;
        -: 4060:    for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)
        -: 4061:      for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {
        -: 4062:	c = FC(row,col);
        -: 4063:	if (c >= colors) c -= 2;
        -: 4064:	gmb_cam[sq][c] += BAYER2(row,col);
        -: 4065:	BAYER2(row,col) = black + (BAYER2(row,col)-black)/2;
        -: 4066:	count[c]++;
        -: 4067:      }
        -: 4068:    FORCC gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - black;
        -: 4069:    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];
        -: 4070:    gmb_xyz[sq][1] = gmb_xyY[sq][2];
        -: 4071:    gmb_xyz[sq][2] = gmb_xyY[sq][2] *
        -: 4072:		(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];
        -: 4073:  }
        -: 4074:  pseudoinverse (gmb_xyz, inverse, NSQ);
        -: 4075:  for (pass=0; pass < 2; pass++) {
        -: 4076:    for (raw_color = i=0; i < colors; i++)
        -: 4077:      for (j=0; j < 3; j++)
        -: 4078:	for (cam_xyz[i][j] = k=0; k < NSQ; k++)
        -: 4079:	  cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];
        -: 4080:    cam_xyz_coeff (rgb_cam, cam_xyz);
        -: 4081:    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];
        -: 4082:    for (sq=0; sq < NSQ; sq++)
        -: 4083:      FORCC gmb_cam[sq][c] *= balance[c];
        -: 4084:  }
        -: 4085:  if (verbose) {
        -: 4086:    printf ("    { \"%s %s\", %d,\n\t{", make, model, black);
        -: 4087:    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);
        -: 4088:    FORCC for (j=0; j < 3; j++)
        -: 4089:      printf ("%c%d", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));
        -: 4090:    puts (" } },");
        -: 4091:  }
        -: 4092:#undef NSQ
        -: 4093:}
        -: 4094:#endif
        -: 4095:
    #####: 4096:void CLASS hat_transform (float *temp, float *base, int st, int size, int sc)
        -: 4097:{
        -: 4098:  int i;
    #####: 4099:  for (i=0; i < sc; i++)
    #####: 4100:    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];
    #####: 4101:  for (; i+sc < size; i++)
    #####: 4102:    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];
    #####: 4103:  for (; i < size; i++)
    #####: 4104:    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];
    #####: 4105:}
        -: 4106:
    #####: 4107:void CLASS wavelet_denoise()
        -: 4108:{
        -: 4109:  float *fimg=0, *temp, thold, mul[2], avg, diff;
        -: 4110:  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];
        -: 4111:  ushort *window[4];
        -: 4112:  static const float noise[] =
        -: 4113:  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };
        -: 4114:
    #####: 4115:  if (verbose) fprintf (stderr,_("Wavelet denoising...\n"));
        -: 4116:
    #####: 4117:  while (maximum << scale < 0x10000) scale++;
    #####: 4118:  maximum <<= --scale;
    #####: 4119:  black <<= scale;
    #####: 4120:  FORC4 cblack[c] <<= scale;
    #####: 4121:  if ((size = iheight*iwidth) < 0x15550000)
    #####: 4122:    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);
    #####: 4123:  merror (fimg, "wavelet_denoise()");
    #####: 4124:  temp = fimg + size*3;
    #####: 4125:  if ((nc = colors) == 3 && filters) nc++;
    #####: 4126:  FORC(nc) {			/* denoise R,G1,B,G3 individually */
    #####: 4127:    for (i=0; i < size; i++)
    #####: 4128:      fimg[i] = 256 * sqrt(image[i][c] << scale);
    #####: 4129:    for (hpass=lev=0; lev < 5; lev++) {
    #####: 4130:      lpass = size*((lev & 1)+1);
    #####: 4131:      for (row=0; row < iheight; row++) {
    #####: 4132:	hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);
    #####: 4133:	for (col=0; col < iwidth; col++)
    #####: 4134:	  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;
        -: 4135:      }
    #####: 4136:      for (col=0; col < iwidth; col++) {
    #####: 4137:	hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);
    #####: 4138:	for (row=0; row < iheight; row++)
    #####: 4139:	  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;
        -: 4140:      }
    #####: 4141:      thold = threshold * noise[lev];
    #####: 4142:      for (i=0; i < size; i++) {
    #####: 4143:	fimg[hpass+i] -= fimg[lpass+i];
    #####: 4144:	if	(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;
    #####: 4145:	else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;
    #####: 4146:	else	 fimg[hpass+i] = 0;
    #####: 4147:	if (hpass) fimg[i] += fimg[hpass+i];
        -: 4148:      }
        -: 4149:      hpass = lpass;
        -: 4150:    }
    #####: 4151:    for (i=0; i < size; i++)
    #####: 4152:      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);
        -: 4153:  }
    #####: 4154:  if (filters && colors == 3) {  /* pull G1 and G3 closer together */
    #####: 4155:    for (row=0; row < 2; row++) {
    #####: 4156:      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];
    #####: 4157:      blk[row] = cblack[FC(row,0) | 1];
        -: 4158:    }
    #####: 4159:    for (i=0; i < 4; i++)
    #####: 4160:      window[i] = (ushort *) fimg + width*i;
    #####: 4161:    for (wlast=-1, row=1; row < height-1; row++) {
    #####: 4162:      while (wlast < row+1) {
    #####: 4163:	for (wlast++, i=0; i < 4; i++)
    #####: 4164:	  window[(i+3) & 3] = window[i];
    #####: 4165:	for (col = FC(wlast,1) & 1; col < width; col+=2)
    #####: 4166:	  window[2][col] = BAYER(wlast,col);
        -: 4167:      }
    #####: 4168:      thold = threshold/512;
    #####: 4169:      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {
    #####: 4170:	avg = ( window[0][col-1] + window[0][col+1] +
    #####: 4171:		window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )
    #####: 4172:	      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;
    #####: 4173:	avg = avg < 0 ? 0 : sqrt(avg);
    #####: 4174:	diff = sqrt(BAYER(row,col)) - avg;
    #####: 4175:	if      (diff < -thold) diff += thold;
    #####: 4176:	else if (diff >  thold) diff -= thold;
        -: 4177:	else diff = 0;
    #####: 4178:	BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);
        -: 4179:      }
        -: 4180:    }
        -: 4181:  }
    #####: 4182:  free (fimg);
    #####: 4183:}
        -: 4184:
        1: 4185:void CLASS scale_colors()
        -: 4186:{
        -: 4187:  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];
        -: 4188:  int val, dark, sat;
        -: 4189:  double dsum[8], dmin, dmax;
        -: 4190:  float scale_mul[4], fr, fc;
        -: 4191:  ushort *img=0, *pix;
        -: 4192:
        1: 4193:  if (user_mul[0])
        1: 4194:    memcpy (pre_mul, user_mul, sizeof pre_mul);
        1: 4195:  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {
    #####: 4196:    memset (dsum, 0, sizeof dsum);
    #####: 4197:    bottom = MIN (greybox[1]+greybox[3], height);
    #####: 4198:    right  = MIN (greybox[0]+greybox[2], width);
    #####: 4199:    for (row=greybox[1]; row < bottom; row += 8)
    #####: 4200:      for (col=greybox[0]; col < right; col += 8) {
    #####: 4201:	memset (sum, 0, sizeof sum);
    #####: 4202:	for (y=row; y < row+8 && y < bottom; y++)
    #####: 4203:	  for (x=col; x < col+8 && x < right; x++)
    #####: 4204:	    FORC4 {
    #####: 4205:	      if (filters) {
    #####: 4206:		c = fcol(y,x);
    #####: 4207:		val = BAYER2(y,x);
        -: 4208:	      } else
    #####: 4209:		val = image[y*width+x][c];
    #####: 4210:	      if (val > maximum-25) goto skip_block;
    #####: 4211:	      if ((val -= cblack[c]) < 0) val = 0;
    #####: 4212:	      sum[c] += val;
    #####: 4213:	      sum[c+4]++;
    #####: 4214:	      if (filters) break;
        -: 4215:	    }
    #####: 4216:	FORC(8) dsum[c] += sum[c];
    #####: 4217:skip_block: ;
        -: 4218:      }
    #####: 4219:    FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];
        -: 4220:  }
        1: 4221:  if (use_camera_wb && cam_mul[0] != -1) {
    #####: 4222:    memset (sum, 0, sizeof sum);
    #####: 4223:    for (row=0; row < 8; row++)
    #####: 4224:      for (col=0; col < 8; col++) {
    #####: 4225:	c = FC(row,col);
    #####: 4226:	if ((val = white[row][col] - cblack[c]) > 0)
    #####: 4227:	  sum[c] += val;
    #####: 4228:	sum[c+4]++;
        -: 4229:      }
    #####: 4230:    if (sum[0] && sum[1] && sum[2] && sum[3])
    #####: 4231:      FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];
    #####: 4232:    else if (cam_mul[0] && cam_mul[2])
    #####: 4233:      memcpy (pre_mul, cam_mul, sizeof pre_mul);
        -: 4234:    else
    #####: 4235:      fprintf (stderr,_("%s: Cannot use camera white balance.\n"), ifname);
        -: 4236:  }
        1: 4237:  if (pre_mul[1] == 0) pre_mul[1] = 1;
        1: 4238:  if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;
        1: 4239:  dark = black;
        1: 4240:  sat = maximum;
        1: 4241:  if (threshold) wavelet_denoise();
        1: 4242:  maximum -= black;
        5: 4243:  for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {
        4: 4244:    if (dmin > pre_mul[c])
        -: 4245:	dmin = pre_mul[c];
        4: 4246:    if (dmax < pre_mul[c])
        -: 4247:	dmax = pre_mul[c];
        -: 4248:  }
        1: 4249:  if (!highlight) dmax = dmin;
        1: 4250:  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;
        1: 4251:  if (verbose) {
    #####: 4252:    fprintf (stderr,
        -: 4253:      _("Scaling with darkness %d, saturation %d, and\nmultipliers"), dark, sat);
    #####: 4254:    FORC4 fprintf (stderr, " %f", pre_mul[c]);
    #####: 4255:    fputc ('\n', stderr);
        -: 4256:  }
        1: 4257:  if (filters > 1000 && (cblack[4]+1)/2 == 1 && (cblack[5]+1)/2 == 1) {
    #####: 4258:    FORC4 cblack[FC(c/2,c%2)] +=
    #####: 4259:	cblack[6 + c/2 % cblack[4] * cblack[5] + c%2 % cblack[5]];
    #####: 4260:    cblack[4] = cblack[5] = 0;
        -: 4261:  }
        1: 4262:  size = iheight*iwidth;
 72676305: 4263:  for (i=0; i < size*4; i++) {
 72676304: 4264:    if (!(val = ((ushort *)image)[i])) continue;
 18169076: 4265:    if (cblack[4] && cblack[5])
    #####: 4266:      val -= cblack[6 + i/4 / iwidth % cblack[4] * cblack[5] +
    #####: 4267:			i/4 % iwidth % cblack[5]];
 18169076: 4268:    val -= cblack[i & 3];
 18169076: 4269:    val *= scale_mul[i & 3];
 18169076: 4270:    ((ushort *)image)[i] = CLIP(val);
        -: 4271:  }
        1: 4272:  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {
    #####: 4273:    if (verbose)
    #####: 4274:      fprintf (stderr,_("Correcting chromatic aberration...\n"));
    #####: 4275:    for (c=0; c < 4; c+=2) {
    #####: 4276:      if (aber[c] == 1) continue;
    #####: 4277:      img = (ushort *) malloc (size * sizeof *img);
    #####: 4278:      merror (img, "scale_colors()");
    #####: 4279:      for (i=0; i < size; i++)
    #####: 4280:	img[i] = image[i][c];
    #####: 4281:      for (row=0; row < iheight; row++) {
    #####: 4282:	ur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;
    #####: 4283:	if (ur > iheight-2) continue;
    #####: 4284:	fr -= ur;
    #####: 4285:	for (col=0; col < iwidth; col++) {
    #####: 4286:	  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;
    #####: 4287:	  if (uc > iwidth-2) continue;
    #####: 4288:	  fc -= uc;
    #####: 4289:	  pix = img + ur*iwidth + uc;
    #####: 4290:	  image[row*iwidth+col][c] =
    #####: 4291:	    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +
    #####: 4292:	    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;
        -: 4293:	}
        -: 4294:      }
    #####: 4295:      free(img);
        -: 4296:    }
        -: 4297:  }
        1: 4298:}
        -: 4299:
        1: 4300:void CLASS pre_interpolate()
        -: 4301:{
        -: 4302:  ushort (*img)[4];
        -: 4303:  int row, col, c;
        -: 4304:
        1: 4305:  if (shrink) {
    #####: 4306:    if (half_size) {
    #####: 4307:      height = iheight;
    #####: 4308:      width  = iwidth;
    #####: 4309:      if (filters == 9) {
    #####: 4310:	for (row=0; row < 3; row++)
    #####: 4311:	  for (col=1; col < 4; col++)
    #####: 4312:	    if (!(image[row*width+col][0] | image[row*width+col][2]))
    #####: 4313:	      goto break2;  break2:
    #####: 4314:	for ( ; row < height; row+=3)
    #####: 4315:	  for (col=(col-1)%3+1; col < width-1; col+=3) {
    #####: 4316:	    img = image + row*width+col;
    #####: 4317:	    for (c=0; c < 3; c+=2)
    #####: 4318:	      img[0][c] = (img[-1][c] + img[1][c]) >> 1;
        -: 4319:	  }
        -: 4320:      }
        -: 4321:    } else {
    #####: 4322:      img = (ushort (*)[4]) calloc (height, width*sizeof *img);
    #####: 4323:      merror (img, "pre_interpolate()");
    #####: 4324:      for (row=0; row < height; row++)
    #####: 4325:	for (col=0; col < width; col++) {
    #####: 4326:	  c = fcol(row,col);
    #####: 4327:	  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];
        -: 4328:	}
    #####: 4329:      free (image);
    #####: 4330:      image = img;
    #####: 4331:      shrink = 0;
        -: 4332:    }
        -: 4333:  }
        1: 4334:  if (filters > 1000 && colors == 3) {
        1: 4335:    mix_green = four_color_rgb ^ half_size;
        1: 4336:    if (four_color_rgb | half_size) colors++;
        -: 4337:    else {
     1742: 4338:      for (row = FC(1,0) >> 1; row < height; row+=2)
  4544010: 4339:	for (col = FC(row,1) & 1; col < width; col+=2)
  4542269: 4340:	  image[row*width+col][1] = image[row*width+col][3];
        1: 4341:      filters &= ~((filters & 0x55555555) << 1);
        -: 4342:    }
        -: 4343:  }
        1: 4344:  if (half_size) filters = 0;
        1: 4345:}
        -: 4346:
        1: 4347:void CLASS border_interpolate (int border)
        -: 4348:{
        -: 4349:  unsigned row, col, y, x, f, c, sum[8];
        -: 4350:
     3483: 4351:  for (row=0; row < height; row++)
    17396: 4352:    for (col=0; col < width; col++) {
    17396: 4353:      if (col==border && row >= border && row < height-border)
     3480: 4354:	col = width-border;
    17396: 4355:      memset (sum, 0, sizeof sum);
    69584: 4356:      for (y=row-1; y != row+2; y++)
   208752: 4357:	for (x=col-1; x != col+2; x++)
   156564: 4358:	  if (y < height && x < width) {
   104368: 4359:	    f = fcol(y,x);
   104368: 4360:	    sum[f] += image[y*width+x][f];
   104368: 4361:	    sum[f+4]++;
        -: 4362:	  }
    17396: 4363:      f = fcol(row,col);
    69584: 4364:      FORCC if (c != f && sum[c+4])
    34792: 4365:	image[row*width+col][c] = sum[c] / sum[c+4];
        -: 4366:    }
        1: 4367:}
        -: 4368:
        1: 4369:void CLASS lin_interpolate()
        -: 4370:{
        -: 4371:  int code[16][16][32], size=16, *ip, sum[4];
        -: 4372:  int f, c, i, x, y, row, col, shift, color;
        -: 4373:  ushort *pix;
        -: 4374:
        1: 4375:  if (verbose) fprintf (stderr,_("Bilinear interpolation...\n"));
        1: 4376:  if (filters == 9) size = 6;
        1: 4377:  border_interpolate(1);
       17: 4378:  for (row=0; row < size; row++)
      256: 4379:    for (col=0; col < size; col++) {
      256: 4380:      ip = code[row][col]+1;
      256: 4381:      f = fcol(row,col);
      256: 4382:      memset (sum, 0, sizeof sum);
     1024: 4383:      for (y=-1; y <= 1; y++)
     2304: 4384:	for (x=-1; x <= 1; x++) {
     2304: 4385:	  shift = (y==0) + (x==0);
     2304: 4386:	  color = fcol(row+y,col+x);
     2304: 4387:	  if (color == f) continue;
     1536: 4388:	  *ip++ = (width*y + x)*4 + color;
     1536: 4389:	  *ip++ = shift;
     1536: 4390:	  *ip++ = color;
     1536: 4391:	  sum[color] += 1 << shift;
        -: 4392:	}
      256: 4393:      code[row][col][0] = (ip - code[row][col]) / 3;
     1024: 4394:      FORCC
      768: 4395:	if (c != f) {
      512: 4396:	  *ip++ = c;
      512: 4397:	  *ip++ = 256 / sum[c];
        -: 4398:	}
        -: 4399:    }
     3480: 4400:  for (row=1; row < height-1; row++)
 18151680: 4401:    for (col=1; col < width-1; col++) {
 18151680: 4402:      pix = image[row*width+col];
 18151680: 4403:      ip = code[row % size][col % size];
 18151680: 4404:      memset (sum, 0, sizeof sum);
127061760: 4405:      for (i=*ip++; i--; ip+=3)
108910080: 4406:	sum[ip[2]] += pix[ip[0]] << ip[1];
 54455040: 4407:      for (i=colors; --i; ip+=2)
 36303360: 4408:	pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;
        -: 4409:    }
        1: 4410:}
        -: 4411:
        -: 4412:/*
        -: 4413:   This algorithm is officially called:
        -: 4414:
        -: 4415:   "Interpolation using a Threshold-based variable number of gradients"
        -: 4416:
        -: 4417:   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html
        -: 4418:
        -: 4419:   I've extended the basic idea to work with non-Bayer filter arrays.
        -: 4420:   Gradients are numbered clockwise from NW=0 to W=7.
        -: 4421: */
    #####: 4422:void CLASS vng_interpolate()
        -: 4423:{
        -: 4424:  static const signed char *cp, terms[] = {
        -: 4425:    -2,-2,+0,-1,0,0x01, -2,-2,+0,+0,1,0x01, -2,-1,-1,+0,0,0x01,
        -: 4426:    -2,-1,+0,-1,0,0x02, -2,-1,+0,+0,0,0x03, -2,-1,+0,+1,1,0x01,
        -: 4427:    -2,+0,+0,-1,0,0x06, -2,+0,+0,+0,1,0x02, -2,+0,+0,+1,0,0x03,
        -: 4428:    -2,+1,-1,+0,0,0x04, -2,+1,+0,-1,1,0x04, -2,+1,+0,+0,0,0x06,
        -: 4429:    -2,+1,+0,+1,0,0x02, -2,+2,+0,+0,1,0x04, -2,+2,+0,+1,0,0x04,
        -: 4430:    -1,-2,-1,+0,0,0x80, -1,-2,+0,-1,0,0x01, -1,-2,+1,-1,0,0x01,
        -: 4431:    -1,-2,+1,+0,1,0x01, -1,-1,-1,+1,0,0x88, -1,-1,+1,-2,0,0x40,
        -: 4432:    -1,-1,+1,-1,0,0x22, -1,-1,+1,+0,0,0x33, -1,-1,+1,+1,1,0x11,
        -: 4433:    -1,+0,-1,+2,0,0x08, -1,+0,+0,-1,0,0x44, -1,+0,+0,+1,0,0x11,
        -: 4434:    -1,+0,+1,-2,1,0x40, -1,+0,+1,-1,0,0x66, -1,+0,+1,+0,1,0x22,
        -: 4435:    -1,+0,+1,+1,0,0x33, -1,+0,+1,+2,1,0x10, -1,+1,+1,-1,1,0x44,
        -: 4436:    -1,+1,+1,+0,0,0x66, -1,+1,+1,+1,0,0x22, -1,+1,+1,+2,0,0x10,
        -: 4437:    -1,+2,+0,+1,0,0x04, -1,+2,+1,+0,1,0x04, -1,+2,+1,+1,0,0x04,
        -: 4438:    +0,-2,+0,+0,1,0x80, +0,-1,+0,+1,1,0x88, +0,-1,+1,-2,0,0x40,
        -: 4439:    +0,-1,+1,+0,0,0x11, +0,-1,+2,-2,0,0x40, +0,-1,+2,-1,0,0x20,
        -: 4440:    +0,-1,+2,+0,0,0x30, +0,-1,+2,+1,1,0x10, +0,+0,+0,+2,1,0x08,
        -: 4441:    +0,+0,+2,-2,1,0x40, +0,+0,+2,-1,0,0x60, +0,+0,+2,+0,1,0x20,
        -: 4442:    +0,+0,+2,+1,0,0x30, +0,+0,+2,+2,1,0x10, +0,+1,+1,+0,0,0x44,
        -: 4443:    +0,+1,+1,+2,0,0x10, +0,+1,+2,-1,1,0x40, +0,+1,+2,+0,0,0x60,
        -: 4444:    +0,+1,+2,+1,0,0x20, +0,+1,+2,+2,0,0x10, +1,-2,+1,+0,0,0x80,
        -: 4445:    +1,-1,+1,+1,0,0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,
        -: 4446:    +1,+0,+2,+1,0,0x10
        -: 4447:  }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };
        -: 4448:  ushort (*brow[5])[4], *pix;
        -: 4449:  int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];
        -: 4450:  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;
        -: 4451:  int g, diff, thold, num, c;
        -: 4452:
    #####: 4453:  lin_interpolate();
    #####: 4454:  if (verbose) fprintf (stderr,_("VNG interpolation...\n"));
        -: 4455:
    #####: 4456:  if (filters == 1) prow = pcol = 16;
    #####: 4457:  if (filters == 9) prow = pcol =  6;
    #####: 4458:  ip = (int *) calloc (prow*pcol, 1280);
    #####: 4459:  merror (ip, "vng_interpolate()");
    #####: 4460:  for (row=0; row < prow; row++)		/* Precalculate for VNG */
    #####: 4461:    for (col=0; col < pcol; col++) {
    #####: 4462:      code[row][col] = ip;
    #####: 4463:      for (cp=terms, t=0; t < 64; t++) {
    #####: 4464:	y1 = *cp++;  x1 = *cp++;
    #####: 4465:	y2 = *cp++;  x2 = *cp++;
    #####: 4466:	weight = *cp++;
    #####: 4467:	grads = *cp++;
    #####: 4468:	color = fcol(row+y1,col+x1);
    #####: 4469:	if (fcol(row+y2,col+x2) != color) continue;
    #####: 4470:	diag = (fcol(row,col+1) == color && fcol(row+1,col) == color) ? 2:1;
    #####: 4471:	if (abs(y1-y2) == diag && abs(x1-x2) == diag) continue;
    #####: 4472:	*ip++ = (y1*width + x1)*4 + color;
    #####: 4473:	*ip++ = (y2*width + x2)*4 + color;
    #####: 4474:	*ip++ = weight;
    #####: 4475:	for (g=0; g < 8; g++)
    #####: 4476:	  if (grads & 1<<g) *ip++ = g;
    #####: 4477:	*ip++ = -1;
        -: 4478:      }
    #####: 4479:      *ip++ = INT_MAX;
    #####: 4480:      for (cp=chood, g=0; g < 8; g++) {
    #####: 4481:	y = *cp++;  x = *cp++;
    #####: 4482:	*ip++ = (y*width + x) * 4;
    #####: 4483:	color = fcol(row,col);
    #####: 4484:	if (fcol(row+y,col+x) != color && fcol(row+y*2,col+x*2) == color)
    #####: 4485:	  *ip++ = (y*width + x) * 8 + color;
        -: 4486:	else
    #####: 4487:	  *ip++ = 0;
        -: 4488:      }
        -: 4489:    }
    #####: 4490:  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);
    #####: 4491:  merror (brow[4], "vng_interpolate()");
    #####: 4492:  for (row=0; row < 3; row++)
    #####: 4493:    brow[row] = brow[4] + row*width;
    #####: 4494:  for (row=2; row < height-2; row++) {		/* Do VNG interpolation */
    #####: 4495:    for (col=2; col < width-2; col++) {
    #####: 4496:      pix = image[row*width+col];
    #####: 4497:      ip = code[row % prow][col % pcol];
    #####: 4498:      memset (gval, 0, sizeof gval);
    #####: 4499:      while ((g = ip[0]) != INT_MAX) {		/* Calculate gradients */
    #####: 4500:	diff = ABS(pix[g] - pix[ip[1]]) << ip[2];
    #####: 4501:	gval[ip[3]] += diff;
    #####: 4502:	ip += 5;
    #####: 4503:	if ((g = ip[-1]) == -1) continue;
    #####: 4504:	gval[g] += diff;
    #####: 4505:	while ((g = *ip++) != -1)
    #####: 4506:	  gval[g] += diff;
        -: 4507:      }
    #####: 4508:      ip++;
    #####: 4509:      gmin = gmax = gval[0];			/* Choose a threshold */
    #####: 4510:      for (g=1; g < 8; g++) {
    #####: 4511:	if (gmin > gval[g]) gmin = gval[g];
    #####: 4512:	if (gmax < gval[g]) gmax = gval[g];
        -: 4513:      }
    #####: 4514:      if (gmax == 0) {
    #####: 4515:	memcpy (brow[2][col], pix, sizeof *image);
    #####: 4516:	continue;
        -: 4517:      }
    #####: 4518:      thold = gmin + (gmax >> 1);
    #####: 4519:      memset (sum, 0, sizeof sum);
    #####: 4520:      color = fcol(row,col);
    #####: 4521:      for (num=g=0; g < 8; g++,ip+=2) {		/* Average the neighbors */
    #####: 4522:	if (gval[g] <= thold) {
    #####: 4523:	  FORCC
    #####: 4524:	    if (c == color && ip[1])
    #####: 4525:	      sum[c] += (pix[c] + pix[ip[1]]) >> 1;
        -: 4526:	    else
    #####: 4527:	      sum[c] += pix[ip[0] + c];
    #####: 4528:	  num++;
        -: 4529:	}
        -: 4530:      }
    #####: 4531:      FORCC {					/* Save to buffer */
    #####: 4532:	t = pix[color];
    #####: 4533:	if (c != color)
    #####: 4534:	  t += (sum[c] - sum[color]) / num;
    #####: 4535:	brow[2][col][c] = CLIP(t);
        -: 4536:      }
        -: 4537:    }
    #####: 4538:    if (row > 3)				/* Write buffer to image */
    #####: 4539:      memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);
    #####: 4540:    for (g=0; g < 4; g++)
    #####: 4541:      brow[(g-1) & 3] = brow[g];
        -: 4542:  }
    #####: 4543:  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);
    #####: 4544:  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);
    #####: 4545:  free (brow[4]);
    #####: 4546:  free (code[0][0]);
    #####: 4547:}
        -: 4548:
        -: 4549:/*
        -: 4550:   Patterned Pixel Grouping Interpolation by Alain Desbiolles
        -: 4551:*/
    #####: 4552:void CLASS ppg_interpolate()
        -: 4553:{
    #####: 4554:  int dir[5] = { 1, width, -1, -width, 1 };
        -: 4555:  int row, col, diff[2], guess[2], c, d, i;
        -: 4556:  ushort (*pix)[4];
        -: 4557:
    #####: 4558:  border_interpolate(3);
    #####: 4559:  if (verbose) fprintf (stderr,_("PPG interpolation...\n"));
        -: 4560:
        -: 4561:/*  Fill in the green layer with gradients and pattern recognition: */
    #####: 4562:  for (row=3; row < height-3; row++)
    #####: 4563:    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {
    #####: 4564:      pix = image + row*width+col;
    #####: 4565:      for (i=0; (d=dir[i]) > 0; i++) {
    #####: 4566:	guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2
    #####: 4567:		      - pix[-2*d][c] - pix[2*d][c];
    #####: 4568:	diff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +
    #####: 4569:		    ABS(pix[ 2*d][c] - pix[ 0][c]) +
    #####: 4570:		    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +
    #####: 4571:		  ( ABS(pix[ 3*d][1] - pix[ d][1]) +
    #####: 4572:		    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;
        -: 4573:      }
    #####: 4574:      d = dir[i = diff[0] > diff[1]];
    #####: 4575:      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);
        -: 4576:    }
        -: 4577:/*  Calculate red and blue for each green pixel:		*/
    #####: 4578:  for (row=1; row < height-1; row++)
    #####: 4579:    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {
    #####: 4580:      pix = image + row*width+col;
    #####: 4581:      for (i=0; (d=dir[i]) > 0; c=2-c, i++)
    #####: 4582:	pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]
        -: 4583:			- pix[-d][1] - pix[d][1]) >> 1);
        -: 4584:    }
        -: 4585:/*  Calculate blue for red pixels and vice versa:		*/
    #####: 4586:  for (row=1; row < height-1; row++)
    #####: 4587:    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {
    #####: 4588:      pix = image + row*width+col;
    #####: 4589:      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {
    #####: 4590:	diff[i] = ABS(pix[-d][c] - pix[d][c]) +
    #####: 4591:		  ABS(pix[-d][1] - pix[0][1]) +
    #####: 4592:		  ABS(pix[ d][1] - pix[0][1]);
    #####: 4593:	guess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]
    #####: 4594:		 - pix[-d][1] - pix[d][1];
        -: 4595:      }
    #####: 4596:      if (diff[0] != diff[1])
    #####: 4597:	pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);
        -: 4598:      else
    #####: 4599:	pix[0][c] = CLIP((guess[0]+guess[1]) >> 2);
        -: 4600:    }
    #####: 4601:}
        -: 4602:
    #####: 4603:void CLASS cielab (ushort rgb[3], short lab[3])
        -: 4604:{
        -: 4605:  int c, i, j, k;
        -: 4606:  float r, xyz[3];
        -: 4607:  static float cbrt[0x10000], xyz_cam[3][4];
        -: 4608:
    #####: 4609:  if (!rgb) {
    #####: 4610:    for (i=0; i < 0x10000; i++) {
    #####: 4611:      r = i / 65535.0;
    #####: 4612:      cbrt[i] = r > 0.008856 ? pow(r,1/3.0) : 7.787*r + 16/116.0;
        -: 4613:    }
    #####: 4614:    for (i=0; i < 3; i++)
    #####: 4615:      for (j=0; j < colors; j++)
    #####: 4616:	for (xyz_cam[i][j] = k=0; k < 3; k++)
    #####: 4617:	  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];
        -: 4618:    return;
        -: 4619:  }
        -: 4620:  xyz[0] = xyz[1] = xyz[2] = 0.5;
    #####: 4621:  FORCC {
    #####: 4622:    xyz[0] += xyz_cam[0][c] * rgb[c];
    #####: 4623:    xyz[1] += xyz_cam[1][c] * rgb[c];
    #####: 4624:    xyz[2] += xyz_cam[2][c] * rgb[c];
        -: 4625:  }
    #####: 4626:  xyz[0] = cbrt[CLIP((int) xyz[0])];
    #####: 4627:  xyz[1] = cbrt[CLIP((int) xyz[1])];
    #####: 4628:  xyz[2] = cbrt[CLIP((int) xyz[2])];
    #####: 4629:  lab[0] = 64 * (116 * xyz[1] - 16);
    #####: 4630:  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);
    #####: 4631:  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);
        -: 4632:}
        -: 4633:
        -: 4634:#define TS 512		/* Tile Size */
        -: 4635:#define fcol(row,col) xtrans[(row+6) % 6][(col+6) % 6]
        -: 4636:
        -: 4637:/*
        -: 4638:   Frank Markesteijn's algorithm for Fuji X-Trans sensors
        -: 4639: */
    #####: 4640:void CLASS xtrans_interpolate (int passes)
        -: 4641:{
        -: 4642:  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;
        -: 4643:  int val, ndir, pass, hm[8], avg[4], color[3][8];
        -: 4644:  static const short orth[12] = { 1,0,0,1,-1,0,0,-1,1,0,0,1 },
        -: 4645:	patt[2][16] = { { 0,1,0,-1,2,0,-1,0,1,1,1,-1,0,0,0,0 },
        -: 4646:			{ 0,1,0,-2,1,0,-2,0,1,1,-2,-2,1,-1,-1,1 } },
        -: 4647:	dir[4] = { 1,TS,TS+1,TS-1 };
        -: 4648:  short allhex[3][3][2][8], *hex;
        -: 4649:  ushort min, max, sgrow, sgcol;
        -: 4650:  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];
        -: 4651:   short (*lab)    [TS][3], (*lix)[3];
        -: 4652:   float (*drv)[TS][TS], diff[6], tr;
        -: 4653:   char (*homo)[TS][TS], *buffer;
        -: 4654:
    #####: 4655:  if (verbose)
    #####: 4656:    fprintf (stderr,_("%d-pass X-Trans interpolation...\n"), passes);
        -: 4657:
    #####: 4658:  cielab (0,0);
    #####: 4659:  ndir = 4 << (passes > 1);
    #####: 4660:  buffer = (char *) malloc (TS*TS*(ndir*11+6));
    #####: 4661:  merror (buffer, "xtrans_interpolate()");
        -: 4662:  rgb  = (ushort(*)[TS][TS][3]) buffer;
    #####: 4663:  lab  = (short (*)    [TS][3])(buffer + TS*TS*(ndir*6));
    #####: 4664:  drv  = (float (*)[TS][TS])   (buffer + TS*TS*(ndir*6+6));
    #####: 4665:  homo = (char  (*)[TS][TS])   (buffer + TS*TS*(ndir*10+6));
        -: 4666:
        -: 4667:/* Map a green hexagon around each non-green pixel and vice versa:	*/
    #####: 4668:  for (row=0; row < 3; row++)
    #####: 4669:    for (col=0; col < 3; col++)
    #####: 4670:      for (ng=d=0; d < 10; d+=2) {
    #####: 4671:	g = fcol(row,col) == 1;
    #####: 4672:	if (fcol(row+orth[d],col+orth[d+2]) == 1) ng=0; else ng++;
    #####: 4673:	if (ng == 4) { sgrow = row; sgcol = col; }
    #####: 4674:	if (ng == g+1) FORC(8) {
    #####: 4675:	  v = orth[d  ]*patt[g][c*2] + orth[d+1]*patt[g][c*2+1];
    #####: 4676:	  h = orth[d+2]*patt[g][c*2] + orth[d+3]*patt[g][c*2+1];
    #####: 4677:	  allhex[row][col][0][c^(g*2 & d)] = h + v*width;
    #####: 4678:	  allhex[row][col][1][c^(g*2 & d)] = h + v*TS;
        -: 4679:	}
        -: 4680:      }
        -: 4681:
        -: 4682:/* Set green1 and green3 to the minimum and maximum allowed values:	*/
    #####: 4683:  for (row=2; row < height-2; row++)
    #####: 4684:    for (min=~(max=0), col=2; col < width-2; col++) {
    #####: 4685:      if (fcol(row,col) == 1 && (min=~(max=0))) continue;
    #####: 4686:      pix = image + row*width + col;
    #####: 4687:      hex = allhex[row % 3][col % 3][0];
    #####: 4688:      if (!max) FORC(6) {
    #####: 4689:	val = pix[hex[c]][1];
    #####: 4690:	if (min > val) min = val;
    #####: 4691:	if (max < val) max = val;
        -: 4692:      }
    #####: 4693:      pix[0][1] = min;
    #####: 4694:      pix[0][3] = max;
    #####: 4695:      switch ((row-sgrow) % 3) {
    #####: 4696:	case 1: if (row < height-3) { row++; col--; } break;
    #####: 4697:	case 2: if ((min=~(max=0)) && (col+=2) < width-3 && row > 2) row--;
        -: 4698:      }
        -: 4699:    }
        -: 4700:
    #####: 4701:  for (top=3; top < height-19; top += TS-16)
    #####: 4702:    for (left=3; left < width-19; left += TS-16) {
    #####: 4703:      mrow = MIN (top+TS, height-3);
    #####: 4704:      mcol = MIN (left+TS, width-3);
    #####: 4705:      for (row=top; row < mrow; row++)
    #####: 4706:	for (col=left; col < mcol; col++)
    #####: 4707:	  memcpy (rgb[0][row-top][col-left], image[row*width+col], 6);
    #####: 4708:      FORC3 memcpy (rgb[c+1], rgb[0], sizeof *rgb);
        -: 4709:
        -: 4710:/* Interpolate green horizontally, vertically, and along both diagonals: */
    #####: 4711:      for (row=top; row < mrow; row++)
    #####: 4712:	for (col=left; col < mcol; col++) {
    #####: 4713:	  if ((f = fcol(row,col)) == 1) continue;
    #####: 4714:	  pix = image + row*width + col;
    #####: 4715:	  hex = allhex[row % 3][col % 3][0];
    #####: 4716:	  color[1][0] = 174 * (pix[  hex[1]][1] + pix[  hex[0]][1]) -
    #####: 4717:			 46 * (pix[2*hex[1]][1] + pix[2*hex[0]][1]);
    #####: 4718:	  color[1][1] = 223 *  pix[  hex[3]][1] + pix[  hex[2]][1] * 33 +
    #####: 4719:			 92 * (pix[      0 ][f] - pix[ -hex[2]][f]);
    #####: 4720:	  FORC(2) color[1][2+c] =
    #####: 4721:		164 * pix[hex[4+c]][1] + 92 * pix[-2*hex[4+c]][1] + 33 *
    #####: 4722:		(2*pix[0][f] - pix[3*hex[4+c]][f] - pix[-3*hex[4+c]][f]);
    #####: 4723:	  FORC4 rgb[c^!((row-sgrow) % 3)][row-top][col-left][1] =
    #####: 4724:		LIM(color[1][c] >> 8,pix[0][1],pix[0][3]);
        -: 4725:	}
        -: 4726:
    #####: 4727:      for (pass=0; pass < passes; pass++) {
    #####: 4728:	if (pass == 1)
    #####: 4729:	  memcpy (rgb+=4, buffer, 4*sizeof *rgb);
        -: 4730:
        -: 4731:/* Recalculate green from interpolated values of closer pixels:	*/
    #####: 4732:	if (pass) {
    #####: 4733:	  for (row=top+2; row < mrow-2; row++)
    #####: 4734:	    for (col=left+2; col < mcol-2; col++) {
    #####: 4735:	      if ((f = fcol(row,col)) == 1) continue;
    #####: 4736:	      pix = image + row*width + col;
    #####: 4737:	      hex = allhex[row % 3][col % 3][1];
    #####: 4738:	      for (d=3; d < 6; d++) {
    #####: 4739:		rix = &rgb[(d-2)^!((row-sgrow) % 3)][row-top][col-left];
    #####: 4740:		val = rix[-2*hex[d]][1] + 2*rix[hex[d]][1]
    #####: 4741:		    - rix[-2*hex[d]][f] - 2*rix[hex[d]][f] + 3*rix[0][f];
    #####: 4742:		rix[0][1] = LIM(val/3,pix[0][1],pix[0][3]);
        -: 4743:	      }
        -: 4744:	    }
        -: 4745:	}
        -: 4746:
        -: 4747:/* Interpolate red and blue values for solitary green pixels:	*/
    #####: 4748:	for (row=(top-sgrow+4)/3*3+sgrow; row < mrow-2; row+=3)
    #####: 4749:	  for (col=(left-sgcol+4)/3*3+sgcol; col < mcol-2; col+=3) {
    #####: 4750:	    rix = &rgb[0][row-top][col-left];
    #####: 4751:	    h = fcol(row,col+1);
    #####: 4752:	    memset (diff, 0, sizeof diff);
    #####: 4753:	    for (i=1, d=0; d < 6; d++, i^=TS^1, h^=2) {
    #####: 4754:	      for (c=0; c < 2; c++, h^=2) {
    #####: 4755:		g = 2*rix[0][1] - rix[i<<c][1] - rix[-i<<c][1];
    #####: 4756:		color[h][d] = g + rix[i<<c][h] + rix[-i<<c][h];
    #####: 4757:		if (d > 1)
    #####: 4758:		  diff[d] += SQR (rix[i<<c][1] - rix[-i<<c][1]
    #####: 4759:				- rix[i<<c][h] + rix[-i<<c][h]) + SQR(g);
        -: 4760:	      }
    #####: 4761:	      if (d > 1 && (d & 1))
    #####: 4762:		if (diff[d-1] < diff[d])
    #####: 4763:		  FORC(2) color[c*2][d] = color[c*2][d-1];
    #####: 4764:	      if (d < 2 || (d & 1)) {
    #####: 4765:		FORC(2) rix[0][c*2] = CLIP(color[c*2][d]/2);
    #####: 4766:		rix += TS*TS;
        -: 4767:	      }
        -: 4768:	    }
        -: 4769:	  }
        -: 4770:
        -: 4771:/* Interpolate red for blue pixels and vice versa:		*/
    #####: 4772:	for (row=top+3; row < mrow-3; row++)
    #####: 4773:	  for (col=left+3; col < mcol-3; col++) {
    #####: 4774:	    if ((f = 2-fcol(row,col)) == 1) continue;
    #####: 4775:	    rix = &rgb[0][row-top][col-left];
    #####: 4776:	    c = (row-sgrow) % 3 ? TS:1;
    #####: 4777:	    h = 3 * (c ^ TS ^ 1);
    #####: 4778:	    for (d=0; d < 4; d++, rix += TS*TS) {
    #####: 4779:	      i = d > 1 || ((d ^ c) & 1) ||
    #####: 4780:		 ((ABS(rix[0][1]-rix[c][1])+ABS(rix[0][1]-rix[-c][1])) <
    #####: 4781:		2*(ABS(rix[0][1]-rix[h][1])+ABS(rix[0][1]-rix[-h][1]))) ? c:h;
    #####: 4782:	      rix[0][f] = CLIP((rix[i][f] + rix[-i][f] +
        -: 4783:		  2*rix[0][1] - rix[i][1] - rix[-i][1])/2);
        -: 4784:	    }
        -: 4785:	  }
        -: 4786:
        -: 4787:/* Fill in red and blue for 2x2 blocks of green:		*/
    #####: 4788:	for (row=top+2; row < mrow-2; row++) if ((row-sgrow) % 3)
    #####: 4789:	  for (col=left+2; col < mcol-2; col++) if ((col-sgcol) % 3) {
    #####: 4790:	    rix = &rgb[0][row-top][col-left];
    #####: 4791:	    hex = allhex[row % 3][col % 3][1];
    #####: 4792:	    for (d=0; d < ndir; d+=2, rix += TS*TS)
    #####: 4793:	      if (hex[d] + hex[d+1]) {
    #####: 4794:		g = 3*rix[0][1] - 2*rix[hex[d]][1] - rix[hex[d+1]][1];
    #####: 4795:		for (c=0; c < 4; c+=2) rix[0][c] =
    #####: 4796:			CLIP((g + 2*rix[hex[d]][c] + rix[hex[d+1]][c])/3);
        -: 4797:	      } else {
    #####: 4798:		g = 2*rix[0][1] - rix[hex[d]][1] - rix[hex[d+1]][1];
    #####: 4799:		for (c=0; c < 4; c+=2) rix[0][c] =
    #####: 4800:			CLIP((g + rix[hex[d]][c] + rix[hex[d+1]][c])/2);
        -: 4801:	      }
        -: 4802:	  }
        -: 4803:      }
        -: 4804:      rgb = (ushort(*)[TS][TS][3]) buffer;
    #####: 4805:      mrow -= top;
    #####: 4806:      mcol -= left;
        -: 4807:
        -: 4808:/* Convert to CIELab and differentiate in all directions:	*/
    #####: 4809:      for (d=0; d < ndir; d++) {
    #####: 4810:	for (row=2; row < mrow-2; row++)
    #####: 4811:	  for (col=2; col < mcol-2; col++)
    #####: 4812:	    cielab (rgb[d][row][col], lab[row][col]);
    #####: 4813:	for (f=dir[d & 3],row=3; row < mrow-3; row++)
    #####: 4814:	  for (col=3; col < mcol-3; col++) {
    #####: 4815:	    lix = &lab[row][col];
    #####: 4816:	    g = 2*lix[0][0] - lix[f][0] - lix[-f][0];
    #####: 4817:	    drv[d][row][col] = SQR(g)
    #####: 4818:	      + SQR((2*lix[0][1] - lix[f][1] - lix[-f][1] + g*500/232))
    #####: 4819:	      + SQR((2*lix[0][2] - lix[f][2] - lix[-f][2] - g*500/580));
        -: 4820:	  }
        -: 4821:      }
        -: 4822:
        -: 4823:/* Build homogeneity maps from the derivatives:			*/
    #####: 4824:      memset(homo, 0, ndir*TS*TS);
    #####: 4825:      for (row=4; row < mrow-4; row++)
    #####: 4826:	for (col=4; col < mcol-4; col++) {
    #####: 4827:	  for (tr=FLT_MAX, d=0; d < ndir; d++)
    #####: 4828:	    if (tr > drv[d][row][col])
        -: 4829:		tr = drv[d][row][col];
    #####: 4830:	  tr *= 8;
    #####: 4831:	  for (d=0; d < ndir; d++)
    #####: 4832:	    for (v=-1; v <= 1; v++)
    #####: 4833:	      for (h=-1; h <= 1; h++)
    #####: 4834:		if (drv[d][row+v][col+h] <= tr)
    #####: 4835:		  homo[d][row][col]++;
        -: 4836:	}
        -: 4837:
        -: 4838:/* Average the most homogenous pixels for the final result:	*/
    #####: 4839:      if (height-top < TS+4) mrow = height-top+2;
    #####: 4840:      if (width-left < TS+4) mcol = width-left+2;
    #####: 4841:      for (row = MIN(top,8); row < mrow-8; row++)
    #####: 4842:	for (col = MIN(left,8); col < mcol-8; col++) {
    #####: 4843:	  for (d=0; d < ndir; d++)
    #####: 4844:	    for (hm[d]=0, v=-2; v <= 2; v++)
    #####: 4845:	      for (h=-2; h <= 2; h++)
    #####: 4846:		hm[d] += homo[d][row+v][col+h];
    #####: 4847:	  for (d=0; d < ndir-4; d++)
    #####: 4848:	    if (hm[d] < hm[d+4]) hm[d  ] = 0; else
    #####: 4849:	    if (hm[d] > hm[d+4]) hm[d+4] = 0;
    #####: 4850:	  for (max=hm[0],d=1; d < ndir; d++)
    #####: 4851:	    if (max < hm[d]) max = hm[d];
    #####: 4852:	  max -= max >> 3;
    #####: 4853:	  memset (avg, 0, sizeof avg);
    #####: 4854:	  for (d=0; d < ndir; d++)
    #####: 4855:	    if (hm[d] >= max) {
    #####: 4856:	      FORC3 avg[c] += rgb[d][row][col][c];
    #####: 4857:	      avg[3]++;
        -: 4858:	    }
    #####: 4859:	  FORC3 image[(row+top)*width+col+left][c] = avg[c]/avg[3];
        -: 4860:	}
        -: 4861:    }
    #####: 4862:  free(buffer);
    #####: 4863:  border_interpolate(8);
    #####: 4864:}
        -: 4865:#undef fcol
        -: 4866:
        -: 4867:/*
        -: 4868:   Adaptive Homogeneity-Directed interpolation is based on
        -: 4869:   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.
        -: 4870: */
    #####: 4871:void CLASS ahd_interpolate()
        -: 4872:{
        -: 4873:  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];
        -: 4874:  static const int dir[4] = { -1, 1, -TS, TS };
        -: 4875:  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;
        -: 4876:  ushort (*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];
        -: 4877:   short (*lab)[TS][TS][3], (*lix)[3];
        -: 4878:   char (*homo)[TS][TS], *buffer;
        -: 4879:
    #####: 4880:  if (verbose) fprintf (stderr,_("AHD interpolation...\n"));
        -: 4881:
    #####: 4882:  cielab (0,0);
    #####: 4883:  border_interpolate(5);
    #####: 4884:  buffer = (char *) malloc (26*TS*TS);
    #####: 4885:  merror (buffer, "ahd_interpolate()");
        -: 4886:  rgb  = (ushort(*)[TS][TS][3]) buffer;
    #####: 4887:  lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);
    #####: 4888:  homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);
        -: 4889:
    #####: 4890:  for (top=2; top < height-5; top += TS-6)
    #####: 4891:    for (left=2; left < width-5; left += TS-6) {
        -: 4892:
        -: 4893:/*  Interpolate green horizontally and vertically:		*/
    #####: 4894:      for (row=top; row < top+TS && row < height-2; row++) {
    #####: 4895:	col = left + (FC(row,left) & 1);
    #####: 4896:	for (c = FC(row,col); col < left+TS && col < width-2; col+=2) {
    #####: 4897:	  pix = image + row*width+col;
    #####: 4898:	  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2
    #####: 4899:		- pix[-2][c] - pix[2][c]) >> 2;
    #####: 4900:	  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);
    #####: 4901:	  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2
    #####: 4902:		- pix[-2*width][c] - pix[2*width][c]) >> 2;
    #####: 4903:	  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);
        -: 4904:	}
        -: 4905:      }
        -: 4906:/*  Interpolate red and blue, and convert to CIELab:		*/
    #####: 4907:      for (d=0; d < 2; d++)
    #####: 4908:	for (row=top+1; row < top+TS-1 && row < height-3; row++)
    #####: 4909:	  for (col=left+1; col < left+TS-1 && col < width-3; col++) {
    #####: 4910:	    pix = image + row*width+col;
    #####: 4911:	    rix = &rgb[d][row-top][col-left];
    #####: 4912:	    lix = &lab[d][row-top][col-left];
    #####: 4913:	    if ((c = 2 - FC(row,col)) == 1) {
    #####: 4914:	      c = FC(row+1,col);
    #####: 4915:	      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]
    #####: 4916:				 - rix[-1][1] - rix[1][1] ) >> 1);
    #####: 4917:	      rix[0][2-c] = CLIP(val);
    #####: 4918:	      val = pix[0][1] + (( pix[-width][c] + pix[width][c]
    #####: 4919:				 - rix[-TS][1] - rix[TS][1] ) >> 1);
        -: 4920:	    } else
    #####: 4921:	      val = rix[0][1] + (( pix[-width-1][c] + pix[-width+1][c]
    #####: 4922:				 + pix[+width-1][c] + pix[+width+1][c]
    #####: 4923:				 - rix[-TS-1][1] - rix[-TS+1][1]
    #####: 4924:				 - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);
    #####: 4925:	    rix[0][c] = CLIP(val);
    #####: 4926:	    c = FC(row,col);
    #####: 4927:	    rix[0][c] = pix[0][c];
    #####: 4928:	    cielab (rix[0],lix[0]);
        -: 4929:	  }
        -: 4930:/*  Build homogeneity maps from the CIELab images:		*/
    #####: 4931:      memset (homo, 0, 2*TS*TS);
    #####: 4932:      for (row=top+2; row < top+TS-2 && row < height-4; row++) {
    #####: 4933:	tr = row-top;
    #####: 4934:	for (col=left+2; col < left+TS-2 && col < width-4; col++) {
    #####: 4935:	  tc = col-left;
    #####: 4936:	  for (d=0; d < 2; d++) {
    #####: 4937:	    lix = &lab[d][tr][tc];
    #####: 4938:	    for (i=0; i < 4; i++) {
    #####: 4939:	       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);
    #####: 4940:	      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])
    #####: 4941:			   + SQR(lix[0][2]-lix[dir[i]][2]);
        -: 4942:	    }
        -: 4943:	  }
    #####: 4944:	  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),
        -: 4945:		     MAX(ldiff[1][2],ldiff[1][3]));
    #####: 4946:	  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),
        -: 4947:		      MAX(abdiff[1][2],abdiff[1][3]));
    #####: 4948:	  for (d=0; d < 2; d++)
    #####: 4949:	    for (i=0; i < 4; i++)
    #####: 4950:	      if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)
    #####: 4951:		homo[d][tr][tc]++;
        -: 4952:	}
        -: 4953:      }
        -: 4954:/*  Combine the most homogenous pixels for the final result:	*/
    #####: 4955:      for (row=top+3; row < top+TS-3 && row < height-5; row++) {
    #####: 4956:	tr = row-top;
    #####: 4957:	for (col=left+3; col < left+TS-3 && col < width-5; col++) {
    #####: 4958:	  tc = col-left;
    #####: 4959:	  for (d=0; d < 2; d++)
    #####: 4960:	    for (hm[d]=0, i=tr-1; i <= tr+1; i++)
    #####: 4961:	      for (j=tc-1; j <= tc+1; j++)
    #####: 4962:		hm[d] += homo[d][i][j];
    #####: 4963:	  if (hm[0] != hm[1])
    #####: 4964:	    FORC3 image[row*width+col][c] = rgb[hm[1] > hm[0]][tr][tc][c];
        -: 4965:	  else
    #####: 4966:	    FORC3 image[row*width+col][c] =
    #####: 4967:		(rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;
        -: 4968:	}
        -: 4969:      }
        -: 4970:    }
    #####: 4971:  free (buffer);
    #####: 4972:}
        -: 4973:#undef TS
        -: 4974:
        1: 4975:void CLASS median_filter()
        -: 4976:{
        -: 4977:  ushort (*pix)[4];
        -: 4978:  int pass, c, i, j, k, med[9];
        -: 4979:  static const uchar opt[] =	/* Optimal 9-element median search */
        -: 4980:  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,
        -: 4981:    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };
        -: 4982:
        1: 4983:  for (pass=1; pass <= med_passes; pass++) {
    #####: 4984:    if (verbose)
    #####: 4985:      fprintf (stderr,_("Median filter pass %d...\n"), pass);
    #####: 4986:    for (c=0; c < 3; c+=2) {
    #####: 4987:      for (pix = image; pix < image+width*height; pix++)
    #####: 4988:	pix[0][3] = pix[0][c];
    #####: 4989:      for (pix = image+width; pix < image+width*(height-1); pix++) {
    #####: 4990:	if ((pix-image+1) % width < 2) continue;
    #####: 4991:	for (k=0, i = -width; i <= width; i += width)
    #####: 4992:	  for (j = i-1; j <= i+1; j++)
    #####: 4993:	    med[k++] = pix[j][3] - pix[j][1];
    #####: 4994:	for (i=0; i < sizeof opt; i+=2)
    #####: 4995:	  if     (med[opt[i]] > med[opt[i+1]])
    #####: 4996:	    SWAP (med[opt[i]] , med[opt[i+1]]);
    #####: 4997:	pix[0][c] = CLIP(med[4] + pix[0][1]);
        -: 4998:      }
        -: 4999:    }
        -: 5000:  }
        1: 5001:}
        -: 5002:
    #####: 5003:void CLASS blend_highlights()
        -: 5004:{
        -: 5005:  int clip=INT_MAX, row, col, c, i, j;
        -: 5006:  static const float trans[2][4][4] =
        -: 5007:  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },
        -: 5008:    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };
        -: 5009:  static const float itrans[2][4][4] =
        -: 5010:  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },
        -: 5011:    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };
        -: 5012:  float cam[2][4], lab[2][4], sum[2], chratio;
        -: 5013:
    #####: 5014:  if ((unsigned) (colors-3) > 1) return;
    #####: 5015:  if (verbose) fprintf (stderr,_("Blending highlights...\n"));
    #####: 5016:  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;
    #####: 5017:  for (row=0; row < height; row++)
    #####: 5018:    for (col=0; col < width; col++) {
    #####: 5019:      FORCC if (image[row*width+col][c] > clip) break;
    #####: 5020:      if (c == colors) continue;
    #####: 5021:      FORCC {
    #####: 5022:	cam[0][c] = image[row*width+col][c];
    #####: 5023:	cam[1][c] = MIN(cam[0][c],clip);
        -: 5024:      }
    #####: 5025:      for (i=0; i < 2; i++) {
    #####: 5026:	FORCC for (lab[i][c]=j=0; j < colors; j++)
    #####: 5027:	  lab[i][c] += trans[colors-3][c][j] * cam[i][j];
    #####: 5028:	for (sum[i]=0,c=1; c < colors; c++)
    #####: 5029:	  sum[i] += SQR(lab[i][c]);
        -: 5030:      }
    #####: 5031:      chratio = sqrt(sum[1]/sum[0]);
    #####: 5032:      for (c=1; c < colors; c++)
    #####: 5033:	lab[0][c] *= chratio;
    #####: 5034:      FORCC for (cam[0][c]=j=0; j < colors; j++)
    #####: 5035:	cam[0][c] += itrans[colors-3][c][j] * lab[0][j];
    #####: 5036:      FORCC image[row*width+col][c] = cam[0][c] / colors;
        -: 5037:    }
        -: 5038:}
        -: 5039:
        -: 5040:#define SCALE (4 >> shrink)
    #####: 5041:void CLASS recover_highlights()
        -: 5042:{
        -: 5043:  float *map, sum, wgt, grow;
        -: 5044:  int hsat[4], count, spread, change, val, i;
        -: 5045:  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;
        -: 5046:  ushort *pixel;
        -: 5047:  static const signed char dir[8][2] =
        -: 5048:    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };
        -: 5049:
    #####: 5050:  if (verbose) fprintf (stderr,_("Rebuilding highlights...\n"));
        -: 5051:
    #####: 5052:  grow = pow (2, 4-highlight);
    #####: 5053:  FORCC hsat[c] = 32000 * pre_mul[c];
    #####: 5054:  for (kc=0, c=1; c < colors; c++)
    #####: 5055:    if (pre_mul[kc] < pre_mul[c]) kc = c;
    #####: 5056:  high = height / SCALE;
    #####: 5057:  wide =  width / SCALE;
    #####: 5058:  map = (float *) calloc (high, wide*sizeof *map);
    #####: 5059:  merror (map, "recover_highlights()");
    #####: 5060:  FORCC if (c != kc) {
    #####: 5061:    memset (map, 0, high*wide*sizeof *map);
    #####: 5062:    for (mrow=0; mrow < high; mrow++)
    #####: 5063:      for (mcol=0; mcol < wide; mcol++) {
        -: 5064:	sum = wgt = count = 0;
    #####: 5065:	for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)
    #####: 5066:	  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {
    #####: 5067:	    pixel = image[row*width+col];
    #####: 5068:	    if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {
    #####: 5069:	      sum += pixel[c];
    #####: 5070:	      wgt += pixel[kc];
    #####: 5071:	      count++;
        -: 5072:	    }
        -: 5073:	  }
    #####: 5074:	if (count == SCALE*SCALE)
    #####: 5075:	  map[mrow*wide+mcol] = sum / wgt;
        -: 5076:      }
    #####: 5077:    for (spread = 32/grow; spread--; ) {
    #####: 5078:      for (mrow=0; mrow < high; mrow++)
    #####: 5079:	for (mcol=0; mcol < wide; mcol++) {
    #####: 5080:	  if (map[mrow*wide+mcol]) continue;
        -: 5081:	  sum = count = 0;
    #####: 5082:	  for (d=0; d < 8; d++) {
    #####: 5083:	    y = mrow + dir[d][0];
    #####: 5084:	    x = mcol + dir[d][1];
    #####: 5085:	    if (y < high && x < wide && map[y*wide+x] > 0) {
    #####: 5086:	      sum  += (1 + (d & 1)) * map[y*wide+x];
    #####: 5087:	      count += 1 + (d & 1);
        -: 5088:	    }
        -: 5089:	  }
    #####: 5090:	  if (count > 3)
    #####: 5091:	    map[mrow*wide+mcol] = - (sum+grow) / (count+grow);
        -: 5092:	}
    #####: 5093:      for (change=i=0; i < high*wide; i++)
    #####: 5094:	if (map[i] < 0) {
    #####: 5095:	  map[i] = -map[i];
        -: 5096:	  change = 1;
        -: 5097:	}
    #####: 5098:      if (!change) break;
        -: 5099:    }
    #####: 5100:    for (i=0; i < high*wide; i++)
    #####: 5101:      if (map[i] == 0) map[i] = 1;
    #####: 5102:    for (mrow=0; mrow < high; mrow++)
    #####: 5103:      for (mcol=0; mcol < wide; mcol++) {
    #####: 5104:	for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)
    #####: 5105:	  for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {
    #####: 5106:	    pixel = image[row*width+col];
    #####: 5107:	    if (pixel[c] / hsat[c] > 1) {
    #####: 5108:	      val = pixel[kc] * map[mrow*wide+mcol];
    #####: 5109:	      if (pixel[c] < val) pixel[c] = CLIP(val);
        -: 5110:	    }
        -: 5111:	  }
        -: 5112:      }
        -: 5113:  }
    #####: 5114:  free (map);
    #####: 5115:}
        -: 5116:#undef SCALE
        -: 5117:
      120: 5118:void CLASS tiff_get (unsigned base,
        -: 5119:	unsigned *tag, unsigned *type, unsigned *len, unsigned *save)
        -: 5120:{
      120: 5121:  *tag  = get2();
      120: 5122:  *type = get2();
      120: 5123:  *len  = get4();
      120: 5124:  *save = ftell(ifp) + 4;
      120: 5125:  if (*len * ("11124811248484"[*type < 14 ? *type:0]-'0') > 4)
       63: 5126:    fseek (ifp, get4()+base, SEEK_SET);
      120: 5127:}
        -: 5128:
    #####: 5129:void CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)
        -: 5130:{
        -: 5131:  unsigned entries, tag, type, len, save;
        -: 5132:
    #####: 5133:  entries = get2();
    #####: 5134:  while (entries--) {
    #####: 5135:    tiff_get (base, &tag, &type, &len, &save);
    #####: 5136:    if (tag == toff) thumb_offset = get4()+base;
    #####: 5137:    if (tag == tlen) thumb_length = get4();
    #####: 5138:    fseek (ifp, save, SEEK_SET);
        -: 5139:  }
    #####: 5140:}
        -: 5141:
        -: 5142:int CLASS parse_tiff_ifd (int base);
        -: 5143:
        1: 5144:void CLASS parse_makernote (int base, int uptag)
        -: 5145:{
        -: 5146:  static const uchar xlat[2][256] = {
        -: 5147:  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,
        -: 5148:    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,
        -: 5149:    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,
        -: 5150:    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,
        -: 5151:    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,
        -: 5152:    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,
        -: 5153:    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,
        -: 5154:    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,
        -: 5155:    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,
        -: 5156:    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,
        -: 5157:    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,
        -: 5158:    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,
        -: 5159:    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,
        -: 5160:    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,
        -: 5161:    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,
        -: 5162:    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },
        -: 5163:  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,
        -: 5164:    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,
        -: 5165:    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,
        -: 5166:    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,
        -: 5167:    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,
        -: 5168:    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,
        -: 5169:    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,
        -: 5170:    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,
        -: 5171:    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,
        -: 5172:    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,
        -: 5173:    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,
        -: 5174:    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,
        -: 5175:    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,
        -: 5176:    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,
        -: 5177:    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,
        -: 5178:    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };
        -: 5179:  unsigned offset=0, entries, tag, type, len, save, c;
        1: 5180:  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};
        -: 5181:  uchar buf97[324], ci, cj, ck;
        1: 5182:  short morder, sorder=order;
        -: 5183:  char buf[10];
        -: 5184:/*
        -: 5185:   The MakerNote might have its own TIFF header (possibly with
        -: 5186:   its own byte-order!), or it might just be a table.
        -: 5187: */
        1: 5188:  if (!strcmp(make,"Nokia")) return;
        1: 5189:  fread (buf, 1, 10, ifp);
        2: 5190:  if (!strncmp (buf,"KDK" ,3) ||	/* these aren't TIFF tables */
        2: 5191:      !strncmp (buf,"VER" ,3) ||
        2: 5192:      !strncmp (buf,"IIII",4) ||
        1: 5193:      !strncmp (buf,"MMMM",4)) return;
        2: 5194:  if (!strncmp (buf,"KC"  ,2) ||	/* Konica KD-400Z, KD-510Z */
        1: 5195:      !strncmp (buf,"MLY" ,3)) {	/* Minolta DiMAGE G series */
    #####: 5196:    order = 0x4d4d;
    #####: 5197:    while ((i=ftell(ifp)) < data_offset && i < 16384) {
    #####: 5198:      wb[0] = wb[2];  wb[2] = wb[1];  wb[1] = wb[3];
    #####: 5199:      wb[3] = get2();
    #####: 5200:      if (wb[1] == 256 && wb[3] == 256 &&
    #####: 5201:	  wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)
    #####: 5202:	FORC4 cam_mul[c] = wb[c];
        -: 5203:    }
        -: 5204:    goto quit;
        -: 5205:  }
        1: 5206:  if (!strcmp (buf,"Nikon")) {
    #####: 5207:    base = ftell(ifp);
    #####: 5208:    order = get2();
    #####: 5209:    if (get2() != 42) goto quit;
    #####: 5210:    offset = get4();
    #####: 5211:    fseek (ifp, offset-8, SEEK_CUR);
        2: 5212:  } else if (!strcmp (buf,"OLYMPUS") ||
        1: 5213:             !strcmp (buf,"PENTAX ")) {
    #####: 5214:    base = ftell(ifp)-10;
    #####: 5215:    fseek (ifp, -2, SEEK_CUR);
    #####: 5216:    order = get2();
    #####: 5217:    if (buf[0] == 'O') get2();
        2: 5218:  } else if (!strncmp (buf,"SONY",4) ||
        1: 5219:	     !strcmp  (buf,"Panasonic")) {
        -: 5220:    goto nf;
        1: 5221:  } else if (!strncmp (buf,"FUJIFILM",8)) {
    #####: 5222:    base = ftell(ifp)-10;
    #####: 5223:nf: order = 0x4949;
    #####: 5224:    fseek (ifp,  2, SEEK_CUR);
        2: 5225:  } else if (!strcmp (buf,"OLYMP") ||
        2: 5226:	     !strcmp (buf,"LEICA") ||
        2: 5227:	     !strcmp (buf,"Ricoh") ||
        1: 5228:	     !strcmp (buf,"EPSON"))
    #####: 5229:    fseek (ifp, -2, SEEK_CUR);
        2: 5230:  else if (!strcmp (buf,"AOC") ||
        1: 5231:	   !strcmp (buf,"QVC"))
    #####: 5232:    fseek (ifp, -4, SEEK_CUR);
        -: 5233:  else {
        1: 5234:    fseek (ifp, -10, SEEK_CUR);
        1: 5235:    if (!strncmp(make,"SAMSUNG",7))
    #####: 5236:      base = ftell(ifp);
        -: 5237:  }
        1: 5238:  entries = get2();
        1: 5239:  if (entries > 1000) return;
        1: 5240:  morder = order;
       43: 5241:  while (entries--) {
       41: 5242:    order = morder;
       41: 5243:    tiff_get (base, &tag, &type, &len, &save);
       41: 5244:    tag |= uptag << 16;
       41: 5245:    if (tag == 2 && strstr(make,"NIKON") && !iso_speed)
    #####: 5246:      iso_speed = (get2(),get2());
       41: 5247:    if (tag == 4 && len > 26 && len < 35) {
        1: 5248:      if ((i=(get4(),get2())) != 0x7fff && !iso_speed)
    #####: 5249:	iso_speed = 50 * pow (2, i/32.0 - 4);
        1: 5250:      if ((i=(get2(),get2())) != 0x7fff && !aperture)
    #####: 5251:	aperture = pow (2, i/64.0);
        1: 5252:      if ((i=get2()) != 0xffff && !shutter)
    #####: 5253:	shutter = pow (2, (short) i/-32.0);
        1: 5254:      wbi = (get2(),get2());
        1: 5255:      shot_order = (get2(),get2());
        -: 5256:    }
       41: 5257:    if ((tag == 4 || tag == 0x114) && !strncmp(make,"KONICA",6)) {
    #####: 5258:      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);
    #####: 5259:      switch (get2()) {
    #####: 5260:	case 72:  flip = 0;  break;
    #####: 5261:	case 76:  flip = 6;  break;
    #####: 5262:	case 82:  flip = 5;  break;
        -: 5263:      }
        -: 5264:    }
       41: 5265:    if (tag == 7 && type == 2 && len > 20)
        1: 5266:      fgets (model2, 64, ifp);
       41: 5267:    if (tag == 8 && type == 4)
    #####: 5268:      shot_order = get4();
       41: 5269:    if (tag == 9 && !strcmp(make,"Canon"))
        1: 5270:      fread (artist, 64, 1, ifp);
       41: 5271:    if (tag == 0xc && len == 4)
    #####: 5272:      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);
       41: 5273:    if (tag == 0xd && type == 7 && get2() == 0xaaaa) {
       51: 5274:      for (c=i=2; (ushort) c != 0xbbbb && i < len; i++)
      102: 5275:	c = c << 8 | fgetc(ifp);
       18: 5276:      while ((i+=4) < len-5)
       18: 5277:	if (get4() == 257 && (i=len) && (c = (get4(),fgetc(ifp))) < 3)
        1: 5278:	  flip = "065"[c]-'0';
        -: 5279:    }
       41: 5280:    if (tag == 0x10 && type == 4)
        1: 5281:      unique_id = get4();
       41: 5282:    if (tag == 0x11 && is_raw && !strncmp(make,"NIKON",5)) {
    #####: 5283:      fseek (ifp, get4()+base, SEEK_SET);
    #####: 5284:      parse_tiff_ifd (base);
        -: 5285:    }
       41: 5286:    if (tag == 0x14 && type == 7) {
    #####: 5287:      if (len == 2560) {
    #####: 5288:	fseek (ifp, 1248, SEEK_CUR);
    #####: 5289:	goto get2_256;
        -: 5290:      }
    #####: 5291:      fread (buf, 1, 10, ifp);
    #####: 5292:      if (!strncmp(buf,"NRW ",4)) {
    #####: 5293:	fseek (ifp, strcmp(buf+4,"0100") ? 46:1546, SEEK_CUR);
    #####: 5294:	cam_mul[0] = get4() << 2;
    #####: 5295:	cam_mul[1] = get4() + get4();
    #####: 5296:	cam_mul[2] = get4() << 2;
        -: 5297:      }
        -: 5298:    }
       41: 5299:    if (tag == 0x15 && type == 2 && is_raw)
    #####: 5300:      fread (model, 64, 1, ifp);
       41: 5301:    if (strstr(make,"PENTAX")) {
    #####: 5302:      if (tag == 0x1b) tag = 0x1018;
    #####: 5303:      if (tag == 0x1c) tag = 0x1017;
        -: 5304:    }
       41: 5305:    if (tag == 0x1d)
    #####: 5306:      while ((c = fgetc(ifp)) && c != EOF)
    #####: 5307:	serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);
       41: 5308:    if (tag == 0x29 && type == 1) {
    #####: 5309:      c = wbi < 18 ? "012347800000005896"[wbi]-'0' : 0;
    #####: 5310:      fseek (ifp, 8 + c*32, SEEK_CUR);
    #####: 5311:      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();
        -: 5312:    }
       41: 5313:    if (tag == 0x3d && type == 3 && len == 4)
    #####: 5314:      FORC4 cblack[c ^ c >> 1] = get2() >> (14-tiff_bps);
       41: 5315:    if (tag == 0x81 && type == 4) {
    #####: 5316:      data_offset = get4();
    #####: 5317:      fseek (ifp, data_offset + 41, SEEK_SET);
    #####: 5318:      raw_height = get2() * 2;
    #####: 5319:      raw_width  = get2();
    #####: 5320:      filters = 0x61616161;
        -: 5321:    }
       41: 5322:    if ((tag == 0x81  && type == 7) ||
       41: 5323:	(tag == 0x100 && type == 7) ||
    #####: 5324:	(tag == 0x280 && type == 1)) {
    #####: 5325:      thumb_offset = ftell(ifp);
    #####: 5326:      thumb_length = len;
        -: 5327:    }
       41: 5328:    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))
    #####: 5329:      thumb_offset += base;
       41: 5330:    if (tag == 0x89 && type == 4)
    #####: 5331:      thumb_length = get4();
       41: 5332:    if (tag == 0x8c || tag == 0x96)
        1: 5333:      meta_offset = ftell(ifp);
       41: 5334:    if (tag == 0x97) {
        4: 5335:      for (i=0; i < 4; i++)
        8: 5336:	ver97 = ver97 * 10 + fgetc(ifp)-'0';
        1: 5337:      switch (ver97) {
    #####: 5338:	case 100:
    #####: 5339:	  fseek (ifp, 68, SEEK_CUR);
    #####: 5340:	  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();
        -: 5341:	  break;
    #####: 5342:	case 102:
    #####: 5343:	  fseek (ifp, 6, SEEK_CUR);
    #####: 5344:	  FORC4 cam_mul[c ^ (c >> 1)] = get2();
        -: 5345:	  break;
    #####: 5346:	case 103:
    #####: 5347:	  fseek (ifp, 16, SEEK_CUR);
    #####: 5348:	  FORC4 cam_mul[c] = get2();
        -: 5349:      }
        1: 5350:      if (ver97 >= 200) {
        1: 5351:	if (ver97 != 205) fseek (ifp, 280, SEEK_CUR);
        1: 5352:	fread (buf97, 324, 1, ifp);
        -: 5353:      }
        -: 5354:    }
       41: 5355:    if (tag == 0xa1 && type == 7) {
    #####: 5356:      order = 0x4949;
    #####: 5357:      fseek (ifp, 140, SEEK_CUR);
    #####: 5358:      FORC3 cam_mul[c] = get4();
        -: 5359:    }
       41: 5360:    if (tag == 0xa4 && type == 3) {
    #####: 5361:      fseek (ifp, wbi*48, SEEK_CUR);
    #####: 5362:      FORC3 cam_mul[c] = get2();
        -: 5363:    }
       41: 5364:    if (tag == 0xa7 && (unsigned) (ver97-200) < 17) {
    #####: 5365:      ci = xlat[0][serial & 0xff];
    #####: 5366:      cj = xlat[1][fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp)];
        -: 5367:      ck = 0x60;
    #####: 5368:      for (i=0; i < 324; i++)
    #####: 5369:	buf97[i] ^= (cj += ci * ck++);
    #####: 5370:      i = "66666>666;6A;:;55"[ver97-200] - '0';
    #####: 5371:      FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =
    #####: 5372:	sget2 (buf97 + (i & -2) + c*2);
        -: 5373:    }
       41: 5374:    if (tag == 0x200 && len == 3)
    #####: 5375:      shot_order = (get4(),get4());
       41: 5376:    if (tag == 0x200 && len == 4)
    #####: 5377:      FORC4 cblack[c ^ c >> 1] = get2();
       41: 5378:    if (tag == 0x201 && len == 4)
    #####: 5379:      FORC4 cam_mul[c ^ (c >> 1)] = get2();
       41: 5380:    if (tag == 0x220 && type == 7)
    #####: 5381:      meta_offset = ftell(ifp);
       41: 5382:    if (tag == 0x401 && type == 4 && len == 4)
    #####: 5383:      FORC4 cblack[c ^ c >> 1] = get4();
       41: 5384:    if (tag == 0xe01) {		/* Nikon Capture Note */
    #####: 5385:      order = 0x4949;
    #####: 5386:      fseek (ifp, 22, SEEK_CUR);
    #####: 5387:      for (offset=22; offset+22 < len; offset += 22+i) {
    #####: 5388:	tag = get4();
    #####: 5389:	fseek (ifp, 14, SEEK_CUR);
    #####: 5390:	i = get4()-4;
    #####: 5391:	if (tag == 0x76a43207) flip = get2();
    #####: 5392:	else fseek (ifp, i, SEEK_CUR);
        -: 5393:      }
        -: 5394:    }
       41: 5395:    if (tag == 0xe80 && len == 256 && type == 7) {
    #####: 5396:      fseek (ifp, 48, SEEK_CUR);
    #####: 5397:      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;
    #####: 5398:      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;
        -: 5399:    }
       41: 5400:    if (tag == 0xf00 && type == 7) {
    #####: 5401:      if (len == 614)
    #####: 5402:	fseek (ifp, 176, SEEK_CUR);
    #####: 5403:      else if (len == 734 || len == 1502)
    #####: 5404:	fseek (ifp, 148, SEEK_CUR);
        -: 5405:      else goto next;
        -: 5406:      goto get2_256;
        -: 5407:    }
       41: 5408:    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)
    #####: 5409:      for (i=0; i < 3; i++)
    #####: 5410:	FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;
       41: 5411:    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)
    #####: 5412:      FORC4 cblack[c ^ c >> 1] = get2();
       41: 5413:    if (tag == 0x1017 || tag == 0x20400100)
    #####: 5414:      cam_mul[0] = get2() / 256.0;
       41: 5415:    if (tag == 0x1018 || tag == 0x20400100)
    #####: 5416:      cam_mul[2] = get2() / 256.0;
       41: 5417:    if (tag == 0x2011 && len == 2) {
    #####: 5418:get2_256:
    #####: 5419:      order = 0x4d4d;
    #####: 5420:      cam_mul[0] = get2() / 256.0;
    #####: 5421:      cam_mul[2] = get2() / 256.0;
        -: 5422:    }
       41: 5423:    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))
    #####: 5424:      fseek (ifp, get4()+base, SEEK_SET);
       41: 5425:    if (tag == 0x2020 && !strncmp(buf,"OLYMP",5))
    #####: 5426:      parse_thumb_note (base, 257, 258);
       41: 5427:    if (tag == 0x2040)
    #####: 5428:      parse_makernote (base, 0x2040);
       41: 5429:    if (tag == 0xb028) {
    #####: 5430:      fseek (ifp, get4()+base, SEEK_SET);
    #####: 5431:      parse_thumb_note (base, 136, 137);
        -: 5432:    }
       41: 5433:    if (tag == 0x4001 && len > 500) {
        1: 5434:      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;
        1: 5435:      fseek (ifp, i, SEEK_CUR);
        1: 5436:      FORC4 cam_mul[c ^ (c >> 1)] = get2();
       12: 5437:      for (i+=18; i <= len; i+=10) {
       12: 5438:	get2();
       12: 5439:	FORC4 sraw_mul[c ^ (c >> 1)] = get2();
       12: 5440:	if (sraw_mul[1] == 1170) break;
        -: 5441:      }
        -: 5442:    }
       41: 5443:    if (tag == 0x4021 && get4() && get4())
    #####: 5444:      FORC4 cam_mul[c] = 1024;
       41: 5445:    if (tag == 0xa021)
    #####: 5446:      FORC4 cam_mul[c ^ (c >> 1)] = get4();
       41: 5447:    if (tag == 0xa028)
    #####: 5448:      FORC4 cam_mul[c ^ (c >> 1)] -= get4();
       41: 5449:    if (tag == 0xb001)
    #####: 5450:      unique_id = get2();
       82: 5451:next:
       41: 5452:    fseek (ifp, save, SEEK_SET);
        -: 5453:  }
        1: 5454:quit:
        1: 5455:  order = sorder;
        -: 5456:}
        -: 5457:
        -: 5458:/*
        -: 5459:   Since the TIFF DateTime string has no timezone information,
        -: 5460:   assume that the camera's clock was set to Universal Time.
        -: 5461: */
        3: 5462:void CLASS get_timestamp (int reversed)
        -: 5463:{
        -: 5464:  struct tm t;
        -: 5465:  char str[20];
        -: 5466:  int i;
        -: 5467:
        3: 5468:  str[19] = 0;
        3: 5469:  if (reversed)
    #####: 5470:    for (i=19; i--; ) str[i] = fgetc(ifp);
        -: 5471:  else
        3: 5472:    fread (str, 19, 1, ifp);
        3: 5473:  memset (&t, 0, sizeof t);
        3: 5474:  if (sscanf (str, "%d:%d:%d %d:%d:%d", &t.tm_year, &t.tm_mon,
        -: 5475:	&t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)
    #####: 5476:    return;
        3: 5477:  t.tm_year -= 1900;
        3: 5478:  t.tm_mon -= 1;
        3: 5479:  t.tm_isdst = -1;
        3: 5480:  if (mktime(&t) > 0)
        3: 5481:    timestamp = mktime(&t);
        -: 5482:}
        -: 5483:
        1: 5484:void CLASS parse_exif (int base)
        -: 5485:{
        -: 5486:  unsigned kodak, entries, tag, type, len, save, c;
        -: 5487:  double expo;
        -: 5488:
        1: 5489:  kodak = !strncmp(make,"EASTMAN",7) && tiff_nifds < 3;
        1: 5490:  entries = get2();
       40: 5491:  while (entries--) {
       38: 5492:    tiff_get (base, &tag, &type, &len, &save);
       38: 5493:    switch (tag) {
        2: 5494:      case 33434:  tiff_ifd[tiff_nifds-1].shutter =
        2: 5495:		   shutter = getreal(type);		break;
        1: 5496:      case 33437:  aperture = getreal(type);		break;
        1: 5497:      case 34855:  iso_speed = get2();			break;
        2: 5498:      case 36867:
        2: 5499:      case 36868:  get_timestamp(0);			break;
        1: 5500:      case 37377:  if ((expo = -getreal(type)) < 128)
        1: 5501:		     tiff_ifd[tiff_nifds-1].shutter =
        1: 5502:		     shutter = pow (2, expo);		break;
        1: 5503:      case 37378:  aperture = pow (2, getreal(type)/2);	break;
        1: 5504:      case 37386:  focal_len = getreal(type);		break;
        1: 5505:      case 37500:  parse_makernote (base, 0);		break;
        1: 5506:      case 40962:  if (kodak) raw_width  = get4();	break;
        1: 5507:      case 40963:  if (kodak) raw_height = get4();	break;
    #####: 5508:      case 41730:
    #####: 5509:	if (get4() == 0x20002)
    #####: 5510:	  for (exif_cfa=c=0; c < 8; c+=2)
    #####: 5511:	    exif_cfa |= fgetc(ifp) * 0x01010101 << c;
        -: 5512:    }
       38: 5513:    fseek (ifp, save, SEEK_SET);
        -: 5514:  }
        1: 5515:}
        -: 5516:
        1: 5517:void CLASS parse_gps (int base)
        -: 5518:{
        -: 5519:  unsigned entries, tag, type, len, save, c;
        -: 5520:
        1: 5521:  entries = get2();
        3: 5522:  while (entries--) {
        1: 5523:    tiff_get (base, &tag, &type, &len, &save);
        1: 5524:    switch (tag) {
    #####: 5525:      case 1: case 3: case 5:
    #####: 5526:	gpsdata[29+tag/2] = getc(ifp);			break;
        -: 5527:      case 2: case 4: case 7:
    #####: 5528:	FORC(6) gpsdata[tag/3*6+c] = get4();		break;
        -: 5529:      case 6:
    #####: 5530:	FORC(2) gpsdata[18+c] = get4();			break;
    #####: 5531:      case 18: case 29:
    #####: 5532:	fgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);
        -: 5533:    }
        1: 5534:    fseek (ifp, save, SEEK_SET);
        -: 5535:  }
        1: 5536:}
        -: 5537:
    #####: 5538:void CLASS romm_coeff (float romm_cam[3][3])
        -: 5539:{
        -: 5540:  static const float rgb_romm[3][3] =	/* ROMM == Kodak ProPhoto */
        -: 5541:  { {  2.034193, -0.727420, -0.306766 },
        -: 5542:    { -0.228811,  1.231729, -0.002922 },
        -: 5543:    { -0.008565, -0.153273,  1.161839 } };
        -: 5544:  int i, j, k;
        -: 5545:
    #####: 5546:  for (i=0; i < 3; i++)
    #####: 5547:    for (j=0; j < 3; j++)
    #####: 5548:      for (cmatrix[i][j] = k=0; k < 3; k++)
    #####: 5549:	cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];
    #####: 5550:}
        -: 5551:
    #####: 5552:void CLASS parse_mos (int offset)
        -: 5553:{
        -: 5554:  char data[40];
    #####: 5555:  int skip, from, i, c, neut[4], planes=0, frot=0;
        -: 5556:  static const char *mod[] =
        -: 5557:  { "","DCB2","Volare","Cantare","CMost","Valeo 6","Valeo 11","Valeo 22",
        -: 5558:    "Valeo 11p","Valeo 17","","Aptus 17","Aptus 22","Aptus 75","Aptus 65",
        -: 5559:    "Aptus 54S","Aptus 65S","Aptus 75S","AFi 5","AFi 6","AFi 7",
        -: 5560:    "AFi-II 7","Aptus-II 7","","Aptus-II 6","","","Aptus-II 10","Aptus-II 5",
        -: 5561:    "","","","","Aptus-II 10R","Aptus-II 8","","Aptus-II 12","","AFi-II 12" };
        -: 5562:  float romm_cam[3][3];
        -: 5563:
    #####: 5564:  fseek (ifp, offset, SEEK_SET);
        -: 5565:  while (1) {
    #####: 5566:    if (get4() != 0x504b5453) break;
    #####: 5567:    get4();
    #####: 5568:    fread (data, 1, 40, ifp);
    #####: 5569:    skip = get4();
    #####: 5570:    from = ftell(ifp);
    #####: 5571:    if (!strcmp(data,"JPEG_preview_data")) {
    #####: 5572:      thumb_offset = from;
    #####: 5573:      thumb_length = skip;
        -: 5574:    }
    #####: 5575:    if (!strcmp(data,"icc_camera_profile")) {
    #####: 5576:      profile_offset = from;
    #####: 5577:      profile_length = skip;
        -: 5578:    }
    #####: 5579:    if (!strcmp(data,"ShootObj_back_type")) {
    #####: 5580:      fscanf (ifp, "%d", &i);
    #####: 5581:      if ((unsigned) i < sizeof mod / sizeof (*mod))
    #####: 5582:	strcpy (model, mod[i]);
        -: 5583:    }
    #####: 5584:    if (!strcmp(data,"icc_camera_to_tone_matrix")) {
    #####: 5585:      for (i=0; i < 9; i++)
    #####: 5586:	((float *)romm_cam)[i] = int_to_float(get4());
    #####: 5587:      romm_coeff (romm_cam);
        -: 5588:    }
    #####: 5589:    if (!strcmp(data,"CaptProf_color_matrix")) {
    #####: 5590:      for (i=0; i < 9; i++)
    #####: 5591:	fscanf (ifp, "%f", (float *)romm_cam + i);
    #####: 5592:      romm_coeff (romm_cam);
        -: 5593:    }
    #####: 5594:    if (!strcmp(data,"CaptProf_number_of_planes"))
    #####: 5595:      fscanf (ifp, "%d", &planes);
    #####: 5596:    if (!strcmp(data,"CaptProf_raw_data_rotation"))
    #####: 5597:      fscanf (ifp, "%d", &flip);
    #####: 5598:    if (!strcmp(data,"CaptProf_mosaic_pattern"))
    #####: 5599:      FORC4 {
    #####: 5600:	fscanf (ifp, "%d", &i);
    #####: 5601:	if (i == 1) frot = c ^ (c >> 1);
        -: 5602:      }
    #####: 5603:    if (!strcmp(data,"ImgProf_rotation_angle")) {
    #####: 5604:      fscanf (ifp, "%d", &i);
    #####: 5605:      flip = i - flip;
        -: 5606:    }
    #####: 5607:    if (!strcmp(data,"NeutObj_neutrals") && !cam_mul[0]) {
    #####: 5608:      FORC4 fscanf (ifp, "%d", neut+c);
    #####: 5609:      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];
        -: 5610:    }
    #####: 5611:    if (!strcmp(data,"Rows_data"))
    #####: 5612:      load_flags = get4();
    #####: 5613:    parse_mos (from);
    #####: 5614:    fseek (ifp, skip+from, SEEK_SET);
        -: 5615:  }
    #####: 5616:  if (planes)
    #####: 5617:    filters = (planes == 1) * 0x01010101 *
    #####: 5618:	(uchar) "\x94\x61\x16\x49"[(flip/90 + frot) & 3];
    #####: 5619:}
        -: 5620:
    #####: 5621:void CLASS linear_table (unsigned len)
        -: 5622:{
        -: 5623:  int i;
    #####: 5624:  if (len > 0x1000) len = 0x1000;
    #####: 5625:  read_shorts (curve, len);
    #####: 5626:  for (i=len; i < 0x1000; i++)
    #####: 5627:    curve[i] = curve[i-1];
    #####: 5628:  maximum = curve[0xfff];
    #####: 5629:}
        -: 5630:
    #####: 5631:void CLASS parse_kodak_ifd (int base)
        -: 5632:{
        -: 5633:  unsigned entries, tag, type, len, save;
        -: 5634:  int i, c, wbi=-2, wbtemp=6500;
    #####: 5635:  float mul[3]={1,1,1}, num;
        -: 5636:  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };
        -: 5637:
    #####: 5638:  entries = get2();
    #####: 5639:  if (entries > 1024) return;
    #####: 5640:  while (entries--) {
    #####: 5641:    tiff_get (base, &tag, &type, &len, &save);
    #####: 5642:    if (tag == 1020) wbi = getint(type);
    #####: 5643:    if (tag == 1021 && len == 72) {		/* WB set in software */
    #####: 5644:      fseek (ifp, 40, SEEK_CUR);
    #####: 5645:      FORC3 cam_mul[c] = 2048.0 / get2();
        -: 5646:      wbi = -2;
        -: 5647:    }
    #####: 5648:    if (tag == 2118) wbtemp = getint(type);
    #####: 5649:    if (tag == 2120 + wbi && wbi >= 0)
    #####: 5650:      FORC3 cam_mul[c] = 2048.0 / getreal(type);
    #####: 5651:    if (tag == 2130 + wbi)
    #####: 5652:      FORC3 mul[c] = getreal(type);
    #####: 5653:    if (tag == 2140 + wbi && wbi >= 0)
    #####: 5654:      FORC3 {
    #####: 5655:	for (num=i=0; i < 4; i++)
    #####: 5656:	  num += getreal(type) * pow (wbtemp/100.0, i);
    #####: 5657:	cam_mul[c] = 2048 / (num * mul[c]);
        -: 5658:      }
    #####: 5659:    if (tag == 2317) linear_table (len);
    #####: 5660:    if (tag == 6020) iso_speed = getint(type);
    #####: 5661:    if (tag == 64013) wbi = fgetc(ifp);
    #####: 5662:    if ((unsigned) wbi < 7 && tag == wbtag[wbi])
    #####: 5663:      FORC3 cam_mul[c] = get4();
    #####: 5664:    if (tag == 64019) width = getint(type);
    #####: 5665:    if (tag == 64020) height = (getint(type)+1) & -2;
    #####: 5666:    fseek (ifp, save, SEEK_SET);
        -: 5667:  }
        -: 5668:}
        -: 5669:
        -: 5670:void CLASS parse_minolta (int base);
        -: 5671:int CLASS parse_tiff (int base);
        -: 5672:
        4: 5673:int CLASS parse_tiff_ifd (int base)
        -: 5674:{
        -: 5675:  unsigned entries, tag, type, len, plen=16, save;
        -: 5676:  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;
        -: 5677:  char software[64], *cbuf, *cp;
        4: 5678:  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];
        -: 5679:  double cc[4][4], cm[4][3], cam_xyz[4][3], num;
        4: 5680:  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };
        4: 5681:  unsigned sony_curve[] = { 0,0,0,0,0,4095 };
        -: 5682:  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;
        -: 5683:  struct jhead jh;
        -: 5684:  FILE *sfp;
        -: 5685:
        4: 5686:  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])
        -: 5687:    return 1;
        4: 5688:  ifd = tiff_nifds++;
       20: 5689:  for (j=0; j < 4; j++)
       64: 5690:    for (i=0; i < 4; i++)
       64: 5691:      cc[j][i] = i == j;
        4: 5692:  entries = get2();
        4: 5693:  if (entries > 512) return 1;
       44: 5694:  while (entries--) {
       40: 5695:    tiff_get (base, &tag, &type, &len, &save);
       40: 5696:    switch (tag) {
    #####: 5697:      case 5:   width  = get2();  break;
    #####: 5698:      case 6:   height = get2();  break;
    #####: 5699:      case 7:   width += get2();  break;
    #####: 5700:      case 9:   if ((i = get2())) filters = i;  break;
    #####: 5701:      case 17: case 18:
    #####: 5702:	if (type == 3 && len == 1)
    #####: 5703:	  cam_mul[(tag-17)*2] = get2() / 256.0;
        -: 5704:	break;
    #####: 5705:      case 23:
    #####: 5706:	if (type == 3) iso_speed = get2();
        -: 5707:	break;
    #####: 5708:      case 28: case 29: case 30:
    #####: 5709:	cblack[tag-28] = get2();
    #####: 5710:	cblack[3] = cblack[1];
    #####: 5711:	break;
    #####: 5712:      case 36: case 37: case 38:
    #####: 5713:	cam_mul[tag-36] = get2();
    #####: 5714:	break;
    #####: 5715:      case 39:
    #####: 5716:	if (len < 50 || cam_mul[0]) break;
    #####: 5717:	fseek (ifp, 12, SEEK_CUR);
    #####: 5718:	FORC3 cam_mul[c] = get2();
        -: 5719:	break;
    #####: 5720:      case 46:
    #####: 5721:	if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;
    #####: 5722:	thumb_offset = ftell(ifp) - 2;
    #####: 5723:	thumb_length = len;
    #####: 5724:	break;
    #####: 5725:      case 61440:			/* Fuji HS10 table */
    #####: 5726:	fseek (ifp, get4()+base, SEEK_SET);
    #####: 5727:	parse_tiff_ifd (base);
    #####: 5728:	break;
        2: 5729:      case 2: case 256: case 61441:	/* ImageWidth */
        4: 5730:	tiff_ifd[ifd].width = getint(type);
        2: 5731:	break;
        2: 5732:      case 3: case 257: case 61442:	/* ImageHeight */
        4: 5733:	tiff_ifd[ifd].height = getint(type);
        2: 5734:	break;
        2: 5735:      case 258:				/* BitsPerSample */
        -: 5736:      case 61443:
        2: 5737:	tiff_ifd[ifd].samples = len & 7;
        4: 5738:	tiff_ifd[ifd].bps = getint(type);
        2: 5739:	if (tiff_bps < tiff_ifd[ifd].bps)
        2: 5740:	    tiff_bps = tiff_ifd[ifd].bps;
        -: 5741:	break;
    #####: 5742:      case 61446:
    #####: 5743:	raw_height = 0;
    #####: 5744:	if (tiff_ifd[ifd].bps > 12) break;
    #####: 5745:	load_raw = &CLASS packed_load_raw;
    #####: 5746:	load_flags = get4() ? 24:80;
    #####: 5747:	break;
        3: 5748:      case 259:				/* Compression */
        6: 5749:	tiff_ifd[ifd].comp = getint(type);
        3: 5750:	break;
        1: 5751:      case 262:				/* PhotometricInterpretation */
        1: 5752:	tiff_ifd[ifd].phint = get2();
        1: 5753:	break;
    #####: 5754:      case 270:				/* ImageDescription */
    #####: 5755:	fread (desc, 512, 1, ifp);
    #####: 5756:	break;
        1: 5757:      case 271:				/* Make */
        1: 5758:	fgets (make, 64, ifp);
        1: 5759:	break;
        1: 5760:      case 272:				/* Model */
        1: 5761:	fgets (model, 64, ifp);
        1: 5762:	break;
    #####: 5763:      case 280:				/* Panasonic RW2 offset */
    #####: 5764:	if (type != 4) break;
    #####: 5765:	load_raw = &CLASS panasonic_load_raw;
    #####: 5766:	load_flags = 0x2008;
        4: 5767:      case 273:				/* StripOffset */
        -: 5768:      case 513:				/* JpegIFOffset */
        -: 5769:      case 61447:
        4: 5770:	tiff_ifd[ifd].offset = get4()+base;
        4: 5771:	if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {
        2: 5772:	  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);
        2: 5773:	  if (ljpeg_start (&jh, 1)) {
        2: 5774:	    tiff_ifd[ifd].comp    = 6;
        2: 5775:	    tiff_ifd[ifd].width   = jh.wide;
        2: 5776:	    tiff_ifd[ifd].height  = jh.high;
        2: 5777:	    tiff_ifd[ifd].bps     = jh.bits;
        2: 5778:	    tiff_ifd[ifd].samples = jh.clrs;
        2: 5779:	    if (!(jh.sraw || (jh.clrs & 1)))
        1: 5780:	      tiff_ifd[ifd].width *= jh.clrs;
        2: 5781:	    if ((tiff_ifd[ifd].width > 4*tiff_ifd[ifd].height) & ~jh.clrs) {
    #####: 5782:	      tiff_ifd[ifd].width  /= 2;
    #####: 5783:	      tiff_ifd[ifd].height *= 2;
        -: 5784:	    }
        2: 5785:	    i = order;
        2: 5786:	    parse_tiff (tiff_ifd[ifd].offset + 12);
        2: 5787:	    order = i;
        -: 5788:	  }
        -: 5789:	}
        -: 5790:	break;
        1: 5791:      case 274:				/* Orientation */
        1: 5792:	tiff_ifd[ifd].flip = "50132467"[get2() & 7]-'0';
        1: 5793:	break;
        1: 5794:      case 277:				/* SamplesPerPixel */
        2: 5795:	tiff_ifd[ifd].samples = getint(type) & 7;
        1: 5796:	break;
        4: 5797:      case 279:				/* StripByteCounts */
        -: 5798:      case 514:
        -: 5799:      case 61448:
        4: 5800:	tiff_ifd[ifd].bytes = get4();
        4: 5801:	break;
        -: 5802:      case 61454:
    #####: 5803:	FORC3 cam_mul[(4-c) % 3] = getint(type);
        -: 5804:	break;
    #####: 5805:      case 305:  case 11:		/* Software */
    #####: 5806:	fgets (software, 64, ifp);
    #####: 5807:	if (!strncmp(software,"Adobe",5) ||
    #####: 5808:	    !strncmp(software,"dcraw",5) ||
    #####: 5809:	    !strncmp(software,"UFRaw",5) ||
    #####: 5810:	    !strncmp(software,"Bibble",6) ||
    #####: 5811:	    !strncmp(software,"Nikon Scan",10) ||
    #####: 5812:	    !strcmp (software,"Digital Photo Professional"))
    #####: 5813:	  is_raw = 0;
        -: 5814:	break;
        1: 5815:      case 306:				/* DateTime */
        1: 5816:	get_timestamp(0);
        1: 5817:	break;
        1: 5818:      case 315:				/* Artist */
        1: 5819:	fread (artist, 64, 1, ifp);
        1: 5820:	break;
    #####: 5821:      case 322:				/* TileWidth */
    #####: 5822:	tiff_ifd[ifd].tile_width = getint(type);
    #####: 5823:	break;
    #####: 5824:      case 323:				/* TileLength */
    #####: 5825:	tiff_ifd[ifd].tile_length = getint(type);
    #####: 5826:	break;
    #####: 5827:      case 324:				/* TileOffsets */
    #####: 5828:	tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();
    #####: 5829:	if (len == 1)
    #####: 5830:	  tiff_ifd[ifd].tile_width = tiff_ifd[ifd].tile_length = 0;
    #####: 5831:	if (len == 4) {
    #####: 5832:	  load_raw = &CLASS sinar_4shot_load_raw;
    #####: 5833:	  is_raw = 5;
        -: 5834:	}
        -: 5835:	break;
    #####: 5836:      case 330:				/* SubIFDs */
    #####: 5837:	if (!strcmp(model,"DSLR-A100") && tiff_ifd[ifd].width == 3872) {
    #####: 5838:	  load_raw = &CLASS sony_arw_load_raw;
    #####: 5839:	  data_offset = get4()+base;
    #####: 5840:	  ifd++;  break;
        -: 5841:	}
    #####: 5842:	while (len--) {
    #####: 5843:	  i = ftell(ifp);
    #####: 5844:	  fseek (ifp, get4()+base, SEEK_SET);
    #####: 5845:	  if (parse_tiff_ifd (base)) break;
    #####: 5846:	  fseek (ifp, i+4, SEEK_SET);
        -: 5847:	}
        -: 5848:	break;
    #####: 5849:      case 400:
    #####: 5850:	strcpy (make, "Sarnoff");
    #####: 5851:	maximum = 0xfff;
    #####: 5852:	break;
        -: 5853:      case 28688:
    #####: 5854:	FORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;
    #####: 5855:	for (i=0; i < 5; i++)
    #####: 5856:	  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)
    #####: 5857:	    curve[j] = curve[j-1] + (1 << i);
        -: 5858:	break;
    #####: 5859:      case 29184: sony_offset = get4();  break;
    #####: 5860:      case 29185: sony_length = get4();  break;
    #####: 5861:      case 29217: sony_key    = get4();  break;
    #####: 5862:      case 29264:
    #####: 5863:	parse_minolta (ftell(ifp));
    #####: 5864:	raw_width = 0;
    #####: 5865:	break;
        -: 5866:      case 29443:
    #####: 5867:	FORC4 cam_mul[c ^ (c < 2)] = get2();
        -: 5868:	break;
        -: 5869:      case 29459:
    #####: 5870:	FORC4 cam_mul[c] = get2();
    #####: 5871:	i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;
    #####: 5872:	SWAP (cam_mul[i],cam_mul[i+1])
    #####: 5873:	break;
    #####: 5874:      case 33405:			/* Model2 */
    #####: 5875:	fgets (model2, 64, ifp);
    #####: 5876:	break;
    #####: 5877:      case 33421:			/* CFARepeatPatternDim */
    #####: 5878:	if (get2() == 6 && get2() == 6)
    #####: 5879:	  filters = 9;
        -: 5880:	break;
    #####: 5881:      case 33422:			/* CFAPattern */
    #####: 5882:	if (filters == 9) {
    #####: 5883:	  FORC(36) ((char *)xtrans)[c] = fgetc(ifp) & 3;
        -: 5884:	  break;
        -: 5885:	}
        -: 5886:      case 64777:			/* Kodak P-series */
    #####: 5887:	if ((plen=len) > 16) plen = 16;
    #####: 5888:	fread (cfa_pat, 1, plen, ifp);
    #####: 5889:	for (colors=cfa=i=0; i < plen && colors < 4; i++) {
    #####: 5890:	  colors += !(cfa & (1 << cfa_pat[i]));
    #####: 5891:	  cfa |= 1 << cfa_pat[i];
        -: 5892:	}
    #####: 5893:	if (cfa == 070) memcpy (cfa_pc,"\003\004\005",3);	/* CMY */
    #####: 5894:	if (cfa == 072) memcpy (cfa_pc,"\005\003\004\001",4);	/* GMCY */
        -: 5895:	goto guess_cfa_pc;
    #####: 5896:      case 33424:
        -: 5897:      case 65024:
    #####: 5898:	fseek (ifp, get4()+base, SEEK_SET);
    #####: 5899:	parse_kodak_ifd (base);
    #####: 5900:	break;
    #####: 5901:      case 33434:			/* ExposureTime */
    #####: 5902:	tiff_ifd[ifd].shutter = shutter = getreal(type);
    #####: 5903:	break;
    #####: 5904:      case 33437:			/* FNumber */
    #####: 5905:	aperture = getreal(type);
    #####: 5906:	break;
        -: 5907:      case 34306:			/* Leaf white balance */
    #####: 5908:	FORC4 cam_mul[c ^ 1] = 4096.0 / get2();
        -: 5909:	break;
    #####: 5910:      case 34307:			/* Leaf CatchLight color matrix */
    #####: 5911:	fread (software, 1, 7, ifp);
    #####: 5912:	if (strncmp(software,"MATRIX",6)) break;
    #####: 5913:	colors = 4;
    #####: 5914:	for (raw_color = i=0; i < 3; i++) {
    #####: 5915:	  FORC4 fscanf (ifp, "%f", &rgb_cam[i][c^1]);
    #####: 5916:	  if (!use_camera_wb) continue;
        -: 5917:	  num = 0;
    #####: 5918:	  FORC4 num += rgb_cam[i][c];
    #####: 5919:	  FORC4 rgb_cam[i][c] /= num;
        -: 5920:	}
        -: 5921:	break;
    #####: 5922:      case 34310:			/* Leaf metadata */
    #####: 5923:	parse_mos (ftell(ifp));
    #####: 5924:      case 34303:
    #####: 5925:	strcpy (make, "Leaf");
    #####: 5926:	break;
        1: 5927:      case 34665:			/* EXIF tag */
        1: 5928:	fseek (ifp, get4()+base, SEEK_SET);
        1: 5929:	parse_exif (base);
        1: 5930:	break;
        1: 5931:      case 34853:			/* GPSInfo tag */
        1: 5932:	fseek (ifp, get4()+base, SEEK_SET);
        1: 5933:	parse_gps (base);
        1: 5934:	break;
    #####: 5935:      case 34675:			/* InterColorProfile */
        -: 5936:      case 50831:			/* AsShotICCProfile */
    #####: 5937:	profile_offset = ftell(ifp);
    #####: 5938:	profile_length = len;
    #####: 5939:	break;
    #####: 5940:      case 37122:			/* CompressedBitsPerPixel */
    #####: 5941:	kodak_cbpp = get4();
    #####: 5942:	break;
    #####: 5943:      case 37386:			/* FocalLength */
    #####: 5944:	focal_len = getreal(type);
    #####: 5945:	break;
    #####: 5946:      case 37393:			/* ImageNumber */
    #####: 5947:	shot_order = getint(type);
    #####: 5948:	break;
    #####: 5949:      case 37400:			/* old Kodak KDC tag */
    #####: 5950:	for (raw_color = i=0; i < 3; i++) {
    #####: 5951:	  getreal(type);
    #####: 5952:	  FORC3 rgb_cam[i][c] = getreal(type);
        -: 5953:	}
        -: 5954:	break;
    #####: 5955:      case 40976:
    #####: 5956:	strip_offset = get4();
    #####: 5957:	switch (tiff_ifd[ifd].comp) {
    #####: 5958:	  case 32770: load_raw = &CLASS samsung_load_raw;   break;
    #####: 5959:	  case 32772: load_raw = &CLASS samsung2_load_raw;  break;
    #####: 5960:	  case 32773: load_raw = &CLASS samsung3_load_raw;  break;
        -: 5961:	}
        -: 5962:	break;
    #####: 5963:      case 46275:			/* Imacon tags */
    #####: 5964:	strcpy (make, "Imacon");
    #####: 5965:	data_offset = ftell(ifp);
    #####: 5966:	ima_len = len;
    #####: 5967:	break;
    #####: 5968:      case 46279:
    #####: 5969:	if (!ima_len) break;
    #####: 5970:	fseek (ifp, 38, SEEK_CUR);
    #####: 5971:      case 46274:
    #####: 5972:	fseek (ifp, 40, SEEK_CUR);
    #####: 5973:	raw_width  = get4();
    #####: 5974:	raw_height = get4();
    #####: 5975:	left_margin = get4() & 7;
    #####: 5976:	width = raw_width - left_margin - (get4() & 7);
    #####: 5977:	top_margin = get4() & 7;
    #####: 5978:	height = raw_height - top_margin - (get4() & 7);
    #####: 5979:	if (raw_width == 7262) {
    #####: 5980:	  height = 5444;
    #####: 5981:	  width  = 7244;
    #####: 5982:	  left_margin = 7;
        -: 5983:	}
    #####: 5984:	fseek (ifp, 52, SEEK_CUR);
    #####: 5985:	FORC3 cam_mul[c] = getreal(11);
    #####: 5986:	fseek (ifp, 114, SEEK_CUR);
    #####: 5987:	flip = (get2() >> 7) * 90;
    #####: 5988:	if (width * height * 6 == ima_len) {
    #####: 5989:	  if (flip % 180 == 90) SWAP(width,height);
    #####: 5990:	  raw_width = width;
    #####: 5991:	  raw_height = height;
    #####: 5992:	  left_margin = top_margin = filters = flip = 0;
        -: 5993:	}
    #####: 5994:	sprintf (model, "Ixpress %d-Mp", height*width/1000000);
    #####: 5995:	load_raw = &CLASS imacon_full_load_raw;
    #####: 5996:	if (filters) {
    #####: 5997:	  if (left_margin & 1) filters = 0x61616161;
    #####: 5998:	  load_raw = &CLASS unpacked_load_raw;
        -: 5999:	}
    #####: 6000:	maximum = 0xffff;
    #####: 6001:	break;
    #####: 6002:      case 50454:			/* Sinar tag */
        -: 6003:      case 50455:
    #####: 6004:	if (!(cbuf = (char *) malloc(len))) break;
    #####: 6005:	fread (cbuf, 1, len, ifp);
    #####: 6006:	for (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\n'))
    #####: 6007:	  if (!strncmp (++cp,"Neutral ",8))
    #####: 6008:	    sscanf (cp+8, "%f %f %f", cam_mul, cam_mul+1, cam_mul+2);
    #####: 6009:	free (cbuf);
    #####: 6010:	break;
    #####: 6011:      case 50458:
    #####: 6012:	if (!make[0]) strcpy (make, "Hasselblad");
        -: 6013:	break;
    #####: 6014:      case 50459:			/* Hasselblad tag */
    #####: 6015:	i = order;
    #####: 6016:	j = ftell(ifp);
    #####: 6017:	c = tiff_nifds;
    #####: 6018:	order = get2();
    #####: 6019:	fseek (ifp, j+(get2(),get4()), SEEK_SET);
    #####: 6020:	parse_tiff_ifd (j);
    #####: 6021:	maximum = 0xffff;
    #####: 6022:	tiff_nifds = c;
    #####: 6023:	order = i;
    #####: 6024:	break;
        -: 6025:      case 50706:			/* DNGVersion */
    #####: 6026:	FORC4 dng_version = (dng_version << 8) + fgetc(ifp);
    #####: 6027:	if (!make[0]) strcpy (make, "DNG");
    #####: 6028:	is_raw = 1;
    #####: 6029:	break;
    #####: 6030:      case 50708:			/* UniqueCameraModel */
    #####: 6031:	if (model[0]) break;
    #####: 6032:	fgets (make, 64, ifp);
    #####: 6033:        if ((cp = strchr(make,' '))) {
    #####: 6034:	  strcpy(model,cp+1);
    #####: 6035:	  *cp = 0;
        -: 6036:	}
        -: 6037:	break;
    #####: 6038:      case 50710:			/* CFAPlaneColor */
    #####: 6039:	if (filters == 9) break;
    #####: 6040:	if (len > 4) len = 4;
    #####: 6041:	colors = len;
    #####: 6042:	fread (cfa_pc, 1, colors, ifp);
    #####: 6043:guess_cfa_pc:
    #####: 6044:	FORCC tab[cfa_pc[c]] = c;
    #####: 6045:	cdesc[c] = 0;
    #####: 6046:	for (i=16; i--; )
    #####: 6047:	  filters = filters << 2 | tab[cfa_pat[i % plen]];
    #####: 6048:	filters -= !filters;
    #####: 6049:	break;
    #####: 6050:      case 50711:			/* CFALayout */
    #####: 6051:	if (get2() == 2) fuji_width = 1;
        -: 6052:	break;
    #####: 6053:      case 291:
        -: 6054:      case 50712:			/* LinearizationTable */
    #####: 6055:	linear_table (len);
    #####: 6056:	break;
    #####: 6057:      case 50713:			/* BlackLevelRepeatDim */
    #####: 6058:	cblack[4] = get2();
    #####: 6059:	cblack[5] = get2();
    #####: 6060:	if (cblack[4] * cblack[5] > sizeof cblack / sizeof *cblack - 6)
    #####: 6061:	    cblack[4] = cblack[5] = 1;
        -: 6062:	break;
    #####: 6063:      case 61450:
    #####: 6064:	cblack[4] = cblack[5] = MIN(sqrt(len),64);
    #####: 6065:      case 50714:			/* BlackLevel */
    #####: 6066:	if (!(cblack[4] * cblack[5]))
    #####: 6067:	  cblack[4] = cblack[5] = 1;
    #####: 6068:	FORC (cblack[4] * cblack[5])
    #####: 6069:	  cblack[6+c] = getreal(type);
    #####: 6070:	black = 0;
    #####: 6071:	break;
        -: 6072:      case 50715:			/* BlackLevelDeltaH */
        -: 6073:      case 50716:			/* BlackLevelDeltaV */
    #####: 6074:	for (num=i=0; i < (len & 0xffff); i++)
    #####: 6075:	  num += getreal(type);
    #####: 6076:	black += num/len + 0.5;
    #####: 6077:	break;
    #####: 6078:      case 50717:			/* WhiteLevel */
    #####: 6079:	maximum = getint(type);
    #####: 6080:	break;
    #####: 6081:      case 50718:			/* DefaultScale */
    #####: 6082:	pixel_aspect  = getreal(type);
    #####: 6083:	pixel_aspect /= getreal(type);
    #####: 6084:	break;
        -: 6085:      case 50721:			/* ColorMatrix1 */
        -: 6086:      case 50722:			/* ColorMatrix2 */
    #####: 6087:	FORCC for (j=0; j < 3; j++)
    #####: 6088:	  cm[c][j] = getreal(type);
        -: 6089:	use_cm = 1;
        -: 6090:	break;
        -: 6091:      case 50723:			/* CameraCalibration1 */
        -: 6092:      case 50724:			/* CameraCalibration2 */
    #####: 6093:	for (i=0; i < colors; i++)
    #####: 6094:	  FORCC cc[i][c] = getreal(type);
        -: 6095:	break;
        -: 6096:      case 50727:			/* AnalogBalance */
    #####: 6097:	FORCC ab[c] = getreal(type);
        -: 6098:	break;
        -: 6099:      case 50728:			/* AsShotNeutral */
    #####: 6100:	FORCC asn[c] = getreal(type);
        -: 6101:	break;
    #####: 6102:      case 50729:			/* AsShotWhiteXY */
    #####: 6103:	xyz[0] = getreal(type);
    #####: 6104:	xyz[1] = getreal(type);
    #####: 6105:	xyz[2] = 1 - xyz[0] - xyz[1];
    #####: 6106:	FORC3 xyz[c] /= d65_white[c];
        -: 6107:	break;
    #####: 6108:      case 50740:			/* DNGPrivateData */
    #####: 6109:	if (dng_version) break;
    #####: 6110:	parse_minolta (j = get4()+base);
    #####: 6111:	fseek (ifp, j, SEEK_SET);
    #####: 6112:	parse_tiff_ifd (base);
    #####: 6113:	break;
        1: 6114:      case 50752:
        1: 6115:	read_shorts (cr2_slice, 3);
        1: 6116:	break;
    #####: 6117:      case 50829:			/* ActiveArea */
    #####: 6118:	top_margin = getint(type);
    #####: 6119:	left_margin = getint(type);
    #####: 6120:	height = getint(type) - top_margin;
    #####: 6121:	width = getint(type) - left_margin;
    #####: 6122:	break;
        -: 6123:      case 50830:			/* MaskedAreas */
    #####: 6124:        for (i=0; i < len && i < 32; i++)
    #####: 6125:	  ((int *)mask)[i] = getint(type);
    #####: 6126:	black = 0;
    #####: 6127:	break;
    #####: 6128:      case 51009:			/* OpcodeList2 */
    #####: 6129:	meta_offset = ftell(ifp);
    #####: 6130:	break;
    #####: 6131:      case 64772:			/* Kodak P-series */
    #####: 6132:	if (len < 13) break;
    #####: 6133:	fseek (ifp, 16, SEEK_CUR);
    #####: 6134:	data_offset = get4();
    #####: 6135:	fseek (ifp, 28, SEEK_CUR);
    #####: 6136:	data_offset += get4();
    #####: 6137:	load_raw = &CLASS packed_load_raw;
    #####: 6138:	break;
    #####: 6139:      case 65026:
    #####: 6140:	if (type == 2) fgets (model2, 64, ifp);
        -: 6141:    }
       40: 6142:    fseek (ifp, save, SEEK_SET);
        -: 6143:  }
        4: 6144:  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {
    #####: 6145:    fseek (ifp, sony_offset, SEEK_SET);
    #####: 6146:    fread (buf, sony_length, 1, ifp);
    #####: 6147:    sony_decrypt (buf, sony_length/4, 1, sony_key);
    #####: 6148:    sfp = ifp;
    #####: 6149:    if ((ifp = tmpfile())) {
    #####: 6150:      fwrite (buf, sony_length, 1, ifp);
    #####: 6151:      fseek (ifp, 0, SEEK_SET);
    #####: 6152:      parse_tiff_ifd (-sony_offset);
    #####: 6153:      fclose (ifp);
        -: 6154:    }
    #####: 6155:    ifp = sfp;
    #####: 6156:    free (buf);
        -: 6157:  }
       12: 6158:  for (i=0; i < colors; i++)
       36: 6159:    FORCC cc[i][c] *= ab[i];
        4: 6160:  if (use_cm) {
    #####: 6161:    FORCC for (i=0; i < 3; i++)
    #####: 6162:      for (cam_xyz[c][i]=j=0; j < colors; j++)
    #####: 6163:	cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];
    #####: 6164:    cam_xyz_coeff (cmatrix, cam_xyz);
        -: 6165:  }
        4: 6166:  if (asn[0]) {
    #####: 6167:    cam_mul[3] = 0;
    #####: 6168:    FORCC cam_mul[c] = 1 / asn[c];
        -: 6169:  }
        4: 6170:  if (!use_cm)
       12: 6171:    FORCC pre_mul[c] /= cc[c][c];
        -: 6172:  return 0;
        -: 6173:}
        -: 6174:
        3: 6175:int CLASS parse_tiff (int base)
        -: 6176:{
        -: 6177:  int doff;
        -: 6178:
        3: 6179:  fseek (ifp, base, SEEK_SET);
        3: 6180:  order = get2();
        3: 6181:  if (order != 0x4949 && order != 0x4d4d) return 0;
        1: 6182:  get2();
        6: 6183:  while ((doff = get4())) {
        4: 6184:    fseek (ifp, doff+base, SEEK_SET);
        4: 6185:    if (parse_tiff_ifd (base)) break;
        -: 6186:  }
        -: 6187:  return 1;
        -: 6188:}
        -: 6189:
        1: 6190:void CLASS apply_tiff()
        -: 6191:{
        -: 6192:  int max_samp=0, ties=0, os, ns, raw=-1, thm=-1, i;
        -: 6193:  struct jhead jh;
        -: 6194:
        1: 6195:  thumb_misc = 16;
        1: 6196:  if (thumb_offset) {
    #####: 6197:    fseek (ifp, thumb_offset, SEEK_SET);
    #####: 6198:    if (ljpeg_start (&jh, 1)) {
    #####: 6199:      thumb_misc   = jh.bits;
    #####: 6200:      thumb_width  = jh.wide;
    #####: 6201:      thumb_height = jh.high;
        -: 6202:    }
        -: 6203:  }
        6: 6204:  for (i=tiff_nifds; i--; ) {
        4: 6205:    if (tiff_ifd[i].shutter)
        1: 6206:      shutter = tiff_ifd[i].shutter;
        4: 6207:    tiff_ifd[i].shutter = shutter;
        -: 6208:  }
        4: 6209:  for (i=0; i < tiff_nifds; i++) {
        4: 6210:    if (max_samp < tiff_ifd[i].samples)
        -: 6211:	max_samp = tiff_ifd[i].samples;
        4: 6212:    if (max_samp > 3) max_samp = 3;
        4: 6213:    os = raw_width*raw_height;
        4: 6214:    ns = tiff_ifd[i].width*tiff_ifd[i].height;
        4: 6215:    if (tiff_bps) {
        4: 6216:      os *= tiff_bps;
        4: 6217:      ns *= tiff_ifd[i].bps;
        -: 6218:    }
        6: 6219:    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&
        4: 6220:	(tiff_ifd[i].width | tiff_ifd[i].height) < 0x10000 &&
        2: 6221:	 ns && ((ns > os && (ties = 1)) ||
    #####: 6222:		(ns == os && shot_select == ties++))) {
        2: 6223:      raw_width     = tiff_ifd[i].width;
        2: 6224:      raw_height    = tiff_ifd[i].height;
        2: 6225:      tiff_bps      = tiff_ifd[i].bps;
        2: 6226:      tiff_compress = tiff_ifd[i].comp;
        2: 6227:      data_offset   = tiff_ifd[i].offset;
        2: 6228:      tiff_flip     = tiff_ifd[i].flip;
        2: 6229:      tiff_samples  = tiff_ifd[i].samples;
        2: 6230:      tile_width    = tiff_ifd[i].tile_width;
        2: 6231:      tile_length   = tiff_ifd[i].tile_length;
        2: 6232:      shutter       = tiff_ifd[i].shutter;
        -: 6233:      raw = i;
        -: 6234:    }
        -: 6235:  }
        1: 6236:  if (is_raw == 1 && ties) is_raw = ties;
        1: 6237:  if (!tile_width ) tile_width  = INT_MAX;
        1: 6238:  if (!tile_length) tile_length = INT_MAX;
        5: 6239:  for (i=tiff_nifds; i--; )
        4: 6240:    if (tiff_ifd[i].flip) tiff_flip = tiff_ifd[i].flip;
        2: 6241:  if (raw >= 0 && !load_raw)
        1: 6242:    switch (tiff_compress) {
    #####: 6243:      case 32767:
    #####: 6244:	if (tiff_ifd[raw].bytes == raw_width*raw_height) {
    #####: 6245:	  tiff_bps = 12;
    #####: 6246:	  load_raw = &CLASS sony_arw2_load_raw;			break;
        -: 6247:	}
    #####: 6248:	if (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {
    #####: 6249:	  raw_height += 8;
    #####: 6250:	  load_raw = &CLASS sony_arw_load_raw;			break;
        -: 6251:	}
    #####: 6252:	load_flags = 79;
    #####: 6253:      case 32769:
    #####: 6254:	load_flags++;
        -: 6255:      case 32770:
        -: 6256:      case 32773: goto slr;
    #####: 6257:      case 0:  case 1:
    #####: 6258:	if (!strncmp(make,"OLYMPUS",7) &&
    #####: 6259:		tiff_ifd[raw].bytes*2 == raw_width*raw_height*3)
    #####: 6260:	  load_flags = 24;
    #####: 6261:	if (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {
    #####: 6262:	  load_flags = 81;
    #####: 6263:	  tiff_bps = 12;
    #####: 6264:	} slr:
    #####: 6265:	switch (tiff_bps) {
    #####: 6266:	  case  8: load_raw = &CLASS eight_bit_load_raw;	break;
    #####: 6267:	  case 12: if (tiff_ifd[raw].phint == 2)
    #####: 6268:		     load_flags = 6;
    #####: 6269:		   load_raw = &CLASS packed_load_raw;		break;
    #####: 6270:	  case 14: load_flags = 0;
    #####: 6271:	  case 16: load_raw = &CLASS unpacked_load_raw;
    #####: 6272:		   if (!strncmp(make,"OLYMPUS",7) &&
    #####: 6273:			tiff_ifd[raw].bytes*7 > raw_width*raw_height)
    #####: 6274:		     load_raw = &CLASS olympus_load_raw;
        -: 6275:	}
        -: 6276:	break;
        1: 6277:      case 6:  case 7:  case 99:
        1: 6278:	load_raw = &CLASS lossless_jpeg_load_raw;		break;
    #####: 6279:      case 262:
    #####: 6280:	load_raw = &CLASS kodak_262_load_raw;			break;
    #####: 6281:      case 34713:
    #####: 6282:	if ((raw_width+9)/10*16*raw_height == tiff_ifd[raw].bytes) {
    #####: 6283:	  load_raw = &CLASS packed_load_raw;
    #####: 6284:	  load_flags = 1;
    #####: 6285:	} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes*2) {
    #####: 6286:	  load_raw = &CLASS packed_load_raw;
    #####: 6287:	  if (model[0] == 'N') load_flags = 80;
    #####: 6288:	} else if (raw_width*raw_height*3 == tiff_ifd[raw].bytes) {
    #####: 6289:	  load_raw = &CLASS nikon_yuv_load_raw;
    #####: 6290:	  gamma_curve (1/2.4, 12.92, 1, 4095);
    #####: 6291:	  memset (cblack, 0, sizeof cblack);
    #####: 6292:	  filters = 0;
    #####: 6293:	} else if (raw_width*raw_height*2 == tiff_ifd[raw].bytes) {
    #####: 6294:	  load_raw = &CLASS unpacked_load_raw;
    #####: 6295:	  load_flags = 4;
    #####: 6296:	  order = 0x4d4d;
        -: 6297:	} else
    #####: 6298:	  load_raw = &CLASS nikon_load_raw;			break;
    #####: 6299:      case 65535:
    #####: 6300:	load_raw = &CLASS pentax_load_raw;			break;
    #####: 6301:      case 65000:
    #####: 6302:	switch (tiff_ifd[raw].phint) {
    #####: 6303:	  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;
    #####: 6304:	  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;
    #####: 6305:	  case 32803: load_raw = &CLASS kodak_65000_load_raw;
        -: 6306:	}
        -: 6307:      case 32867: case 34892: break;
    #####: 6308:      default: is_raw = 0;
        -: 6309:    }
        1: 6310:  if (!dng_version)
        1: 6311:    if ( (tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 &&
    #####: 6312:	  (tiff_compress & -16) != 32768)
        1: 6313:      || (tiff_bps == 8 && strncmp(make,"Phase",5) &&
    #####: 6314:	  !strcasestr(make,"Kodak") && !strstr(model2,"DEBUG RAW")))
    #####: 6315:      is_raw = 0;
        4: 6316:  for (i=0; i < tiff_nifds; i++)
        7: 6317:    if (i != raw && tiff_ifd[i].samples == max_samp &&
        3: 6318:	tiff_ifd[i].width * tiff_ifd[i].height / (SQR(tiff_ifd[i].bps)+1) >
        3: 6319:	      thumb_width *       thumb_height / (SQR(thumb_misc)+1)
        1: 6320:	&& tiff_ifd[i].comp != 34892) {
        1: 6321:      thumb_width  = tiff_ifd[i].width;
        1: 6322:      thumb_height = tiff_ifd[i].height;
        1: 6323:      thumb_offset = tiff_ifd[i].offset;
        1: 6324:      thumb_length = tiff_ifd[i].bytes;
        1: 6325:      thumb_misc   = tiff_ifd[i].bps;
        -: 6326:      thm = i;
        -: 6327:    }
        1: 6328:  if (thm >= 0) {
        1: 6329:    thumb_misc |= tiff_ifd[thm].samples << 5;
        1: 6330:    switch (tiff_ifd[thm].comp) {
    #####: 6331:      case 0:
    #####: 6332:	write_thumb = &CLASS layer_thumb;
    #####: 6333:	break;
    #####: 6334:      case 1:
    #####: 6335:	if (tiff_ifd[thm].bps <= 8)
    #####: 6336:	  write_thumb = &CLASS ppm_thumb;
    #####: 6337:	else if (!strcmp(make,"Imacon"))
    #####: 6338:	  write_thumb = &CLASS ppm16_thumb;
        -: 6339:	else
    #####: 6340:	  thumb_load_raw = &CLASS kodak_thumb_load_raw;
        -: 6341:	break;
    #####: 6342:      case 65000:
    #####: 6343:	thumb_load_raw = tiff_ifd[thm].phint == 6 ?
    #####: 6344:		&CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;
        -: 6345:    }
        -: 6346:  }
        1: 6347:}
        -: 6348:
    #####: 6349:void CLASS parse_minolta (int base)
        -: 6350:{
        -: 6351:  int save, tag, len, offset, high=0, wide=0, i, c;
    #####: 6352:  short sorder=order;
        -: 6353:
    #####: 6354:  fseek (ifp, base, SEEK_SET);
    #####: 6355:  if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;
    #####: 6356:  order = fgetc(ifp) * 0x101;
    #####: 6357:  offset = base + get4() + 8;
    #####: 6358:  while ((save=ftell(ifp)) < offset) {
    #####: 6359:    for (tag=i=0; i < 4; i++)
    #####: 6360:      tag = tag << 8 | fgetc(ifp);
    #####: 6361:    len = get4();
    #####: 6362:    switch (tag) {
    #####: 6363:      case 0x505244:				/* PRD */
    #####: 6364:	fseek (ifp, 8, SEEK_CUR);
    #####: 6365:	high = get2();
    #####: 6366:	wide = get2();
    #####: 6367:	break;
    #####: 6368:      case 0x574247:				/* WBG */
    #####: 6369:	get4();
    #####: 6370:	i = strcmp(model,"DiMAGE A200") ? 0:3;
    #####: 6371:	FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();
        -: 6372:	break;
    #####: 6373:      case 0x545457:				/* TTW */
    #####: 6374:	parse_tiff (ftell(ifp));
    #####: 6375:	data_offset = offset;
        -: 6376:    }
    #####: 6377:    fseek (ifp, save+len+8, SEEK_SET);
        -: 6378:  }
    #####: 6379:  raw_height = high;
    #####: 6380:  raw_width  = wide;
    #####: 6381:  order = sorder;
        -: 6382:}
        -: 6383:
        -: 6384:/*
        -: 6385:   Many cameras have a "debug mode" that writes JPEG and raw
        -: 6386:   at the same time.  The raw file has no header, so try to
        -: 6387:   to open the matching JPEG file and read its metadata.
        -: 6388: */
    #####: 6389:void CLASS parse_external_jpeg()
        -: 6390:{
        -: 6391:  const char *file, *ext;
        -: 6392:  char *jname, *jfile, *jext;
    #####: 6393:  FILE *save=ifp;
        -: 6394:
    #####: 6395:  ext  = strrchr (ifname, '.');
    #####: 6396:  file = strrchr (ifname, '/');
    #####: 6397:  if (!file) file = strrchr (ifname, '\\');
    #####: 6398:  if (!file) file = ifname-1;
    #####: 6399:  file++;
    #####: 6400:  if (!ext || strlen(ext) != 4 || ext-file != 8) return;
    #####: 6401:  jname = (char *) malloc (strlen(ifname) + 1);
    #####: 6402:  merror (jname, "parse_external_jpeg()");
    #####: 6403:  strcpy (jname, ifname);
    #####: 6404:  jfile = file - ifname + jname;
    #####: 6405:  jext  = ext  - ifname + jname;
    #####: 6406:  if (strcasecmp (ext, ".jpg")) {
    #####: 6407:    strcpy (jext, isupper(ext[1]) ? ".JPG":".jpg");
    #####: 6408:    if (isdigit(*file)) {
    #####: 6409:      memcpy (jfile, file+4, 4);
    #####: 6410:      memcpy (jfile+4, file, 4);
        -: 6411:    }
        -: 6412:  } else
    #####: 6413:    while (isdigit(*--jext)) {
    #####: 6414:      if (*jext != '9') {
    #####: 6415:	(*jext)++;
    #####: 6416:	break;
        -: 6417:      }
    #####: 6418:      *jext = '0';
        -: 6419:    }
    #####: 6420:  if (strcmp (jname, ifname)) {
    #####: 6421:    if ((ifp = fopen (jname, "rb"))) {
    #####: 6422:      if (verbose)
    #####: 6423:	fprintf (stderr,_("Reading metadata from %s ...\n"), jname);
    #####: 6424:      parse_tiff (12);
    #####: 6425:      thumb_offset = 0;
    #####: 6426:      is_raw = 1;
    #####: 6427:      fclose (ifp);
        -: 6428:    }
        -: 6429:  }
    #####: 6430:  if (!timestamp)
    #####: 6431:    fprintf (stderr,_("Failed to read metadata from %s\n"), jname);
    #####: 6432:  free (jname);
    #####: 6433:  ifp = save;
        -: 6434:}
        -: 6435:
        -: 6436:/*
        -: 6437:   CIFF block 0x1030 contains an 8x8 white sample.
        -: 6438:   Load this into white[][] for use in scale_colors().
        -: 6439: */
    #####: 6440:void CLASS ciff_block_1030()
        -: 6441:{
        -: 6442:  static const ushort key[] = { 0x410, 0x45f3 };
        -: 6443:  int i, bpp, row, col, vbits=0;
        -: 6444:  unsigned long bitbuf=0;
        -: 6445:
    #####: 6446:  if ((get2(),get4()) != 0x80008 || !get4()) return;
    #####: 6447:  bpp = get2();
    #####: 6448:  if (bpp != 10 && bpp != 12) return;
    #####: 6449:  for (i=row=0; row < 8; row++)
    #####: 6450:    for (col=0; col < 8; col++) {
    #####: 6451:      if (vbits < bpp) {
    #####: 6452:	bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);
    #####: 6453:	vbits += 16;
        -: 6454:      }
    #####: 6455:      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);
        -: 6456:    }
        -: 6457:}
        -: 6458:
        -: 6459:/*
        -: 6460:   Parse a CIFF file, better known as Canon CRW format.
        -: 6461: */
    #####: 6462:void CLASS parse_ciff (int offset, int length, int depth)
        -: 6463:{
        -: 6464:  int tboff, nrecs, c, type, len, save, wbi=-1;
    #####: 6465:  ushort key[] = { 0x410, 0x45f3 };
        -: 6466:
    #####: 6467:  fseek (ifp, offset+length-4, SEEK_SET);
    #####: 6468:  tboff = get4() + offset;
    #####: 6469:  fseek (ifp, tboff, SEEK_SET);
    #####: 6470:  nrecs = get2();
    #####: 6471:  if ((nrecs | depth) > 127) return;
    #####: 6472:  while (nrecs--) {
    #####: 6473:    type = get2();
    #####: 6474:    len  = get4();
    #####: 6475:    save = ftell(ifp) + 4;
    #####: 6476:    fseek (ifp, offset+get4(), SEEK_SET);
    #####: 6477:    if ((((type >> 8) + 8) | 8) == 0x38)
    #####: 6478:      parse_ciff (ftell(ifp), len, depth+1); /* Parse a sub-table */
    #####: 6479:    if (type == 0x0810)
    #####: 6480:      fread (artist, 64, 1, ifp);
    #####: 6481:    if (type == 0x080a) {
    #####: 6482:      fread (make, 64, 1, ifp);
    #####: 6483:      fseek (ifp, strlen(make) - 63, SEEK_CUR);
    #####: 6484:      fread (model, 64, 1, ifp);
        -: 6485:    }
    #####: 6486:    if (type == 0x1810) {
    #####: 6487:      width = get4();
    #####: 6488:      height = get4();
    #####: 6489:      pixel_aspect = int_to_float(get4());
    #####: 6490:      flip = get4();
        -: 6491:    }
    #####: 6492:    if (type == 0x1835)			/* Get the decoder table */
    #####: 6493:      tiff_compress = get4();
    #####: 6494:    if (type == 0x2007) {
    #####: 6495:      thumb_offset = ftell(ifp);
    #####: 6496:      thumb_length = len;
        -: 6497:    }
    #####: 6498:    if (type == 0x1818) {
    #####: 6499:      shutter = pow (2, -int_to_float((get4(),get4())));
    #####: 6500:      aperture = pow (2, int_to_float(get4())/2);
        -: 6501:    }
    #####: 6502:    if (type == 0x102a) {
    #####: 6503:      iso_speed = pow (2, (get4(),get2())/32.0 - 4) * 50;
    #####: 6504:      aperture  = pow (2, (get2(),(short)get2())/64.0);
    #####: 6505:      shutter   = pow (2,-((short)get2())/32.0);
    #####: 6506:      wbi = (get2(),get2());
    #####: 6507:      if (wbi > 17) wbi = 0;
    #####: 6508:      fseek (ifp, 32, SEEK_CUR);
    #####: 6509:      if (shutter > 1e6) shutter = get2()/10.0;
        -: 6510:    }
    #####: 6511:    if (type == 0x102c) {
    #####: 6512:      if (get2() > 512) {		/* Pro90, G1 */
    #####: 6513:	fseek (ifp, 118, SEEK_CUR);
    #####: 6514:	FORC4 cam_mul[c ^ 2] = get2();
        -: 6515:      } else {				/* G2, S30, S40 */
    #####: 6516:	fseek (ifp, 98, SEEK_CUR);
    #####: 6517:	FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();
        -: 6518:      }
        -: 6519:    }
    #####: 6520:    if (type == 0x0032) {
    #####: 6521:      if (len == 768) {			/* EOS D30 */
    #####: 6522:	fseek (ifp, 72, SEEK_CUR);
    #####: 6523:	FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();
    #####: 6524:	if (!wbi) cam_mul[0] = -1;	/* use my auto white balance */
    #####: 6525:      } else if (!cam_mul[0]) {
    #####: 6526:	if (get2() == key[0])		/* Pro1, G6, S60, S70 */
    #####: 6527:	  c = (strstr(model,"Pro1") ?
    #####: 6528:	      "012346000000000000":"01345:000000006008")[wbi]-'0'+ 2;
        -: 6529:	else {				/* G3, G5, S45, S50 */
    #####: 6530:	  c = "023457000000006000"[wbi]-'0';
    #####: 6531:	  key[0] = key[1] = 0;
        -: 6532:	}
    #####: 6533:	fseek (ifp, 78 + c*8, SEEK_CUR);
    #####: 6534:	FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];
    #####: 6535:	if (!wbi) cam_mul[0] = -1;
        -: 6536:      }
        -: 6537:    }
    #####: 6538:    if (type == 0x10a9) {		/* D60, 10D, 300D, and clones */
    #####: 6539:      if (len > 66) wbi = "0134567028"[wbi]-'0';
    #####: 6540:      fseek (ifp, 2 + wbi*8, SEEK_CUR);
    #####: 6541:      FORC4 cam_mul[c ^ (c >> 1)] = get2();
        -: 6542:    }
    #####: 6543:    if (type == 0x1030 && (0x18040 >> wbi & 1))
    #####: 6544:      ciff_block_1030();		/* all that don't have 0x10a9 */
    #####: 6545:    if (type == 0x1031) {
    #####: 6546:      raw_width = (get2(),get2());
    #####: 6547:      raw_height = get2();
        -: 6548:    }
    #####: 6549:    if (type == 0x5029) {
    #####: 6550:      focal_len = len >> 16;
    #####: 6551:      if ((len & 0xffff) == 2) focal_len /= 32;
        -: 6552:    }
    #####: 6553:    if (type == 0x5813) flash_used = int_to_float(len);
    #####: 6554:    if (type == 0x5814) canon_ev   = int_to_float(len);
    #####: 6555:    if (type == 0x5817) shot_order = len;
    #####: 6556:    if (type == 0x5834) unique_id  = len;
    #####: 6557:    if (type == 0x580e) timestamp  = len;
    #####: 6558:    if (type == 0x180e) timestamp  = get4();
        -: 6559:#ifdef LOCALTIME
        -: 6560:    if ((type | 0x4000) == 0x580e)
        -: 6561:      timestamp = mktime (gmtime (&timestamp));
        -: 6562:#endif
    #####: 6563:    fseek (ifp, save, SEEK_SET);
        -: 6564:  }
        -: 6565:}
        -: 6566:
    #####: 6567:void CLASS parse_rollei()
        -: 6568:{
        -: 6569:  char line[128], *val;
        -: 6570:  struct tm t;
        -: 6571:
    #####: 6572:  fseek (ifp, 0, SEEK_SET);
    #####: 6573:  memset (&t, 0, sizeof t);
        -: 6574:  do {
    #####: 6575:    fgets (line, 128, ifp);
    #####: 6576:    if ((val = strchr(line,'=')))
    #####: 6577:      *val++ = 0;
        -: 6578:    else
    #####: 6579:      val = line + strlen(line);
    #####: 6580:    if (!strcmp(line,"DAT"))
    #####: 6581:      sscanf (val, "%d.%d.%d", &t.tm_mday, &t.tm_mon, &t.tm_year);
    #####: 6582:    if (!strcmp(line,"TIM"))
    #####: 6583:      sscanf (val, "%d:%d:%d", &t.tm_hour, &t.tm_min, &t.tm_sec);
    #####: 6584:    if (!strcmp(line,"HDR"))
    #####: 6585:      thumb_offset = atoi(val);
    #####: 6586:    if (!strcmp(line,"X  "))
    #####: 6587:      raw_width = atoi(val);
    #####: 6588:    if (!strcmp(line,"Y  "))
    #####: 6589:      raw_height = atoi(val);
    #####: 6590:    if (!strcmp(line,"TX "))
    #####: 6591:      thumb_width = atoi(val);
    #####: 6592:    if (!strcmp(line,"TY "))
    #####: 6593:      thumb_height = atoi(val);
    #####: 6594:  } while (strncmp(line,"EOHD",4));
    #####: 6595:  data_offset = thumb_offset + thumb_width * thumb_height * 2;
    #####: 6596:  t.tm_year -= 1900;
    #####: 6597:  t.tm_mon -= 1;
    #####: 6598:  if (mktime(&t) > 0)
    #####: 6599:    timestamp = mktime(&t);
    #####: 6600:  strcpy (make, "Rollei");
    #####: 6601:  strcpy (model,"d530flex");
    #####: 6602:  write_thumb = &CLASS rollei_thumb;
    #####: 6603:}
        -: 6604:
    #####: 6605:void CLASS parse_sinar_ia()
        -: 6606:{
        -: 6607:  int entries, off;
        -: 6608:  char str[8], *cp;
        -: 6609:
    #####: 6610:  order = 0x4949;
    #####: 6611:  fseek (ifp, 4, SEEK_SET);
    #####: 6612:  entries = get4();
    #####: 6613:  fseek (ifp, get4(), SEEK_SET);
    #####: 6614:  while (entries--) {
    #####: 6615:    off = get4(); get4();
    #####: 6616:    fread (str, 8, 1, ifp);
    #####: 6617:    if (!strcmp(str,"META"))   meta_offset = off;
    #####: 6618:    if (!strcmp(str,"THUMB")) thumb_offset = off;
    #####: 6619:    if (!strcmp(str,"RAW0"))   data_offset = off;
        -: 6620:  }
    #####: 6621:  fseek (ifp, meta_offset+20, SEEK_SET);
    #####: 6622:  fread (make, 64, 1, ifp);
    #####: 6623:  make[63] = 0;
    #####: 6624:  if ((cp = strchr(make,' '))) {
    #####: 6625:    strcpy (model, cp+1);
    #####: 6626:    *cp = 0;
        -: 6627:  }
    #####: 6628:  raw_width  = get2();
    #####: 6629:  raw_height = get2();
    #####: 6630:  load_raw = &CLASS unpacked_load_raw;
    #####: 6631:  thumb_width = (get4(),get2());
    #####: 6632:  thumb_height = get2();
    #####: 6633:  write_thumb = &CLASS ppm_thumb;
    #####: 6634:  maximum = 0x3fff;
    #####: 6635:}
        -: 6636:
    #####: 6637:void CLASS parse_phase_one (int base)
        -: 6638:{
        -: 6639:  unsigned entries, tag, type, len, data, save, i, c;
        -: 6640:  float romm_cam[3][3];
        -: 6641:  char *cp;
        -: 6642:
    #####: 6643:  memset (&ph1, 0, sizeof ph1);
    #####: 6644:  fseek (ifp, base, SEEK_SET);
    #####: 6645:  order = get4() & 0xffff;
    #####: 6646:  if (get4() >> 8 != 0x526177) return;		/* "Raw" */
    #####: 6647:  fseek (ifp, get4()+base, SEEK_SET);
    #####: 6648:  entries = get4();
    #####: 6649:  get4();
    #####: 6650:  while (entries--) {
    #####: 6651:    tag  = get4();
    #####: 6652:    type = get4();
    #####: 6653:    len  = get4();
    #####: 6654:    data = get4();
    #####: 6655:    save = ftell(ifp);
    #####: 6656:    fseek (ifp, base+data, SEEK_SET);
    #####: 6657:    switch (tag) {
    #####: 6658:      case 0x100:  flip = "0653"[data & 3]-'0';  break;
        -: 6659:      case 0x106:
    #####: 6660:	for (i=0; i < 9; i++)
    #####: 6661:	  ((float *)romm_cam)[i] = getreal(11);
    #####: 6662:	romm_coeff (romm_cam);
    #####: 6663:	break;
        -: 6664:      case 0x107:
    #####: 6665:	FORC3 cam_mul[c] = getreal(11);
        -: 6666:	break;
    #####: 6667:      case 0x108:  raw_width     = data;	break;
    #####: 6668:      case 0x109:  raw_height    = data;	break;
    #####: 6669:      case 0x10a:  left_margin   = data;	break;
    #####: 6670:      case 0x10b:  top_margin    = data;	break;
    #####: 6671:      case 0x10c:  width         = data;	break;
    #####: 6672:      case 0x10d:  height        = data;	break;
    #####: 6673:      case 0x10e:  ph1.format    = data;	break;
    #####: 6674:      case 0x10f:  data_offset   = data+base;	break;
    #####: 6675:      case 0x110:  meta_offset   = data+base;
    #####: 6676:		   meta_length   = len;			break;
    #####: 6677:      case 0x112:  ph1.key_off   = save - 4;		break;
    #####: 6678:      case 0x210:  ph1.tag_210   = int_to_float(data);	break;
    #####: 6679:      case 0x21a:  ph1.tag_21a   = data;		break;
    #####: 6680:      case 0x21c:  strip_offset  = data+base;		break;
    #####: 6681:      case 0x21d:  ph1.black     = data;		break;
    #####: 6682:      case 0x222:  ph1.split_col = data;		break;
    #####: 6683:      case 0x223:  ph1.black_col = data+base;		break;
    #####: 6684:      case 0x224:  ph1.split_row = data;		break;
    #####: 6685:      case 0x225:  ph1.black_row = data+base;		break;
    #####: 6686:      case 0x301:
    #####: 6687:	model[63] = 0;
    #####: 6688:	fread (model, 1, 63, ifp);
    #####: 6689:	if ((cp = strstr(model," camera"))) *cp = 0;
        -: 6690:    }
    #####: 6691:    fseek (ifp, save, SEEK_SET);
        -: 6692:  }
    #####: 6693:  load_raw = ph1.format < 3 ?
    #####: 6694:	&CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;
    #####: 6695:  maximum = 0xffff;
    #####: 6696:  strcpy (make, "Phase One");
    #####: 6697:  if (model[0]) return;
    #####: 6698:  switch (raw_height) {
    #####: 6699:    case 2060: strcpy (model,"LightPhase");	break;
    #####: 6700:    case 2682: strcpy (model,"H 10");		break;
    #####: 6701:    case 4128: strcpy (model,"H 20");		break;
    #####: 6702:    case 5488: strcpy (model,"H 25");		break;
        -: 6703:  }
        -: 6704:}
        -: 6705:
    #####: 6706:void CLASS parse_fuji (int offset)
        -: 6707:{
        -: 6708:  unsigned entries, tag, len, save, c;
        -: 6709:
    #####: 6710:  fseek (ifp, offset, SEEK_SET);
    #####: 6711:  entries = get4();
    #####: 6712:  if (entries > 255) return;
    #####: 6713:  while (entries--) {
    #####: 6714:    tag = get2();
    #####: 6715:    len = get2();
    #####: 6716:    save = ftell(ifp);
    #####: 6717:    if (tag == 0x100) {
    #####: 6718:      raw_height = get2();
    #####: 6719:      raw_width  = get2();
    #####: 6720:    } else if (tag == 0x121) {
    #####: 6721:      height = get2();
    #####: 6722:      if ((width = get2()) == 4284) width += 3;
    #####: 6723:    } else if (tag == 0x130) {
    #####: 6724:      fuji_layout = fgetc(ifp) >> 7;
    #####: 6725:      fuji_width = !(fgetc(ifp) & 8);
    #####: 6726:    } else if (tag == 0x131) {
    #####: 6727:      filters = 9;
    #####: 6728:      FORC(36) xtrans_abs[0][35-c] = fgetc(ifp) & 3;
    #####: 6729:    } else if (tag == 0x2ff0) {
    #####: 6730:      FORC4 cam_mul[c ^ 1] = get2();
    #####: 6731:    } else if (tag == 0xc000) {
    #####: 6732:      c = order;
    #####: 6733:      order = 0x4949;
    #####: 6734:      while ((tag = get4()) > raw_width);
    #####: 6735:      width = tag;
    #####: 6736:      height = get4();
    #####: 6737:      order = c;
        -: 6738:    }
    #####: 6739:    fseek (ifp, save+len, SEEK_SET);
        -: 6740:  }
    #####: 6741:  height <<= fuji_layout;
    #####: 6742:  width  >>= fuji_layout;
        -: 6743:}
        -: 6744:
    #####: 6745:int CLASS parse_jpeg (int offset)
        -: 6746:{
        -: 6747:  int len, save, hlen, mark;
        -: 6748:
    #####: 6749:  fseek (ifp, offset, SEEK_SET);
    #####: 6750:  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) return 0;
        -: 6751:
    #####: 6752:  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda) {
    #####: 6753:    order = 0x4d4d;
    #####: 6754:    len   = get2() - 2;
    #####: 6755:    save  = ftell(ifp);
    #####: 6756:    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9) {
    #####: 6757:      fgetc(ifp);
    #####: 6758:      raw_height = get2();
    #####: 6759:      raw_width  = get2();
        -: 6760:    }
    #####: 6761:    order = get2();
    #####: 6762:    hlen  = get4();
    #####: 6763:    if (get4() == 0x48454150)		/* "HEAP" */
    #####: 6764:      parse_ciff (save+hlen, len-hlen, 0);
    #####: 6765:    if (parse_tiff (save+6)) apply_tiff();
    #####: 6766:    fseek (ifp, save+len, SEEK_SET);
        -: 6767:  }
        -: 6768:  return 1;
        -: 6769:}
        -: 6770:
    #####: 6771:void CLASS parse_riff()
        -: 6772:{
        -: 6773:  unsigned i, size, end;
        -: 6774:  char tag[4], date[64], month[64];
        -: 6775:  static const char mon[12][4] =
        -: 6776:  { "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec" };
        -: 6777:  struct tm t;
        -: 6778:
    #####: 6779:  order = 0x4949;
    #####: 6780:  fread (tag, 4, 1, ifp);
    #####: 6781:  size = get4();
    #####: 6782:  end = ftell(ifp) + size;
    #####: 6783:  if (!memcmp(tag,"RIFF",4) || !memcmp(tag,"LIST",4)) {
    #####: 6784:    get4();
    #####: 6785:    while (ftell(ifp)+7 < end && !feof(ifp))
    #####: 6786:      parse_riff();
    #####: 6787:  } else if (!memcmp(tag,"nctg",4)) {
    #####: 6788:    while (ftell(ifp)+7 < end) {
    #####: 6789:      i = get2();
    #####: 6790:      size = get2();
    #####: 6791:      if ((i+1) >> 1 == 10 && size == 20)
    #####: 6792:	get_timestamp(0);
    #####: 6793:      else fseek (ifp, size, SEEK_CUR);
        -: 6794:    }
    #####: 6795:  } else if (!memcmp(tag,"IDIT",4) && size < 64) {
    #####: 6796:    fread (date, 64, 1, ifp);
    #####: 6797:    date[size] = 0;
    #####: 6798:    memset (&t, 0, sizeof t);
    #####: 6799:    if (sscanf (date, "%*s %s %d %d:%d:%d %d", month, &t.tm_mday,
        -: 6800:	&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {
    #####: 6801:      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);
    #####: 6802:      t.tm_mon = i;
    #####: 6803:      t.tm_year -= 1900;
    #####: 6804:      if (mktime(&t) > 0)
    #####: 6805:	timestamp = mktime(&t);
        -: 6806:    }
        -: 6807:  } else
    #####: 6808:    fseek (ifp, size, SEEK_CUR);
    #####: 6809:}
        -: 6810:
    #####: 6811:void CLASS parse_qt (int end)
        -: 6812:{
        -: 6813:  unsigned save, size;
        -: 6814:  char tag[4];
        -: 6815:
    #####: 6816:  order = 0x4d4d;
    #####: 6817:  while (ftell(ifp)+7 < end) {
    #####: 6818:    save = ftell(ifp);
    #####: 6819:    if ((size = get4()) < 8) return;
    #####: 6820:    fread (tag, 4, 1, ifp);
    #####: 6821:    if (!memcmp(tag,"moov",4) ||
    #####: 6822:	!memcmp(tag,"udta",4) ||
    #####: 6823:	!memcmp(tag,"CNTH",4))
    #####: 6824:      parse_qt (save+size);
    #####: 6825:    if (!memcmp(tag,"CNDA",4))
    #####: 6826:      parse_jpeg (ftell(ifp));
    #####: 6827:    fseek (ifp, save+size, SEEK_SET);
        -: 6828:  }
        -: 6829:}
        -: 6830:
    #####: 6831:void CLASS parse_smal (int offset, int fsize)
        -: 6832:{
        -: 6833:  int ver;
        -: 6834:
    #####: 6835:  fseek (ifp, offset+2, SEEK_SET);
    #####: 6836:  order = 0x4949;
    #####: 6837:  ver = fgetc(ifp);
    #####: 6838:  if (ver == 6)
    #####: 6839:    fseek (ifp, 5, SEEK_CUR);
    #####: 6840:  if (get4() != fsize) return;
    #####: 6841:  if (ver > 6) data_offset = get4();
    #####: 6842:  raw_height = height = get2();
    #####: 6843:  raw_width  = width  = get2();
    #####: 6844:  strcpy (make, "SMaL");
    #####: 6845:  sprintf (model, "v%d %dx%d", ver, width, height);
    #####: 6846:  if (ver == 6) load_raw = &CLASS smal_v6_load_raw;
    #####: 6847:  if (ver == 9) load_raw = &CLASS smal_v9_load_raw;
        -: 6848:}
        -: 6849:
    #####: 6850:void CLASS parse_cine()
        -: 6851:{
        -: 6852:  unsigned off_head, off_setup, off_image, i;
        -: 6853:
    #####: 6854:  order = 0x4949;
    #####: 6855:  fseek (ifp, 4, SEEK_SET);
    #####: 6856:  is_raw = get2() == 2;
    #####: 6857:  fseek (ifp, 14, SEEK_CUR);
    #####: 6858:  is_raw *= get4();
    #####: 6859:  off_head = get4();
    #####: 6860:  off_setup = get4();
    #####: 6861:  off_image = get4();
    #####: 6862:  timestamp = get4();
    #####: 6863:  if ((i = get4())) timestamp = i;
    #####: 6864:  fseek (ifp, off_head+4, SEEK_SET);
    #####: 6865:  raw_width = get4();
    #####: 6866:  raw_height = get4();
    #####: 6867:  switch (get2(),get2()) {
    #####: 6868:    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;
    #####: 6869:    case 16:  load_raw = &CLASS  unpacked_load_raw;
        -: 6870:  }
    #####: 6871:  fseek (ifp, off_setup+792, SEEK_SET);
    #####: 6872:  strcpy (make, "CINE");
    #####: 6873:  sprintf (model, "%d", get4());
    #####: 6874:  fseek (ifp, 12, SEEK_CUR);
    #####: 6875:  switch ((i=get4()) & 0xffffff) {
    #####: 6876:    case  3:  filters = 0x94949494;  break;
    #####: 6877:    case  4:  filters = 0x49494949;  break;
    #####: 6878:    default:  is_raw = 0;
        -: 6879:  }
    #####: 6880:  fseek (ifp, 72, SEEK_CUR);
    #####: 6881:  switch ((get4()+3600) % 360) {
    #####: 6882:    case 270:  flip = 4;  break;
    #####: 6883:    case 180:  flip = 1;  break;
    #####: 6884:    case  90:  flip = 7;  break;
    #####: 6885:    case   0:  flip = 2;
        -: 6886:  }
    #####: 6887:  cam_mul[0] = getreal(11);
    #####: 6888:  cam_mul[2] = getreal(11);
    #####: 6889:  maximum = ~(-1 << get4());
    #####: 6890:  fseek (ifp, 668, SEEK_CUR);
    #####: 6891:  shutter = get4()/1000000000.0;
    #####: 6892:  fseek (ifp, off_image, SEEK_SET);
    #####: 6893:  if (shot_select < is_raw)
    #####: 6894:    fseek (ifp, shot_select*8, SEEK_CUR);
    #####: 6895:  data_offset  = (INT64) get4() + 8;
    #####: 6896:  data_offset += (INT64) get4() << 32;
    #####: 6897:}
        -: 6898:
    #####: 6899:void CLASS parse_redcine()
        -: 6900:{
        -: 6901:  unsigned i, len, rdvo;
        -: 6902:
    #####: 6903:  order = 0x4d4d;
    #####: 6904:  is_raw = 0;
    #####: 6905:  fseek (ifp, 52, SEEK_SET);
    #####: 6906:  width  = get4();
    #####: 6907:  height = get4();
    #####: 6908:  fseek (ifp, 0, SEEK_END);
    #####: 6909:  fseek (ifp, -(i = ftello(ifp) & 511), SEEK_CUR);
    #####: 6910:  if (get4() != i || get4() != 0x52454f42) {
    #####: 6911:    fprintf (stderr,_("%s: Tail is missing, parsing from head...\n"), ifname);
    #####: 6912:    fseek (ifp, 0, SEEK_SET);
    #####: 6913:    while ((len = get4()) != EOF) {
    #####: 6914:      if (get4() == 0x52454456)
    #####: 6915:	if (is_raw++ == shot_select)
    #####: 6916:	  data_offset = ftello(ifp) - 8;
    #####: 6917:      fseek (ifp, len-8, SEEK_CUR);
        -: 6918:    }
        -: 6919:  } else {
    #####: 6920:    rdvo = get4();
    #####: 6921:    fseek (ifp, 12, SEEK_CUR);
    #####: 6922:    is_raw = get4();
    #####: 6923:    fseeko (ifp, rdvo+8 + shot_select*4, SEEK_SET);
    #####: 6924:    data_offset = get4();
        -: 6925:  }
    #####: 6926:}
        -: 6927:
    #####: 6928:char * CLASS foveon_gets (int offset, char *str, int len)
        -: 6929:{
        -: 6930:  int i;
    #####: 6931:  fseek (ifp, offset, SEEK_SET);
    #####: 6932:  for (i=0; i < len-1; i++)
    #####: 6933:    if ((str[i] = get2()) == 0) break;
    #####: 6934:  str[i] = 0;
    #####: 6935:  return str;
        -: 6936:}
        -: 6937:
    #####: 6938:void CLASS parse_foveon()
        -: 6939:{
        -: 6940:  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];
        -: 6941:  char name[64], value[64];
        -: 6942:
    #####: 6943:  order = 0x4949;			/* Little-endian */
    #####: 6944:  fseek (ifp, 36, SEEK_SET);
    #####: 6945:  flip = get4();
    #####: 6946:  fseek (ifp, -4, SEEK_END);
    #####: 6947:  fseek (ifp, get4(), SEEK_SET);
    #####: 6948:  if (get4() != 0x64434553) return;	/* SECd */
    #####: 6949:  entries = (get4(),get4());
    #####: 6950:  while (entries--) {
    #####: 6951:    off = get4();
    #####: 6952:    len = get4();
    #####: 6953:    tag = get4();
    #####: 6954:    save = ftell(ifp);
    #####: 6955:    fseek (ifp, off, SEEK_SET);
    #####: 6956:    if (get4() != (0x20434553 | (tag << 24))) return;
    #####: 6957:    switch (tag) {
    #####: 6958:      case 0x47414d49:			/* IMAG */
        -: 6959:      case 0x32414d49:			/* IMA2 */
    #####: 6960:	fseek (ifp, 8, SEEK_CUR);
    #####: 6961:	pent = get4();
    #####: 6962:	wide = get4();
    #####: 6963:	high = get4();
    #####: 6964:	if (wide > raw_width && high > raw_height) {
    #####: 6965:	  switch (pent) {
    #####: 6966:	    case  5:  load_flags = 1;
    #####: 6967:	    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;
    #####: 6968:	    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;
    #####: 6969:	    default:  load_raw = 0;
        -: 6970:	  }
    #####: 6971:	  raw_width  = wide;
    #####: 6972:	  raw_height = high;
    #####: 6973:	  data_offset = off+28;
    #####: 6974:	  is_foveon = 1;
        -: 6975:	}
    #####: 6976:	fseek (ifp, off+28, SEEK_SET);
    #####: 6977:	if (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8
    #####: 6978:		&& thumb_length < len-28) {
    #####: 6979:	  thumb_offset = off+28;
    #####: 6980:	  thumb_length = len-28;
    #####: 6981:	  write_thumb = &CLASS jpeg_thumb;
        -: 6982:	}
    #####: 6983:	if (++img == 2 && !thumb_length) {
    #####: 6984:	  thumb_offset = off+24;
    #####: 6985:	  thumb_width = wide;
    #####: 6986:	  thumb_height = high;
    #####: 6987:	  write_thumb = &CLASS foveon_thumb;
        -: 6988:	}
        -: 6989:	break;
    #####: 6990:      case 0x464d4143:			/* CAMF */
    #####: 6991:	meta_offset = off+8;
    #####: 6992:	meta_length = len-28;
    #####: 6993:	break;
    #####: 6994:      case 0x504f5250:			/* PROP */
    #####: 6995:	pent = (get4(),get4());
    #####: 6996:	fseek (ifp, 12, SEEK_CUR);
    #####: 6997:	off += pent*8 + 24;
    #####: 6998:	if ((unsigned) pent > 256) pent=256;
    #####: 6999:	for (i=0; i < pent*2; i++)
    #####: 7000:	  ((int *)poff)[i] = off + get4()*2;
    #####: 7001:	for (i=0; i < pent; i++) {
    #####: 7002:	  foveon_gets (poff[i][0], name, 64);
    #####: 7003:	  foveon_gets (poff[i][1], value, 64);
    #####: 7004:	  if (!strcmp (name, "ISO"))
    #####: 7005:	    iso_speed = atoi(value);
    #####: 7006:	  if (!strcmp (name, "CAMMANUF"))
    #####: 7007:	    strcpy (make, value);
    #####: 7008:	  if (!strcmp (name, "CAMMODEL"))
    #####: 7009:	    strcpy (model, value);
    #####: 7010:	  if (!strcmp (name, "WB_DESC"))
    #####: 7011:	    strcpy (model2, value);
    #####: 7012:	  if (!strcmp (name, "TIME"))
    #####: 7013:	    timestamp = atoi(value);
    #####: 7014:	  if (!strcmp (name, "EXPTIME"))
    #####: 7015:	    shutter = atoi(value) / 1000000.0;
    #####: 7016:	  if (!strcmp (name, "APERTURE"))
    #####: 7017:	    aperture = atof(value);
    #####: 7018:	  if (!strcmp (name, "FLENGTH"))
    #####: 7019:	    focal_len = atof(value);
        -: 7020:	}
        -: 7021:#ifdef LOCALTIME
        -: 7022:	timestamp = mktime (gmtime (&timestamp));
        -: 7023:#endif
        -: 7024:    }
    #####: 7025:    fseek (ifp, save, SEEK_SET);
        -: 7026:  }
        -: 7027:}
        -: 7028:
        -: 7029:/*
        -: 7030:   All matrices are from Adobe DNG Converter unless otherwise noted.
        -: 7031: */
        1: 7032:void CLASS adobe_coeff (const char *make, const char *model)
        -: 7033:{
        -: 7034:  static const struct {
        -: 7035:    const char *prefix;
        -: 7036:    short black, maximum, trans[12];
        -: 7037:  } table[] = {
        -: 7038:    { "AgfaPhoto DC-833m", 0, 0,	/* DJC */
        -: 7039:	{ 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },
        -: 7040:    { "Apple QuickTake", 0, 0,		/* DJC */
        -: 7041:	{ 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },
        -: 7042:    { "Canon EOS D2000", 0, 0,
        -: 7043:	{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },
        -: 7044:    { "Canon EOS D6000", 0, 0,
        -: 7045:	{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },
        -: 7046:    { "Canon EOS D30", 0, 0,
        -: 7047:	{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },
        -: 7048:    { "Canon EOS D60", 0, 0xfa0,
        -: 7049:	{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },
        -: 7050:    { "Canon EOS 5DS", 0, 0x3c96,
        -: 7051:	{ 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },
        -: 7052:    { "Canon EOS 5D Mark III", 0, 0x3c80,
        -: 7053:	{ 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },
        -: 7054:    { "Canon EOS 5D Mark II", 0, 0x3cf0,
        -: 7055:	{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },
        -: 7056:    { "Canon EOS 5D", 0, 0xe6c,
        -: 7057:	{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },
        -: 7058:    { "Canon EOS 6D", 0, 0x3c82,
        -: 7059:	{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },
        -: 7060:    { "Canon EOS 7D Mark II", 0, 0x3510,
        -: 7061:	{ 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },
        -: 7062:    { "Canon EOS 7D", 0, 0x3510,
        -: 7063:	{ 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },
        -: 7064:    { "Canon EOS 10D", 0, 0xfa0,
        -: 7065:	{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },
        -: 7066:    { "Canon EOS 20Da", 0, 0,
        -: 7067:	{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },
        -: 7068:    { "Canon EOS 20D", 0, 0xfff,
        -: 7069:	{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },
        -: 7070:    { "Canon EOS 30D", 0, 0,
        -: 7071:	{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },
        -: 7072:    { "Canon EOS 40D", 0, 0x3f60,
        -: 7073:	{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },
        -: 7074:    { "Canon EOS 50D", 0, 0x3d93,
        -: 7075:	{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },
        -: 7076:    { "Canon EOS 60D", 0, 0x2ff7,
        -: 7077:	{ 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },
        -: 7078:    { "Canon EOS 70D", 0, 0x3bc7,
        -: 7079:	{ 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },
        -: 7080:    { "Canon EOS 80D", 0, 0,
        -: 7081:	{ 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },
        -: 7082:    { "Canon EOS 100D", 0, 0x350f,
        -: 7083:	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
        -: 7084:    { "Canon EOS 300D", 0, 0xfa0,
        -: 7085:	{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },
        -: 7086:    { "Canon EOS 350D", 0, 0xfff,
        -: 7087:	{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },
        -: 7088:    { "Canon EOS 400D", 0, 0xe8e,
        -: 7089:	{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },
        -: 7090:    { "Canon EOS 450D", 0, 0x390d,
        -: 7091:	{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },
        -: 7092:    { "Canon EOS 500D", 0, 0x3479,
        -: 7093:	{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },
        -: 7094:    { "Canon EOS 550D", 0, 0x3dd7,
        -: 7095:	{ 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },
        -: 7096:    { "Canon EOS 600D", 0, 0x3510,
        -: 7097:	{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },
        -: 7098:    { "Canon EOS 650D", 0, 0x354d,
        -: 7099:	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
        -: 7100:    { "Canon EOS 700D", 0, 0x3c00,
        -: 7101:	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
        -: 7102:    { "Canon EOS 750D", 0, 0x368e,
        -: 7103:	{ 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
        -: 7104:    { "Canon EOS 760D", 0, 0x350f,
        -: 7105:	{ 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
        -: 7106:    { "Canon EOS 1000D", 0, 0xe43,
        -: 7107:	{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },
        -: 7108:    { "Canon EOS 1100D", 0, 0x3510,
        -: 7109:	{ 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },
        -: 7110:    { "Canon EOS 1200D", 0, 0x37c2,
        -: 7111:	{ 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },
        -: 7112:    { "Canon EOS 1300D", 0, 0x3510,
        -: 7113:	{ 6939,-1016,-866,-4428,12473,2177,-1175,2178,6162 } },
        -: 7114:    { "Canon EOS M3", 0, 0,
        -: 7115:	{ 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
        -: 7116:    { "Canon EOS M10", 0, 0,
        -: 7117:	{ 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },
        -: 7118:    { "Canon EOS M", 0, 0,
        -: 7119:	{ 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
        -: 7120:    { "Canon EOS-1Ds Mark III", 0, 0x3bb0,
        -: 7121:	{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },
        -: 7122:    { "Canon EOS-1Ds Mark II", 0, 0xe80,
        -: 7123:	{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },
        -: 7124:    { "Canon EOS-1D Mark IV", 0, 0x3bb0,
        -: 7125:	{ 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },
        -: 7126:    { "Canon EOS-1D Mark III", 0, 0x3bb0,
        -: 7127:	{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },
        -: 7128:    { "Canon EOS-1D Mark II N", 0, 0xe80,
        -: 7129:	{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },
        -: 7130:    { "Canon EOS-1D Mark II", 0, 0xe80,
        -: 7131:	{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },
        -: 7132:    { "Canon EOS-1DS", 0, 0xe20,
        -: 7133:	{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },
        -: 7134:    { "Canon EOS-1D C", 0, 0x3c4e,
        -: 7135:	{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },
        -: 7136:    { "Canon EOS-1D X Mark II", 0, 0,
        -: 7137:	{ 7596,-978,-967,-4808,12571,2503,-1398,2567,5752 } },
        -: 7138:    { "Canon EOS-1D X", 0, 0x3c4e,
        -: 7139:	{ 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },
        -: 7140:    { "Canon EOS-1D", 0, 0xe20,
        -: 7141:	{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },
        -: 7142:    { "Canon EOS C500", 853, 0,		/* DJC */
        -: 7143:	{ 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },
        -: 7144:    { "Canon PowerShot A530", 0, 0,
        -: 7145:	{ 0 } },	/* don't want the A5 matrix */
        -: 7146:    { "Canon PowerShot A50", 0, 0,
        -: 7147:	{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },
        -: 7148:    { "Canon PowerShot A5", 0, 0,
        -: 7149:	{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },
        -: 7150:    { "Canon PowerShot G10", 0, 0,
        -: 7151:	{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },
        -: 7152:    { "Canon PowerShot G11", 0, 0,
        -: 7153:	{ 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },
        -: 7154:    { "Canon PowerShot G12", 0, 0,
        -: 7155:	{ 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },
        -: 7156:    { "Canon PowerShot G15", 0, 0,
        -: 7157:	{ 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },
        -: 7158:    { "Canon PowerShot G16", 0, 0,
        -: 7159:	{ 8020,-2687,-682,-3704,11879,2052,-965,1921,5556 } },
        -: 7160:    { "Canon PowerShot G1 X", 0, 0,
        -: 7161:	{ 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },
        -: 7162:    { "Canon PowerShot G1", 0, 0,
        -: 7163:	{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },
        -: 7164:    { "Canon PowerShot G2", 0, 0,
        -: 7165:	{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },
        -: 7166:    { "Canon PowerShot G3 X", 0, 0,
        -: 7167:	{ 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },
        -: 7168:    { "Canon PowerShot G3", 0, 0,
        -: 7169:	{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },
        -: 7170:    { "Canon PowerShot G5 X", 0, 0,
        -: 7171:	{ 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
        -: 7172:    { "Canon PowerShot G5", 0, 0,
        -: 7173:	{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },
        -: 7174:    { "Canon PowerShot G6", 0, 0,
        -: 7175:	{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },
        -: 7176:    { "Canon PowerShot G7 X", 0, 0,
        -: 7177:	{ 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
        -: 7178:    { "Canon PowerShot G9 X", 0, 0,
        -: 7179:	{ 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
        -: 7180:    { "Canon PowerShot G9", 0, 0,
        -: 7181:	{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },
        -: 7182:    { "Canon PowerShot Pro1", 0, 0,
        -: 7183:	{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },
        -: 7184:    { "Canon PowerShot Pro70", 34, 0,
        -: 7185:	{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },
        -: 7186:    { "Canon PowerShot Pro90", 0, 0,
        -: 7187:	{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },
        -: 7188:    { "Canon PowerShot S30", 0, 0,
        -: 7189:	{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },
        -: 7190:    { "Canon PowerShot S40", 0, 0,
        -: 7191:	{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },
        -: 7192:    { "Canon PowerShot S45", 0, 0,
        -: 7193:	{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },
        -: 7194:    { "Canon PowerShot S50", 0, 0,
        -: 7195:	{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },
        -: 7196:    { "Canon PowerShot S60", 0, 0,
        -: 7197:	{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },
        -: 7198:    { "Canon PowerShot S70", 0, 0,
        -: 7199:	{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },
        -: 7200:    { "Canon PowerShot S90", 0, 0,
        -: 7201:	{ 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },
        -: 7202:    { "Canon PowerShot S95", 0, 0,
        -: 7203:	{ 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },
        -: 7204:    { "Canon PowerShot S100", 0, 0,
        -: 7205:	{ 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },
        -: 7206:    { "Canon PowerShot S110", 0, 0,
        -: 7207:	{ 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },
        -: 7208:    { "Canon PowerShot S120", 0, 0,
        -: 7209:	{ 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },
        -: 7210:    { "Canon PowerShot SX1 IS", 0, 0,
        -: 7211:	{ 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },
        -: 7212:    { "Canon PowerShot SX50 HS", 0, 0,
        -: 7213:	{ 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },
        -: 7214:    { "Canon PowerShot SX60 HS", 0, 0,
        -: 7215:	{ 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },
        -: 7216:    { "Canon PowerShot A3300", 0, 0,	/* DJC */
        -: 7217:	{ 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },
        -: 7218:    { "Canon PowerShot A470", 0, 0,	/* DJC */
        -: 7219:	{ 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },
        -: 7220:    { "Canon PowerShot A610", 0, 0,	/* DJC */
        -: 7221:	{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },
        -: 7222:    { "Canon PowerShot A620", 0, 0,	/* DJC */
        -: 7223:	{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },
        -: 7224:    { "Canon PowerShot A630", 0, 0,	/* DJC */
        -: 7225:	{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },
        -: 7226:    { "Canon PowerShot A640", 0, 0,	/* DJC */
        -: 7227:	{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },
        -: 7228:    { "Canon PowerShot A650", 0, 0,	/* DJC */
        -: 7229:	{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },
        -: 7230:    { "Canon PowerShot A720", 0, 0,	/* DJC */
        -: 7231:	{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },
        -: 7232:    { "Canon PowerShot S3 IS", 0, 0,	/* DJC */
        -: 7233:	{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },
        -: 7234:    { "Canon PowerShot SX110 IS", 0, 0,	/* DJC */
        -: 7235:	{ 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },
        -: 7236:    { "Canon PowerShot SX220", 0, 0,	/* DJC */
        -: 7237:	{ 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },
        -: 7238:    { "Canon IXUS 160", 0, 0,		/* DJC */
        -: 7239:	{ 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },
        -: 7240:    { "Casio EX-S20", 0, 0,		/* DJC */
        -: 7241:	{ 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },
        -: 7242:    { "Casio EX-Z750", 0, 0,		/* DJC */
        -: 7243:	{ 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },
        -: 7244:    { "Casio EX-Z10", 128, 0xfff,	/* DJC */
        -: 7245:	{ 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },
        -: 7246:    { "CINE 650", 0, 0,
        -: 7247:	{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },
        -: 7248:    { "CINE 660", 0, 0,
        -: 7249:	{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },
        -: 7250:    { "CINE", 0, 0,
        -: 7251:	{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },
        -: 7252:    { "Contax N Digital", 0, 0xf1e,
        -: 7253:	{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },
        -: 7254:    { "DXO ONE", 0, 0,
        -: 7255:	{ 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },
        -: 7256:    { "Epson R-D1", 0, 0,
        -: 7257:	{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },
        -: 7258:    { "Fujifilm E550", 0, 0,
        -: 7259:	{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },
        -: 7260:    { "Fujifilm E900", 0, 0,
        -: 7261:	{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },
        -: 7262:    { "Fujifilm F5", 0, 0,
        -: 7263:	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
        -: 7264:    { "Fujifilm F6", 0, 0,
        -: 7265:	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
        -: 7266:    { "Fujifilm F77", 0, 0xfe9,
        -: 7267:	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
        -: 7268:    { "Fujifilm F7", 0, 0,
        -: 7269:	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
        -: 7270:    { "Fujifilm F8", 0, 0,
        -: 7271:	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
        -: 7272:    { "Fujifilm S100FS", 514, 0,
        -: 7273:	{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },
        -: 7274:    { "Fujifilm S1", 0, 0,
        -: 7275:	{ 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },
        -: 7276:    { "Fujifilm S20Pro", 0, 0,
        -: 7277:	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
        -: 7278:    { "Fujifilm S20", 512, 0x3fff,
        -: 7279:	{ 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },
        -: 7280:    { "Fujifilm S2Pro", 128, 0,
        -: 7281:	{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },
        -: 7282:    { "Fujifilm S3Pro", 0, 0,
        -: 7283:	{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },
        -: 7284:    { "Fujifilm S5Pro", 0, 0,
        -: 7285:	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
        -: 7286:    { "Fujifilm S5000", 0, 0,
        -: 7287:	{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },
        -: 7288:    { "Fujifilm S5100", 0, 0,
        -: 7289:	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
        -: 7290:    { "Fujifilm S5500", 0, 0,
        -: 7291:	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
        -: 7292:    { "Fujifilm S5200", 0, 0,
        -: 7293:	{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
        -: 7294:    { "Fujifilm S5600", 0, 0,
        -: 7295:	{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
        -: 7296:    { "Fujifilm S6", 0, 0,
        -: 7297:	{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },
        -: 7298:    { "Fujifilm S7000", 0, 0,
        -: 7299:	{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },
        -: 7300:    { "Fujifilm S9000", 0, 0,
        -: 7301:	{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },
        -: 7302:    { "Fujifilm S9500", 0, 0,
        -: 7303:	{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },
        -: 7304:    { "Fujifilm S9100", 0, 0,
        -: 7305:	{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },
        -: 7306:    { "Fujifilm S9600", 0, 0,
        -: 7307:	{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },
        -: 7308:    { "Fujifilm SL1000", 0, 0,
        -: 7309:	{ 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },
        -: 7310:    { "Fujifilm IS-1", 0, 0,
        -: 7311:	{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },
        -: 7312:    { "Fujifilm IS Pro", 0, 0,
        -: 7313:	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
        -: 7314:    { "Fujifilm HS10 HS11", 0, 0xf68,
        -: 7315:	{ 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },
        -: 7316:    { "Fujifilm HS2", 0, 0,
        -: 7317:	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
        -: 7318:    { "Fujifilm HS3", 0, 0,
        -: 7319:	{ 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
        -: 7320:    { "Fujifilm HS50EXR", 0, 0,
        -: 7321:	{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },
        -: 7322:    { "Fujifilm F900EXR", 0, 0,
        -: 7323:	{ 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },
        -: 7324:    { "Fujifilm X100S", 0, 0,
        -: 7325:	{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },
        -: 7326:    { "Fujifilm X100T", 0, 0,
        -: 7327:	{ 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },
        -: 7328:    { "Fujifilm X100", 0, 0,
        -: 7329:	{ 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },
        -: 7330:    { "Fujifilm X10", 0, 0,
        -: 7331:	{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
        -: 7332:    { "Fujifilm X20", 0, 0,
        -: 7333:	{ 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },
        -: 7334:    { "Fujifilm X30", 0, 0,
        -: 7335:	{ 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },
        -: 7336:    { "Fujifilm X70", 0, 0,
        -: 7337:	{ 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },
        -: 7338:    { "Fujifilm X-Pro1", 0, 0,
        -: 7339:	{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
        -: 7340:    { "Fujifilm X-Pro2", 0, 0,
        -: 7341:	{ 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
        -: 7342:    { "Fujifilm X-A1", 0, 0,
        -: 7343:	{ 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },
        -: 7344:    { "Fujifilm X-A2", 0, 0,
        -: 7345:	{ 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },
        -: 7346:    { "Fujifilm X-E1", 0, 0,
        -: 7347:	{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
        -: 7348:    { "Fujifilm X-E2S", 0, 0,
        -: 7349:	{ 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },
        -: 7350:    { "Fujifilm X-E2", 0, 0,
        -: 7351:	{ 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },
        -: 7352:    { "Fujifilm X-M1", 0, 0,
        -: 7353:	{ 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
        -: 7354:    { "Fujifilm X-S1", 0, 0,
        -: 7355:	{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
        -: 7356:    { "Fujifilm X-T1", 0, 0,	/* also X-T10 */
        -: 7357:	{ 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },
        -: 7358:    { "Fujifilm XF1", 0, 0,
        -: 7359:	{ 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
        -: 7360:    { "Fujifilm XQ", 0, 0,	/* XQ1 and XQ2 */
        -: 7361:	{ 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },
        -: 7362:    { "Imacon Ixpress", 0, 0,		/* DJC */
        -: 7363:	{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },
        -: 7364:    { "Kodak NC2000", 0, 0,
        -: 7365:	{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },
        -: 7366:    { "Kodak DCS315C", 8, 0,
        -: 7367:	{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },
        -: 7368:    { "Kodak DCS330C", 8, 0,
        -: 7369:	{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },
        -: 7370:    { "Kodak DCS420", 0, 0,
        -: 7371:	{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },
        -: 7372:    { "Kodak DCS460", 0, 0,
        -: 7373:	{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
        -: 7374:    { "Kodak EOSDCS1", 0, 0,
        -: 7375:	{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
        -: 7376:    { "Kodak EOSDCS3B", 0, 0,
        -: 7377:	{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },
        -: 7378:    { "Kodak DCS520C", 178, 0,
        -: 7379:	{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },
        -: 7380:    { "Kodak DCS560C", 177, 0,
        -: 7381:	{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },
        -: 7382:    { "Kodak DCS620C", 177, 0,
        -: 7383:	{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },
        -: 7384:    { "Kodak DCS620X", 176, 0,
        -: 7385:	{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },
        -: 7386:    { "Kodak DCS660C", 173, 0,
        -: 7387:	{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },
        -: 7388:    { "Kodak DCS720X", 0, 0,
        -: 7389:	{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },
        -: 7390:    { "Kodak DCS760C", 0, 0,
        -: 7391:	{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },
        -: 7392:    { "Kodak DCS Pro SLR", 0, 0,
        -: 7393:	{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
        -: 7394:    { "Kodak DCS Pro 14nx", 0, 0,
        -: 7395:	{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
        -: 7396:    { "Kodak DCS Pro 14", 0, 0,
        -: 7397:	{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },
        -: 7398:    { "Kodak ProBack645", 0, 0,
        -: 7399:	{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },
        -: 7400:    { "Kodak ProBack", 0, 0,
        -: 7401:	{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },
        -: 7402:    { "Kodak P712", 0, 0,
        -: 7403:	{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },
        -: 7404:    { "Kodak P850", 0, 0xf7c,
        -: 7405:	{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },
        -: 7406:    { "Kodak P880", 0, 0xfff,
        -: 7407:	{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },
        -: 7408:    { "Kodak EasyShare Z980", 0, 0,
        -: 7409:	{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },
        -: 7410:    { "Kodak EasyShare Z981", 0, 0,
        -: 7411:	{ 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },
        -: 7412:    { "Kodak EasyShare Z990", 0, 0xfed,
        -: 7413:	{ 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },
        -: 7414:    { "Kodak EASYSHARE Z1015", 0, 0xef1,
        -: 7415:	{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },
        -: 7416:    { "Leaf CMost", 0, 0,
        -: 7417:	{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },
        -: 7418:    { "Leaf Valeo 6", 0, 0,
        -: 7419:	{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },
        -: 7420:    { "Leaf Aptus 54S", 0, 0,
        -: 7421:	{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },
        -: 7422:    { "Leaf Aptus 65", 0, 0,
        -: 7423:	{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
        -: 7424:    { "Leaf Aptus 75", 0, 0,
        -: 7425:	{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
        -: 7426:    { "Leaf", 0, 0,
        -: 7427:	{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },
        -: 7428:    { "Mamiya ZD", 0, 0,
        -: 7429:	{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },
        -: 7430:    { "Micron 2010", 110, 0,		/* DJC */
        -: 7431:	{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },
        -: 7432:    { "Minolta DiMAGE 5", 0, 0xf7d,
        -: 7433:	{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },
        -: 7434:    { "Minolta DiMAGE 7Hi", 0, 0xf7d,
        -: 7435:	{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },
        -: 7436:    { "Minolta DiMAGE 7", 0, 0xf7d,
        -: 7437:	{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },
        -: 7438:    { "Minolta DiMAGE A1", 0, 0xf8b,
        -: 7439:	{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },
        -: 7440:    { "Minolta DiMAGE A200", 0, 0,
        -: 7441:	{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },
        -: 7442:    { "Minolta DiMAGE A2", 0, 0xf8f,
        -: 7443:	{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },
        -: 7444:    { "Minolta DiMAGE Z2", 0, 0,	/* DJC */
        -: 7445:	{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },
        -: 7446:    { "Minolta DYNAX 5", 0, 0xffb,
        -: 7447:	{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },
        -: 7448:    { "Minolta DYNAX 7", 0, 0xffb,
        -: 7449:	{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },
        -: 7450:    { "Motorola PIXL", 0, 0,		/* DJC */
        -: 7451:	{ 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },
        -: 7452:    { "Nikon D100", 0, 0,
        -: 7453:	{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },
        -: 7454:    { "Nikon D1H", 0, 0,
        -: 7455:	{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },
        -: 7456:    { "Nikon D1X", 0, 0,
        -: 7457:	{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },
        -: 7458:    { "Nikon D1", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */
        -: 7459:	{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },
        -: 7460:    { "Nikon D200", 0, 0xfbc,
        -: 7461:	{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },
        -: 7462:    { "Nikon D2H", 0, 0,
        -: 7463:	{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },
        -: 7464:    { "Nikon D2X", 0, 0,
        -: 7465:	{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },
        -: 7466:    { "Nikon D3000", 0, 0,
        -: 7467:	{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
        -: 7468:    { "Nikon D3100", 0, 0,
        -: 7469:	{ 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },
        -: 7470:    { "Nikon D3200", 0, 0xfb9,
        -: 7471:	{ 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },
        -: 7472:    { "Nikon D3300", 0, 0,
        -: 7473:	{ 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
        -: 7474:    { "Nikon D300", 0, 0,
        -: 7475:	{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },
        -: 7476:    { "Nikon D3X", 0, 0,
        -: 7477:	{ 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },
        -: 7478:    { "Nikon D3S", 0, 0,
        -: 7479:	{ 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },
        -: 7480:    { "Nikon D3", 0, 0,
        -: 7481:	{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
        -: 7482:    { "Nikon D40X", 0, 0,
        -: 7483:	{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },
        -: 7484:    { "Nikon D40", 0, 0,
        -: 7485:	{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },
        -: 7486:    { "Nikon D4S", 0, 0,
        -: 7487:	{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
        -: 7488:    { "Nikon D4", 0, 0,
        -: 7489:	{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
        -: 7490:    { "Nikon Df", 0, 0,
        -: 7491:	{ 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
        -: 7492:    { "Nikon D5000", 0, 0xf00,
        -: 7493:	{ 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },
        -: 7494:    { "Nikon D5100", 0, 0x3de6,
        -: 7495:	{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
        -: 7496:    { "Nikon D5200", 0, 0,
        -: 7497:	{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
        -: 7498:    { "Nikon D5300", 0, 0,
        -: 7499:	{ 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
        -: 7500:    { "Nikon D5500", 0, 0,
        -: 7501:	{ 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },
        -: 7502:    { "Nikon D500", 0, 0,
        -: 7503:	{ 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },
        -: 7504:    { "Nikon D50", 0, 0,
        -: 7505:	{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
        -: 7506:    { "Nikon D5", 0, 0,
        -: 7507:	{ 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },
        -: 7508:    { "Nikon D600", 0, 0x3e07,
        -: 7509:	{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },
        -: 7510:    { "Nikon D610", 0, 0,
        -: 7511:	{ 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },
        -: 7512:    { "Nikon D60", 0, 0,
        -: 7513:	{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
        -: 7514:    { "Nikon D7000", 0, 0,
        -: 7515:	{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
        -: 7516:    { "Nikon D7100", 0, 0,
        -: 7517:	{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
        -: 7518:    { "Nikon D7200", 0, 0,
        -: 7519:	{ 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
        -: 7520:    { "Nikon D750", 0, 0,
        -: 7521:	{ 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },
        -: 7522:    { "Nikon D700", 0, 0,
        -: 7523:	{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
        -: 7524:    { "Nikon D70", 0, 0,
        -: 7525:	{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
        -: 7526:    { "Nikon D810", 0, 0,
        -: 7527:	{ 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },
        -: 7528:    { "Nikon D800", 0, 0,
        -: 7529:	{ 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },
        -: 7530:    { "Nikon D80", 0, 0,
        -: 7531:	{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },
        -: 7532:    { "Nikon D90", 0, 0xf00,
        -: 7533:	{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },
        -: 7534:    { "Nikon E700", 0, 0x3dd,		/* DJC */
        -: 7535:	{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },
        -: 7536:    { "Nikon E800", 0, 0x3dd,		/* DJC */
        -: 7537:	{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },
        -: 7538:    { "Nikon E950", 0, 0x3dd,		/* DJC */
        -: 7539:	{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },
        -: 7540:    { "Nikon E995", 0, 0,	/* copied from E5000 */
        -: 7541:	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
        -: 7542:    { "Nikon E2100", 0, 0,	/* copied from Z2, new white balance */
        -: 7543:	{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },
        -: 7544:    { "Nikon E2500", 0, 0,
        -: 7545:	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
        -: 7546:    { "Nikon E3200", 0, 0,		/* DJC */
        -: 7547:	{ 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },
        -: 7548:    { "Nikon E4300", 0, 0,	/* copied from Minolta DiMAGE Z2 */
        -: 7549:	{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },
        -: 7550:    { "Nikon E4500", 0, 0,
        -: 7551:	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
        -: 7552:    { "Nikon E5000", 0, 0,
        -: 7553:	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
        -: 7554:    { "Nikon E5400", 0, 0,
        -: 7555:	{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },
        -: 7556:    { "Nikon E5700", 0, 0,
        -: 7557:	{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },
        -: 7558:    { "Nikon E8400", 0, 0,
        -: 7559:	{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },
        -: 7560:    { "Nikon E8700", 0, 0,
        -: 7561:	{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },
        -: 7562:    { "Nikon E8800", 0, 0,
        -: 7563:	{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },
        -: 7564:    { "Nikon COOLPIX A", 0, 0,
        -: 7565:	{ 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
        -: 7566:    { "Nikon COOLPIX P330", 200, 0,
        -: 7567:	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
        -: 7568:    { "Nikon COOLPIX P340", 200, 0,
        -: 7569:	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
        -: 7570:    { "Nikon COOLPIX P6000", 0, 0,
        -: 7571:	{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },
        -: 7572:    { "Nikon COOLPIX P7000", 0, 0,
        -: 7573:	{ 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },
        -: 7574:    { "Nikon COOLPIX P7100", 0, 0,
        -: 7575:	{ 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },
        -: 7576:    { "Nikon COOLPIX P7700", 200, 0,
        -: 7577:	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
        -: 7578:    { "Nikon COOLPIX P7800", 200, 0,
        -: 7579:	{ 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
        -: 7580:    { "Nikon 1 V3", 0, 0,
        -: 7581:	{ 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },
        -: 7582:    { "Nikon 1 J4", 0, 0,
        -: 7583:	{ 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },
        -: 7584:    { "Nikon 1 J5", 0, 0,
        -: 7585:	{ 7520,-2518,-645,-3844,12102,1945,-913,2249,6835 } },
        -: 7586:    { "Nikon 1 S2", 200, 0,
        -: 7587:	{ 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },
        -: 7588:    { "Nikon 1 V2", 0, 0,
        -: 7589:	{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
        -: 7590:    { "Nikon 1 J3", 0, 0,
        -: 7591:	{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
        -: 7592:    { "Nikon 1 AW1", 0, 0,
        -: 7593:	{ 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
        -: 7594:    { "Nikon 1 ", 0, 0,		/* J1, J2, S1, V1 */
        -: 7595:	{ 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },
        -: 7596:    { "Olympus AIR A01", 0, 0,
        -: 7597:	{ 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },
        -: 7598:    { "Olympus C5050", 0, 0,
        -: 7599:	{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },
        -: 7600:    { "Olympus C5060", 0, 0,
        -: 7601:	{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },
        -: 7602:    { "Olympus C7070", 0, 0,
        -: 7603:	{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },
        -: 7604:    { "Olympus C70", 0, 0,
        -: 7605:	{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },
        -: 7606:    { "Olympus C80", 0, 0,
        -: 7607:	{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },
        -: 7608:    { "Olympus E-10", 0, 0xffc,
        -: 7609:	{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },
        -: 7610:    { "Olympus E-1", 0, 0,
        -: 7611:	{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },
        -: 7612:    { "Olympus E-20", 0, 0xffc,
        -: 7613:	{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },
        -: 7614:    { "Olympus E-300", 0, 0,
        -: 7615:	{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },
        -: 7616:    { "Olympus E-330", 0, 0,
        -: 7617:	{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },
        -: 7618:    { "Olympus E-30", 0, 0xfbc,
        -: 7619:	{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },
        -: 7620:    { "Olympus E-3", 0, 0xf99,
        -: 7621:	{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },
        -: 7622:    { "Olympus E-400", 0, 0,
        -: 7623:	{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },
        -: 7624:    { "Olympus E-410", 0, 0xf6a,
        -: 7625:	{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },
        -: 7626:    { "Olympus E-420", 0, 0xfd7,
        -: 7627:	{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },
        -: 7628:    { "Olympus E-450", 0, 0xfd2,
        -: 7629:	{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },
        -: 7630:    { "Olympus E-500", 0, 0,
        -: 7631:	{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },
        -: 7632:    { "Olympus E-510", 0, 0xf6a,
        -: 7633:	{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },
        -: 7634:    { "Olympus E-520", 0, 0xfd2,
        -: 7635:	{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },
        -: 7636:    { "Olympus E-5", 0, 0xeec,
        -: 7637:	{ 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },
        -: 7638:    { "Olympus E-600", 0, 0xfaf,
        -: 7639:	{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
        -: 7640:    { "Olympus E-620", 0, 0xfaf,
        -: 7641:	{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
        -: 7642:    { "Olympus E-P1", 0, 0xffd,
        -: 7643:	{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
        -: 7644:    { "Olympus E-P2", 0, 0xffd,
        -: 7645:	{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
        -: 7646:    { "Olympus E-P3", 0, 0,
        -: 7647:	{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
        -: 7648:    { "Olympus E-P5", 0, 0,
        -: 7649:	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
        -: 7650:    { "Olympus E-PL1s", 0, 0,
        -: 7651:	{ 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },
        -: 7652:    { "Olympus E-PL1", 0, 0,
        -: 7653:	{ 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },
        -: 7654:    { "Olympus E-PL2", 0, 0xcf3,
        -: 7655:	{ 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },
        -: 7656:    { "Olympus E-PL3", 0, 0,
        -: 7657:	{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
        -: 7658:    { "Olympus E-PL5", 0, 0xfcb,
        -: 7659:	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
        -: 7660:    { "Olympus E-PL6", 0, 0,
        -: 7661:	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
        -: 7662:    { "Olympus E-PL7", 0, 0,
        -: 7663:	{ 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },
        -: 7664:    { "Olympus E-PM1", 0, 0,
        -: 7665:	{ 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
        -: 7666:    { "Olympus E-PM2", 0, 0,
        -: 7667:	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
        -: 7668:    { "Olympus E-M10", 0, 0,	/* also E-M10 Mark II */
        -: 7669:	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
        -: 7670:    { "Olympus E-M1", 0, 0,
        -: 7671:	{ 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },
        -: 7672:    { "Olympus E-M5MarkII", 0, 0,
        -: 7673:	{ 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },
        -: 7674:    { "Olympus E-M5", 0, 0xfe1,
        -: 7675:	{ 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
        -: 7676:    { "Olympus PEN-F", 0, 0,
        -: 7677:	{ 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },
        -: 7678:    { "Olympus SH-2", 0, 0,
        -: 7679:	{ 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },
        -: 7680:    { "Olympus SP350", 0, 0,
        -: 7681:	{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },
        -: 7682:    { "Olympus SP3", 0, 0,
        -: 7683:	{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },
        -: 7684:    { "Olympus SP500UZ", 0, 0xfff,
        -: 7685:	{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },
        -: 7686:    { "Olympus SP510UZ", 0, 0xffe,
        -: 7687:	{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },
        -: 7688:    { "Olympus SP550UZ", 0, 0xffe,
        -: 7689:	{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },
        -: 7690:    { "Olympus SP560UZ", 0, 0xff9,
        -: 7691:	{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },
        -: 7692:    { "Olympus SP570UZ", 0, 0,
        -: 7693:	{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },
        -: 7694:    { "Olympus STYLUS1", 0, 0,
        -: 7695:	{ 8360,-2420,-880,-3928,12353,1739,-1381,2416,5173 } },
        -: 7696:    { "Olympus TG-4", 0, 0,
        -: 7697:	{ 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },
        -: 7698:    { "Olympus XZ-10", 0, 0,
        -: 7699:	{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },
        -: 7700:    { "Olympus XZ-1", 0, 0,
        -: 7701:	{ 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },
        -: 7702:    { "Olympus XZ-2", 0, 0,
        -: 7703:	{ 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },
        -: 7704:    { "OmniVision", 0, 0,		/* DJC */
        -: 7705:	{ 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } },
        -: 7706:    { "Pentax *ist DL2", 0, 0,
        -: 7707:	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
        -: 7708:    { "Pentax *ist DL", 0, 0,
        -: 7709:	{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },
        -: 7710:    { "Pentax *ist DS2", 0, 0,
        -: 7711:	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
        -: 7712:    { "Pentax *ist DS", 0, 0,
        -: 7713:	{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },
        -: 7714:    { "Pentax *ist D", 0, 0,
        -: 7715:	{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },
        -: 7716:    { "Pentax K10D", 0, 0,
        -: 7717:	{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },
        -: 7718:    { "Pentax K1", 0, 0,
        -: 7719:	{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },
        -: 7720:    { "Pentax K20D", 0, 0,
        -: 7721:	{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },
        -: 7722:    { "Pentax K200D", 0, 0,
        -: 7723:	{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },
        -: 7724:    { "Pentax K2000", 0, 0,
        -: 7725:	{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },
        -: 7726:    { "Pentax K-m", 0, 0,
        -: 7727:	{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },
        -: 7728:    { "Pentax K-x", 0, 0,
        -: 7729:	{ 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },
        -: 7730:    { "Pentax K-r", 0, 0,
        -: 7731:	{ 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },
        -: 7732:    { "Pentax K-1", 0, 0,
        -: 7733:	{ 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },
        -: 7734:    { "Pentax K-30", 0, 0,
        -: 7735:	{ 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },
        -: 7736:    { "Pentax K-3 II", 0, 0,
        -: 7737:	{ 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },
        -: 7738:    { "Pentax K-3", 0, 0,
        -: 7739:	{ 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },
        -: 7740:    { "Pentax K-5 II", 0, 0,
        -: 7741:	{ 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },
        -: 7742:    { "Pentax K-5", 0, 0,
        -: 7743:	{ 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },
        -: 7744:    { "Pentax K-7", 0, 0,
        -: 7745:	{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },
        -: 7746:    { "Pentax K-S1", 0, 0,
        -: 7747:	{ 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },
        -: 7748:    { "Pentax K-S2", 0, 0,
        -: 7749:	{ 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },
        -: 7750:    { "Pentax Q-S1", 0, 0,
        -: 7751:	{ 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },
        -: 7752:    { "Pentax 645D", 0, 0x3e00,
        -: 7753:	{ 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },
        -: 7754:    { "Panasonic DMC-CM1", 15, 0,
        -: 7755:	{ 8770,-3194,-820,-2871,11281,1803,-513,1552,4434 } },
        -: 7756:    { "Panasonic DMC-FZ8", 0, 0xf7f,
        -: 7757:	{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },
        -: 7758:    { "Panasonic DMC-FZ18", 0, 0,
        -: 7759:	{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },
        -: 7760:    { "Panasonic DMC-FZ28", 15, 0xf96,
        -: 7761:	{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },
        -: 7762:    { "Panasonic DMC-FZ330", 15, 0,
        -: 7763:	{ 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },
        -: 7764:    { "Panasonic DMC-FZ300", 15, 0,
        -: 7765:	{ 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },
        -: 7766:    { "Panasonic DMC-FZ30", 0, 0xf94,
        -: 7767:	{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },
        -: 7768:    { "Panasonic DMC-FZ3", 15, 0,
        -: 7769:	{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },
        -: 7770:    { "Panasonic DMC-FZ4", 15, 0,
        -: 7771:	{ 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },
        -: 7772:    { "Panasonic DMC-FZ50", 0, 0,
        -: 7773:	{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },
        -: 7774:    { "Panasonic DMC-FZ7", 15, 0,
        -: 7775:	{ 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },
        -: 7776:    { "Leica V-LUX1", 0, 0,
        -: 7777:	{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },
        -: 7778:    { "Panasonic DMC-L10", 15, 0xf96,
        -: 7779:	{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },
        -: 7780:    { "Panasonic DMC-L1", 0, 0xf7f,
        -: 7781:	{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },
        -: 7782:    { "Leica DIGILUX 3", 0, 0xf7f,
        -: 7783:	{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },
        -: 7784:    { "Panasonic DMC-LC1", 0, 0,
        -: 7785:	{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },
        -: 7786:    { "Leica DIGILUX 2", 0, 0,
        -: 7787:	{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },
        -: 7788:    { "Panasonic DMC-LX100", 15, 0,
        -: 7789:	{ 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },
        -: 7790:    { "Leica D-LUX (Typ 109)", 15, 0,
        -: 7791:	{ 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },
        -: 7792:    { "Panasonic DMC-LF1", 15, 0,
        -: 7793:	{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },
        -: 7794:    { "Leica C (Typ 112)", 15, 0,
        -: 7795:	{ 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },
        -: 7796:    { "Panasonic DMC-LX1", 0, 0xf7f,
        -: 7797:	{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },
        -: 7798:    { "Leica D-LUX2", 0, 0xf7f,
        -: 7799:	{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },
        -: 7800:    { "Panasonic DMC-LX2", 0, 0,
        -: 7801:	{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },
        -: 7802:    { "Leica D-LUX3", 0, 0,
        -: 7803:	{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },
        -: 7804:    { "Panasonic DMC-LX3", 15, 0,
        -: 7805:	{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },
        -: 7806:    { "Leica D-LUX 4", 15, 0,
        -: 7807:	{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },
        -: 7808:    { "Panasonic DMC-LX5", 15, 0,
        -: 7809:	{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },
        -: 7810:    { "Leica D-LUX 5", 15, 0,
        -: 7811:	{ 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },
        -: 7812:    { "Panasonic DMC-LX7", 15, 0,
        -: 7813:	{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },
        -: 7814:    { "Leica D-LUX 6", 15, 0,
        -: 7815:	{ 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },
        -: 7816:    { "Panasonic DMC-FZ1000", 15, 0,
        -: 7817:	{ 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },
        -: 7818:    { "Leica V-LUX (Typ 114)", 15, 0,
        -: 7819:	{ 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },
        -: 7820:    { "Panasonic DMC-FZ100", 15, 0xfff,
        -: 7821:	{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },
        -: 7822:    { "Leica V-LUX 2", 15, 0xfff,
        -: 7823:	{ 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },
        -: 7824:    { "Panasonic DMC-FZ150", 15, 0xfff,
        -: 7825:	{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },
        -: 7826:    { "Leica V-LUX 3", 15, 0xfff,
        -: 7827:	{ 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },
        -: 7828:    { "Panasonic DMC-FZ200", 15, 0xfff,
        -: 7829:	{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },
        -: 7830:    { "Leica V-LUX 4", 15, 0xfff,
        -: 7831:	{ 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },
        -: 7832:    { "Panasonic DMC-FX150", 15, 0xfff,
        -: 7833:	{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },
        -: 7834:    { "Panasonic DMC-G10", 0, 0,
        -: 7835:	{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
        -: 7836:    { "Panasonic DMC-G1", 15, 0xf94,
        -: 7837:	{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },
        -: 7838:    { "Panasonic DMC-G2", 15, 0xf3c,
        -: 7839:	{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
        -: 7840:    { "Panasonic DMC-G3", 15, 0xfff,
        -: 7841:	{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },
        -: 7842:    { "Panasonic DMC-G5", 15, 0xfff,
        -: 7843:	{ 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },
        -: 7844:    { "Panasonic DMC-G6", 15, 0xfff,
        -: 7845:	{ 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },
        -: 7846:    { "Panasonic DMC-G7", 15, 0xfff,
        -: 7847:	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
        -: 7848:    { "Panasonic DMC-GF1", 15, 0xf92,
        -: 7849:	{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
        -: 7850:    { "Panasonic DMC-GF2", 15, 0xfff,
        -: 7851:	{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
        -: 7852:    { "Panasonic DMC-GF3", 15, 0xfff,
        -: 7853:	{ 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },
        -: 7854:    { "Panasonic DMC-GF5", 15, 0xfff,
        -: 7855:	{ 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },
        -: 7856:    { "Panasonic DMC-GF6", 15, 0,
        -: 7857:	{ 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },
        -: 7858:    { "Panasonic DMC-GF7", 15, 0,
        -: 7859:	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
        -: 7860:    { "Panasonic DMC-GF8", 15, 0,
        -: 7861:	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
        -: 7862:    { "Panasonic DMC-GH1", 15, 0xf92,
        -: 7863:	{ 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },
        -: 7864:    { "Panasonic DMC-GH2", 15, 0xf95,
        -: 7865:	{ 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },
        -: 7866:    { "Panasonic DMC-GH3", 15, 0,
        -: 7867:	{ 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },
        -: 7868:    { "Panasonic DMC-GH4", 15, 0,
        -: 7869:	{ 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },
        -: 7870:    { "Panasonic DMC-GM1", 15, 0,
        -: 7871:	{ 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },
        -: 7872:    { "Panasonic DMC-GM5", 15, 0,
        -: 7873:	{ 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },
        -: 7874:    { "Panasonic DMC-GX1", 15, 0,
        -: 7875:	{ 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },
        -: 7876:    { "Panasonic DMC-GX7", 15, 0,
        -: 7877:	{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
        -: 7878:    { "Panasonic DMC-GX8", 15, 0,
        -: 7879:	{ 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },
        -: 7880:    { "Panasonic DMC-TZ1", 15, 0,
        -: 7881:	{ 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
        -: 7882:    { "Panasonic DMC-ZS1", 15, 0,
        -: 7883:	{ 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
        -: 7884:    { "Panasonic DMC-TZ6", 15, 0,
        -: 7885:	{ 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },
        -: 7886:    { "Panasonic DMC-ZS4", 15, 0,
        -: 7887:	{ 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },
        -: 7888:    { "Panasonic DMC-TZ7", 15, 0,
        -: 7889:	{ 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },
        -: 7890:    { "Panasonic DMC-ZS5", 15, 0,
        -: 7891:	{ 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },
        -: 7892:    { "Panasonic DMC-TZ8", 15, 0,
        -: 7893:	{ 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },
        -: 7894:    { "Panasonic DMC-ZS6", 15, 0,
        -: 7895:	{ 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },
        -: 7896:    { "Leica S (Typ 007)", 0, 0,
        -: 7897:	{ 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },
        -: 7898:    { "Leica X", 0, 0,		/* X and X-U, both (Typ 113) */
        -: 7899:	{ 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },
        -: 7900:    { "Leica Q (Typ 116)", 0, 0,
        -: 7901:	{ 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },
        -: 7902:    { "Leica M (Typ 262)", 0, 0,
        -: 7903:	{ 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },
        -: 7904:    { "Leica SL (Typ 601)", 0, 0,
        -: 7905:	{ 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },
        -: 7906:    { "Phase One H 20", 0, 0,		/* DJC */
        -: 7907:	{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },
        -: 7908:    { "Phase One H 25", 0, 0,
        -: 7909:	{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },
        -: 7910:    { "Phase One P 2", 0, 0,
        -: 7911:	{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },
        -: 7912:    { "Phase One P 30", 0, 0,
        -: 7913:	{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },
        -: 7914:    { "Phase One P 45", 0, 0,
        -: 7915:	{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },
        -: 7916:    { "Phase One P40", 0, 0,
        -: 7917:	{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
        -: 7918:    { "Phase One P65", 0, 0,
        -: 7919:	{ 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
        -: 7920:    { "Photron BC2-HD", 0, 0,		/* DJC */
        -: 7921:	{ 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },
        -: 7922:    { "Red One", 704, 0xffff,		/* DJC */
        -: 7923:	{ 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },
        -: 7924:    { "Ricoh GR II", 0, 0,
        -: 7925:	{ 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },
        -: 7926:    { "Ricoh GR", 0, 0,
        -: 7927:	{ 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },
        -: 7928:    { "Samsung EX1", 0, 0x3e00,
        -: 7929:	{ 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },
        -: 7930:    { "Samsung EX2F", 0, 0x7ff,
        -: 7931:	{ 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },
        -: 7932:    { "Samsung EK-GN120", 0, 0,
        -: 7933:	{ 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
        -: 7934:    { "Samsung NX mini", 0, 0,
        -: 7935:	{ 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },
        -: 7936:    { "Samsung NX3300", 0, 0,
        -: 7937:	{ 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },
        -: 7938:    { "Samsung NX3000", 0, 0,
        -: 7939:	{ 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },
        -: 7940:    { "Samsung NX30", 0, 0,	/* NX30, NX300, NX300M */
        -: 7941:	{ 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
        -: 7942:    { "Samsung NX2000", 0, 0,
        -: 7943:	{ 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
        -: 7944:    { "Samsung NX2", 0, 0xfff,	/* NX20, NX200, NX210 */
        -: 7945:	{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
        -: 7946:    { "Samsung NX1000", 0, 0,
        -: 7947:	{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
        -: 7948:    { "Samsung NX1100", 0, 0,
        -: 7949:	{ 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
        -: 7950:    { "Samsung NX11", 0, 0,
        -: 7951:	{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
        -: 7952:    { "Samsung NX10", 0, 0,	/* also NX100 */
        -: 7953:	{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
        -: 7954:    { "Samsung NX500", 0, 0,
        -: 7955:	{ 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },
        -: 7956:    { "Samsung NX5", 0, 0,
        -: 7957:	{ 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
        -: 7958:    { "Samsung NX1", 0, 0,
        -: 7959:	{ 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },
        -: 7960:    { "Samsung WB2000", 0, 0xfff,
        -: 7961:	{ 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },
        -: 7962:    { "Samsung GX-1", 0, 0,
        -: 7963:	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
        -: 7964:    { "Samsung GX20", 0, 0,	/* copied from Pentax K20D */
        -: 7965:	{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },
        -: 7966:    { "Samsung S85", 0, 0,		/* DJC */
        -: 7967:	{ 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },
        -: 7968:    { "Sinar", 0, 0,			/* DJC */
        -: 7969:	{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },
        -: 7970:    { "Sony DSC-F828", 0, 0,
        -: 7971:	{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },
        -: 7972:    { "Sony DSC-R1", 0, 0,
        -: 7973:	{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },
        -: 7974:    { "Sony DSC-V3", 0, 0,
        -: 7975:	{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },
        -: 7976:    { "Sony DSC-RX100M", 0, 0,		/* M2, M3, and M4 */
        -: 7977:	{ 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },
        -: 7978:    { "Sony DSC-RX100", 0, 0,
        -: 7979:	{ 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },
        -: 7980:    { "Sony DSC-RX10", 0, 0,		/* also RX10M2 */
        -: 7981:	{ 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },
        -: 7982:    { "Sony DSC-RX1RM2", 0, 0,
        -: 7983:	{ 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },
        -: 7984:    { "Sony DSC-RX1", 0, 0,
        -: 7985:	{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
        -: 7986:    { "Sony DSLR-A100", 0, 0xfeb,
        -: 7987:	{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },
        -: 7988:    { "Sony DSLR-A290", 0, 0,
        -: 7989:	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
        -: 7990:    { "Sony DSLR-A2", 0, 0,
        -: 7991:	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
        -: 7992:    { "Sony DSLR-A300", 0, 0,
        -: 7993:	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
        -: 7994:    { "Sony DSLR-A330", 0, 0,
        -: 7995:	{ 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },
        -: 7996:    { "Sony DSLR-A350", 0, 0xffc,
        -: 7997:	{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },
        -: 7998:    { "Sony DSLR-A380", 0, 0,
        -: 7999:	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
        -: 8000:    { "Sony DSLR-A390", 0, 0,
        -: 8001:	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
        -: 8002:    { "Sony DSLR-A450", 0, 0xfeb,
        -: 8003:	{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
        -: 8004:    { "Sony DSLR-A580", 0, 0xfeb,
        -: 8005:	{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },
        -: 8006:    { "Sony DSLR-A500", 0, 0xfeb,
        -: 8007:	{ 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },
        -: 8008:    { "Sony DSLR-A5", 0, 0xfeb,
        -: 8009:	{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
        -: 8010:    { "Sony DSLR-A700", 0, 0,
        -: 8011:	{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },
        -: 8012:    { "Sony DSLR-A850", 0, 0,
        -: 8013:	{ 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },
        -: 8014:    { "Sony DSLR-A900", 0, 0,
        -: 8015:	{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },
        -: 8016:    { "Sony ILCA-68", 0, 0,
        -: 8017:	{ 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },
        -: 8018:    { "Sony ILCA-77M2", 0, 0,
        -: 8019:	{ 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },
        -: 8020:    { "Sony ILCE-6300", 0, 0,
        -: 8021:	{ 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },
        -: 8022:    { "Sony ILCE-7M2", 0, 0,
        -: 8023:	{ 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },
        -: 8024:    { "Sony ILCE-7S", 0, 0,	/* also ILCE-7SM2 */
        -: 8025:	{ 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },
        -: 8026:    { "Sony ILCE-7RM2", 0, 0,
        -: 8027:	{ 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },
        -: 8028:    { "Sony ILCE-7R", 0, 0,
        -: 8029:	{ 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },
        -: 8030:    { "Sony ILCE-7", 0, 0,
        -: 8031:	{ 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },
        -: 8032:    { "Sony ILCE", 0, 0,	/* 3000, 5000, 5100, 6000, and QX1 */
        -: 8033:	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
        -: 8034:    { "Sony NEX-5N", 0, 0,
        -: 8035:	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
        -: 8036:    { "Sony NEX-5R", 0, 0,
        -: 8037:	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
        -: 8038:    { "Sony NEX-5T", 0, 0,
        -: 8039:	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
        -: 8040:    { "Sony NEX-3N", 0, 0,
        -: 8041:	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
        -: 8042:    { "Sony NEX-3", 138, 0,		/* DJC */
        -: 8043:	{ 6907,-1256,-645,-4940,12621,2320,-1710,2581,6230 } },
        -: 8044:    { "Sony NEX-5", 116, 0,		/* DJC */
        -: 8045:	{ 6807,-1350,-342,-4216,11649,2567,-1089,2001,6420 } },
        -: 8046:    { "Sony NEX-3", 0, 0,		/* Adobe */
        -: 8047:	{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },
        -: 8048:    { "Sony NEX-5", 0, 0,		/* Adobe */
        -: 8049:	{ 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },
        -: 8050:    { "Sony NEX-6", 0, 0,
        -: 8051:	{ 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
        -: 8052:    { "Sony NEX-7", 0, 0,
        -: 8053:	{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
        -: 8054:    { "Sony NEX", 0, 0,	/* NEX-C3, NEX-F3 */
        -: 8055:	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
        -: 8056:    { "Sony SLT-A33", 0, 0,
        -: 8057:	{ 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },
        -: 8058:    { "Sony SLT-A35", 0, 0,
        -: 8059:	{ 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },
        -: 8060:    { "Sony SLT-A37", 0, 0,
        -: 8061:	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
        -: 8062:    { "Sony SLT-A55", 0, 0,
        -: 8063:	{ 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },
        -: 8064:    { "Sony SLT-A57", 0, 0,
        -: 8065:	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
        -: 8066:    { "Sony SLT-A58", 0, 0,
        -: 8067:	{ 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
        -: 8068:    { "Sony SLT-A65", 0, 0,
        -: 8069:	{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
        -: 8070:    { "Sony SLT-A77", 0, 0,
        -: 8071:	{ 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
        -: 8072:    { "Sony SLT-A99", 0, 0,
        -: 8073:	{ 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
        -: 8074:  };
        -: 8075:  double cam_xyz[4][3];
        -: 8076:  char name[130];
        -: 8077:  int i, j;
        -: 8078:
        1: 8079:  sprintf (name, "%s %s", make, model);
       51: 8080:  for (i=0; i < sizeof table / sizeof *table; i++)
       51: 8081:    if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {
        1: 8082:      if (table[i].black)   black   = (ushort) table[i].black;
        1: 8083:      if (table[i].maximum) maximum = (ushort) table[i].maximum;
        1: 8084:      if (table[i].trans[0]) {
       13: 8085:	for (raw_color = j=0; j < 12; j++)
       12: 8086:	  ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;
        1: 8087:	cam_xyz_coeff (rgb_cam, cam_xyz);
        -: 8088:      }
        -: 8089:      break;
        -: 8090:    }
        1: 8091:}
        -: 8092:
    #####: 8093:void CLASS simple_coeff (int index)
        -: 8094:{
        -: 8095:  static const float table[][12] = {
        -: 8096:  /* index 0 -- all Foveon cameras */
        -: 8097:  { 1.4032,-0.2231,-0.1016,-0.5263,1.4816,0.017,-0.0112,0.0183,0.9113 },
        -: 8098:  /* index 1 -- Kodak DC20 and DC25 */
        -: 8099:  { 2.25,0.75,-1.75,-0.25,-0.25,0.75,0.75,-0.25,-0.25,-1.75,0.75,2.25 },
        -: 8100:  /* index 2 -- Logitech Fotoman Pixtura */
        -: 8101:  { 1.893,-0.418,-0.476,-0.495,1.773,-0.278,-1.017,-0.655,2.672 },
        -: 8102:  /* index 3 -- Nikon E880, E900, and E990 */
        -: 8103:  { -1.936280,  1.800443, -1.448486,  2.584324,
        -: 8104:     1.405365, -0.524955, -0.289090,  0.408680,
        -: 8105:    -1.204965,  1.082304,  2.941367, -1.818705 }
        -: 8106:  };
        -: 8107:  int i, c;
        -: 8108:
    #####: 8109:  for (raw_color = i=0; i < 3; i++)
    #####: 8110:    FORCC rgb_cam[i][c] = table[index][i*colors+c];
    #####: 8111:}
        -: 8112:
    #####: 8113:short CLASS guess_byte_order (int words)
        -: 8114:{
        -: 8115:  uchar test[4][2];
        -: 8116:  int t=2, msb;
    #####: 8117:  double diff, sum[2] = {0,0};
        -: 8118:
    #####: 8119:  fread (test[0], 2, 2, ifp);
    #####: 8120:  for (words-=2; words--; ) {
    #####: 8121:    fread (test[t], 2, 1, ifp);
    #####: 8122:    for (msb=0; msb < 2; msb++) {
    #####: 8123:      diff = (test[t^2][msb] << 8 | test[t^2][!msb])
    #####: 8124:	   - (test[t  ][msb] << 8 | test[t  ][!msb]);
    #####: 8125:      sum[msb] += diff*diff;
        -: 8126:    }
    #####: 8127:    t = (t+1) & 3;
        -: 8128:  }
    #####: 8129:  return sum[0] < sum[1] ? 0x4d4d : 0x4949;
        -: 8130:}
        -: 8131:
    #####: 8132:float CLASS find_green (int bps, int bite, int off0, int off1)
        -: 8133:{
        -: 8134:  UINT64 bitbuf=0;
        -: 8135:  int vbits, col, i, c;
        -: 8136:  ushort img[2][2064];
    #####: 8137:  double sum[]={0,0};
        -: 8138:
    #####: 8139:  FORC(2) {
    #####: 8140:    fseek (ifp, c ? off1:off0, SEEK_SET);
    #####: 8141:    for (vbits=col=0; col < width; col++) {
    #####: 8142:      for (vbits -= bps; vbits < 0; vbits += bite) {
    #####: 8143:	bitbuf <<= bite;
    #####: 8144:	for (i=0; i < bite; i+=8)
    #####: 8145:	  bitbuf |= (unsigned) (fgetc(ifp) << i);
        -: 8146:      }
    #####: 8147:      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);
        -: 8148:    }
        -: 8149:  }
    #####: 8150:  FORC(width-1) {
    #####: 8151:    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);
    #####: 8152:    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);
        -: 8153:  }
    #####: 8154:  return 100 * log(sum[0]/sum[1]);
        -: 8155:}
        -: 8156:
        -: 8157:/*
        -: 8158:   Identify which camera created this file, and set global variables
        -: 8159:   accordingly.
        -: 8160: */
        1: 8161:void CLASS identify()
        -: 8162:{
        -: 8163:  static const short pana[][6] = {
        -: 8164:    { 3130, 1743,  4,  0, -6,  0 },
        -: 8165:    { 3130, 2055,  4,  0, -6,  0 },
        -: 8166:    { 3130, 2319,  4,  0, -6,  0 },
        -: 8167:    { 3170, 2103, 18,  0,-42, 20 },
        -: 8168:    { 3170, 2367, 18, 13,-42,-21 },
        -: 8169:    { 3177, 2367,  0,  0, -1,  0 },
        -: 8170:    { 3304, 2458,  0,  0, -1,  0 },
        -: 8171:    { 3330, 2463,  9,  0, -5,  0 },
        -: 8172:    { 3330, 2479,  9,  0,-17,  4 },
        -: 8173:    { 3370, 1899, 15,  0,-44, 20 },
        -: 8174:    { 3370, 2235, 15,  0,-44, 20 },
        -: 8175:    { 3370, 2511, 15, 10,-44,-21 },
        -: 8176:    { 3690, 2751,  3,  0, -8, -3 },
        -: 8177:    { 3710, 2751,  0,  0, -3,  0 },
        -: 8178:    { 3724, 2450,  0,  0,  0, -2 },
        -: 8179:    { 3770, 2487, 17,  0,-44, 19 },
        -: 8180:    { 3770, 2799, 17, 15,-44,-19 },
        -: 8181:    { 3880, 2170,  6,  0, -6,  0 },
        -: 8182:    { 4060, 3018,  0,  0,  0, -2 },
        -: 8183:    { 4290, 2391,  3,  0, -8, -1 },
        -: 8184:    { 4330, 2439, 17, 15,-44,-19 },
        -: 8185:    { 4508, 2962,  0,  0, -3, -4 },
        -: 8186:    { 4508, 3330,  0,  0, -3, -6 },
        -: 8187:  };
        -: 8188:  static const ushort canon[][11] = {
        -: 8189:    { 1944, 1416,   0,  0, 48,  0 },
        -: 8190:    { 2144, 1560,   4,  8, 52,  2, 0, 0, 0, 25 },
        -: 8191:    { 2224, 1456,  48,  6,  0,  2 },
        -: 8192:    { 2376, 1728,  12,  6, 52,  2 },
        -: 8193:    { 2672, 1968,  12,  6, 44,  2 },
        -: 8194:    { 3152, 2068,  64, 12,  0,  0, 16 },
        -: 8195:    { 3160, 2344,  44, 12,  4,  4 },
        -: 8196:    { 3344, 2484,   4,  6, 52,  6 },
        -: 8197:    { 3516, 2328,  42, 14,  0,  0 },
        -: 8198:    { 3596, 2360,  74, 12,  0,  0 },
        -: 8199:    { 3744, 2784,  52, 12,  8, 12 },
        -: 8200:    { 3944, 2622,  30, 18,  6,  2 },
        -: 8201:    { 3948, 2622,  42, 18,  0,  2 },
        -: 8202:    { 3984, 2622,  76, 20,  0,  2, 14 },
        -: 8203:    { 4104, 3048,  48, 12, 24, 12 },
        -: 8204:    { 4116, 2178,   4,  2,  0,  0 },
        -: 8205:    { 4152, 2772, 192, 12,  0,  0 },
        -: 8206:    { 4160, 3124, 104, 11,  8, 65 },
        -: 8207:    { 4176, 3062,  96, 17,  8,  0, 0, 16, 0, 7, 0x49 },
        -: 8208:    { 4192, 3062,  96, 17, 24,  0, 0, 16, 0, 0, 0x49 },
        -: 8209:    { 4312, 2876,  22, 18,  0,  2 },
        -: 8210:    { 4352, 2874,  62, 18,  0,  0 },
        -: 8211:    { 4476, 2954,  90, 34,  0,  0 },
        -: 8212:    { 4480, 3348,  12, 10, 36, 12, 0, 0, 0, 18, 0x49 },
        -: 8213:    { 4480, 3366,  80, 50,  0,  0 },
        -: 8214:    { 4496, 3366,  80, 50, 12,  0 },
        -: 8215:    { 4768, 3516,  96, 16,  0,  0, 0, 16 },
        -: 8216:    { 4832, 3204,  62, 26,  0,  0 },
        -: 8217:    { 4832, 3228,  62, 51,  0,  0 },
        -: 8218:    { 5108, 3349,  98, 13,  0,  0 },
        -: 8219:    { 5120, 3318, 142, 45, 62,  0 },
        -: 8220:    { 5280, 3528,  72, 52,  0,  0 },
        -: 8221:    { 5344, 3516, 142, 51,  0,  0 },
        -: 8222:    { 5344, 3584, 126,100,  0,  2 },
        -: 8223:    { 5360, 3516, 158, 51,  0,  0 },
        -: 8224:    { 5568, 3708,  72, 38,  0,  0 },
        -: 8225:    { 5632, 3710,  96, 17,  0,  0, 0, 16, 0, 0, 0x49 },
        -: 8226:    { 5712, 3774,  62, 20, 10,  2 },
        -: 8227:    { 5792, 3804, 158, 51,  0,  0 },
        -: 8228:    { 5920, 3950, 122, 80,  2,  0 },
        -: 8229:    { 6096, 4056,  72, 34,  0,  0 },
        -: 8230:    { 6288, 4056, 264, 34,  0,  0 },
        -: 8231:    { 8896, 5920, 160, 64,  0,  0 },
        -: 8232:  };
        -: 8233:  static const struct {
        -: 8234:    ushort id;
        -: 8235:    char model[20];
        -: 8236:  } unique[] = {
        -: 8237:    { 0x168, "EOS 10D" },    { 0x001, "EOS-1D" },
        -: 8238:    { 0x175, "EOS 20D" },    { 0x174, "EOS-1D Mark II" },
        -: 8239:    { 0x234, "EOS 30D" },    { 0x232, "EOS-1D Mark II N" },
        -: 8240:    { 0x190, "EOS 40D" },    { 0x169, "EOS-1D Mark III" },
        -: 8241:    { 0x261, "EOS 50D" },    { 0x281, "EOS-1D Mark IV" },
        -: 8242:    { 0x287, "EOS 60D" },    { 0x167, "EOS-1DS" },
        -: 8243:    { 0x325, "EOS 70D" },
        -: 8244:    { 0x350, "EOS 80D" },    { 0x328, "EOS-1D X Mark II" },
        -: 8245:    { 0x170, "EOS 300D" },   { 0x188, "EOS-1Ds Mark II" },
        -: 8246:    { 0x176, "EOS 450D" },   { 0x215, "EOS-1Ds Mark III" },
        -: 8247:    { 0x189, "EOS 350D" },   { 0x324, "EOS-1D C" },
        -: 8248:    { 0x236, "EOS 400D" },   { 0x269, "EOS-1D X" },
        -: 8249:    { 0x252, "EOS 500D" },   { 0x213, "EOS 5D" },
        -: 8250:    { 0x270, "EOS 550D" },   { 0x218, "EOS 5D Mark II" },
        -: 8251:    { 0x286, "EOS 600D" },   { 0x285, "EOS 5D Mark III" },
        -: 8252:    { 0x301, "EOS 650D" },   { 0x302, "EOS 6D" },
        -: 8253:    { 0x326, "EOS 700D" },   { 0x250, "EOS 7D" },
        -: 8254:    { 0x393, "EOS 750D" },   { 0x289, "EOS 7D Mark II" },
        -: 8255:    { 0x347, "EOS 760D" },
        -: 8256:    { 0x254, "EOS 1000D" },
        -: 8257:    { 0x288, "EOS 1100D" },
        -: 8258:    { 0x327, "EOS 1200D" },  { 0x382, "Canon EOS 5DS" },
        -: 8259:    { 0x404, "EOS 1300D" },  { 0x401, "Canon EOS 5DS R" },
        -: 8260:    { 0x346, "EOS 100D" },
        -: 8261:  }, sonique[] = {
        -: 8262:    { 0x002, "DSC-R1" },     { 0x100, "DSLR-A100" },
        -: 8263:    { 0x101, "DSLR-A900" },  { 0x102, "DSLR-A700" },
        -: 8264:    { 0x103, "DSLR-A200" },  { 0x104, "DSLR-A350" },
        -: 8265:    { 0x105, "DSLR-A300" },  { 0x108, "DSLR-A330" },
        -: 8266:    { 0x109, "DSLR-A230" },  { 0x10a, "DSLR-A290" },
        -: 8267:    { 0x10d, "DSLR-A850" },  { 0x111, "DSLR-A550" },
        -: 8268:    { 0x112, "DSLR-A500" },  { 0x113, "DSLR-A450" },
        -: 8269:    { 0x116, "NEX-5" },      { 0x117, "NEX-3" },
        -: 8270:    { 0x118, "SLT-A33" },    { 0x119, "SLT-A55V" },
        -: 8271:    { 0x11a, "DSLR-A560" },  { 0x11b, "DSLR-A580" },
        -: 8272:    { 0x11c, "NEX-C3" },     { 0x11d, "SLT-A35" },
        -: 8273:    { 0x11e, "SLT-A65V" },   { 0x11f, "SLT-A77V" },
        -: 8274:    { 0x120, "NEX-5N" },     { 0x121, "NEX-7" },
        -: 8275:    { 0x123, "SLT-A37" },    { 0x124, "SLT-A57" },
        -: 8276:    { 0x125, "NEX-F3" },     { 0x126, "SLT-A99V" },
        -: 8277:    { 0x127, "NEX-6" },      { 0x128, "NEX-5R" },
        -: 8278:    { 0x129, "DSC-RX100" },  { 0x12a, "DSC-RX1" },
        -: 8279:    { 0x12e, "ILCE-3000" },  { 0x12f, "SLT-A58" },
        -: 8280:    { 0x131, "NEX-3N" },     { 0x132, "ILCE-7" },
        -: 8281:    { 0x133, "NEX-5T" },     { 0x134, "DSC-RX100M2" },
        -: 8282:    { 0x135, "DSC-RX10" },   { 0x136, "DSC-RX1R" },
        -: 8283:    { 0x137, "ILCE-7R" },    { 0x138, "ILCE-6000" },
        -: 8284:    { 0x139, "ILCE-5000" },  { 0x13d, "DSC-RX100M3" },
        -: 8285:    { 0x13e, "ILCE-7S" },    { 0x13f, "ILCA-77M2" },
        -: 8286:    { 0x153, "ILCE-5100" },  { 0x154, "ILCE-7M2" },
        -: 8287:    { 0x155, "DSC-RX100M4" },{ 0x156, "DSC-RX10M2" },
        -: 8288:    { 0x158, "DSC-RX1RM2" }, { 0x15a, "ILCE-QX1" },
        -: 8289:    { 0x15b, "ILCE-7RM2" },  { 0x15e, "ILCE-7SM2" },
        -: 8290:    { 0x161, "ILCA-68" },    { 0x165, "ILCE-6300" },
        -: 8291:  };
        -: 8292:  static const struct {
        -: 8293:    unsigned fsize;
        -: 8294:    ushort rw, rh;
        -: 8295:    uchar lm, tm, rm, bm, lf, cf, max, flags;
        -: 8296:    char make[10], model[20];
        -: 8297:    ushort offset;
        -: 8298:  } table[] = {
        -: 8299:    {   786432,1024, 768, 0, 0, 0, 0, 0,0x94,0,0,"AVT","F-080C" },
        -: 8300:    {  1447680,1392,1040, 0, 0, 0, 0, 0,0x94,0,0,"AVT","F-145C" },
        -: 8301:    {  1920000,1600,1200, 0, 0, 0, 0, 0,0x94,0,0,"AVT","F-201C" },
        -: 8302:    {  5067304,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,"AVT","F-510C" },
        -: 8303:    {  5067316,2588,1958, 0, 0, 0, 0, 0,0x94,0,0,"AVT","F-510C",12 },
        -: 8304:    { 10134608,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,"AVT","F-510C" },
        -: 8305:    { 10134620,2588,1958, 0, 0, 0, 0, 9,0x94,0,0,"AVT","F-510C",12 },
        -: 8306:    { 16157136,3272,2469, 0, 0, 0, 0, 9,0x94,0,0,"AVT","F-810C" },
        -: 8307:    { 15980544,3264,2448, 0, 0, 0, 0, 8,0x61,0,1,"AgfaPhoto","DC-833m" },
        -: 8308:    {  9631728,2532,1902, 0, 0, 0, 0,96,0x61,0,0,"Alcatel","5035D" },
        -: 8309:    {  2868726,1384,1036, 0, 0, 0, 0,64,0x49,0,8,"Baumer","TXG14",1078 },
        -: 8310:    {  5298000,2400,1766,12,12,44, 2,40,0x94,0,2,"Canon","PowerShot SD300" },
        -: 8311:    {  6553440,2664,1968, 4, 4,44, 4,40,0x94,0,2,"Canon","PowerShot A460" },
        -: 8312:    {  6573120,2672,1968,12, 8,44, 0,40,0x94,0,2,"Canon","PowerShot A610" },
        -: 8313:    {  6653280,2672,1992,10, 6,42, 2,40,0x94,0,2,"Canon","PowerShot A530" },
        -: 8314:    {  7710960,2888,2136,44, 8, 4, 0,40,0x94,0,2,"Canon","PowerShot S3 IS" },
        -: 8315:    {  9219600,3152,2340,36,12, 4, 0,40,0x94,0,2,"Canon","PowerShot A620" },
        -: 8316:    {  9243240,3152,2346,12, 7,44,13,40,0x49,0,2,"Canon","PowerShot A470" },
        -: 8317:    { 10341600,3336,2480, 6, 5,32, 3,40,0x94,0,2,"Canon","PowerShot A720 IS" },
        -: 8318:    { 10383120,3344,2484,12, 6,44, 6,40,0x94,0,2,"Canon","PowerShot A630" },
        -: 8319:    { 12945240,3736,2772,12, 6,52, 6,40,0x94,0,2,"Canon","PowerShot A640" },
        -: 8320:    { 15636240,4104,3048,48,12,24,12,40,0x94,0,2,"Canon","PowerShot A650" },
        -: 8321:    { 15467760,3720,2772, 6,12,30, 0,40,0x94,0,2,"Canon","PowerShot SX110 IS" },
        -: 8322:    { 15534576,3728,2778,12, 9,44, 9,40,0x94,0,2,"Canon","PowerShot SX120 IS" },
        -: 8323:    { 18653760,4080,3048,24,12,24,12,40,0x94,0,2,"Canon","PowerShot SX20 IS" },
        -: 8324:    { 19131120,4168,3060,92,16, 4, 1,40,0x94,0,2,"Canon","PowerShot SX220 HS" },
        -: 8325:    { 21936096,4464,3276,25,10,73,12,40,0x16,0,2,"Canon","PowerShot SX30 IS" },
        -: 8326:    { 24724224,4704,3504, 8,16,56, 8,40,0x94,0,2,"Canon","PowerShot A3300 IS" },
        -: 8327:    { 30858240,5248,3920, 8,16,56,16,40,0x94,0,2,"Canon","IXUS 160" },
        -: 8328:    {  1976352,1632,1211, 0, 2, 0, 1, 0,0x94,0,1,"Casio","QV-2000UX" },
        -: 8329:    {  3217760,2080,1547, 0, 0,10, 1, 0,0x94,0,1,"Casio","QV-3*00EX" },
        -: 8330:    {  6218368,2585,1924, 0, 0, 9, 0, 0,0x94,0,1,"Casio","QV-5700" },
        -: 8331:    {  7816704,2867,2181, 0, 0,34,36, 0,0x16,0,1,"Casio","EX-Z60" },
        -: 8332:    {  2937856,1621,1208, 0, 0, 1, 0, 0,0x94,7,13,"Casio","EX-S20" },
        -: 8333:    {  4948608,2090,1578, 0, 0,32,34, 0,0x94,7,1,"Casio","EX-S100" },
        -: 8334:    {  6054400,2346,1720, 2, 0,32, 0, 0,0x94,7,1,"Casio","QV-R41" },
        -: 8335:    {  7426656,2568,1928, 0, 0, 0, 0, 0,0x94,0,1,"Casio","EX-P505" },
        -: 8336:    {  7530816,2602,1929, 0, 0,22, 0, 0,0x94,7,1,"Casio","QV-R51" },
        -: 8337:    {  7542528,2602,1932, 0, 0,32, 0, 0,0x94,7,1,"Casio","EX-Z50" },
        -: 8338:    {  7562048,2602,1937, 0, 0,25, 0, 0,0x16,7,1,"Casio","EX-Z500" },
        -: 8339:    {  7753344,2602,1986, 0, 0,32,26, 0,0x94,7,1,"Casio","EX-Z55" },
        -: 8340:    {  9313536,2858,2172, 0, 0,14,30, 0,0x94,7,1,"Casio","EX-P600" },
        -: 8341:    { 10834368,3114,2319, 0, 0,27, 0, 0,0x94,0,1,"Casio","EX-Z750" },
        -: 8342:    { 10843712,3114,2321, 0, 0,25, 0, 0,0x94,0,1,"Casio","EX-Z75" },
        -: 8343:    { 10979200,3114,2350, 0, 0,32,32, 0,0x94,7,1,"Casio","EX-P700" },
        -: 8344:    { 12310144,3285,2498, 0, 0, 6,30, 0,0x94,0,1,"Casio","EX-Z850" },
        -: 8345:    { 12489984,3328,2502, 0, 0,47,35, 0,0x94,0,1,"Casio","EX-Z8" },
        -: 8346:    { 15499264,3754,2752, 0, 0,82, 0, 0,0x94,0,1,"Casio","EX-Z1050" },
        -: 8347:    { 18702336,4096,3044, 0, 0,24, 0,80,0x94,7,1,"Casio","EX-ZR100" },
        -: 8348:    {  7684000,2260,1700, 0, 0, 0, 0,13,0x94,0,1,"Casio","QV-4000" },
        -: 8349:    {   787456,1024, 769, 0, 1, 0, 0, 0,0x49,0,0,"Creative","PC-CAM 600" },
        -: 8350:    { 28829184,4384,3288, 0, 0, 0, 0,36,0x61,0,0,"DJI" },
        -: 8351:    { 15151104,4608,3288, 0, 0, 0, 0, 0,0x94,0,0,"Matrix" },
        -: 8352:    {  3840000,1600,1200, 0, 0, 0, 0,65,0x49,0,0,"Foculus","531C" },
        -: 8353:    {   307200, 640, 480, 0, 0, 0, 0, 0,0x94,0,0,"Generic" },
        -: 8354:    {    62464, 256, 244, 1, 1, 6, 1, 0,0x8d,0,0,"Kodak","DC20" },
        -: 8355:    {   124928, 512, 244, 1, 1,10, 1, 0,0x8d,0,0,"Kodak","DC20" },
        -: 8356:    {  1652736,1536,1076, 0,52, 0, 0, 0,0x61,0,0,"Kodak","DCS200" },
        -: 8357:    {  4159302,2338,1779, 1,33, 1, 2, 0,0x94,0,0,"Kodak","C330" },
        -: 8358:    {  4162462,2338,1779, 1,33, 1, 2, 0,0x94,0,0,"Kodak","C330",3160 },
        -: 8359:    {  2247168,1232, 912, 0, 0,16, 0, 0,0x00,0,0,"Kodak","C330" },
        -: 8360:    {  3370752,1232, 912, 0, 0,16, 0, 0,0x00,0,0,"Kodak","C330" },
        -: 8361:    {  6163328,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,"Kodak","C603" },
        -: 8362:    {  6166488,2864,2152, 0, 0, 0, 0, 0,0x94,0,0,"Kodak","C603",3160 },
        -: 8363:    {   460800, 640, 480, 0, 0, 0, 0, 0,0x00,0,0,"Kodak","C603" },
        -: 8364:    {  9116448,2848,2134, 0, 0, 0, 0, 0,0x00,0,0,"Kodak","C603" },
        -: 8365:    { 12241200,4040,3030, 2, 0, 0,13, 0,0x49,0,0,"Kodak","12MP" },
        -: 8366:    { 12272756,4040,3030, 2, 0, 0,13, 0,0x49,0,0,"Kodak","12MP",31556 },
        -: 8367:    { 18000000,4000,3000, 0, 0, 0, 0, 0,0x00,0,0,"Kodak","12MP" },
        -: 8368:    {   614400, 640, 480, 0, 3, 0, 0,64,0x94,0,0,"Kodak","KAI-0340" },
        -: 8369:    { 15360000,3200,2400, 0, 0, 0, 0,96,0x16,0,0,"Lenovo","A820" },
        -: 8370:    {  3884928,1608,1207, 0, 0, 0, 0,96,0x16,0,0,"Micron","2010",3212 },
        -: 8371:    {  1138688,1534, 986, 0, 0, 0, 0, 0,0x61,0,0,"Minolta","RD175",513 },
        -: 8372:    {  1581060,1305, 969, 0, 0,18, 6, 6,0x1e,4,1,"Nikon","E900" },
        -: 8373:    {  2465792,1638,1204, 0, 0,22, 1, 6,0x4b,5,1,"Nikon","E950" },
        -: 8374:    {  2940928,1616,1213, 0, 0, 0, 7,30,0x94,0,1,"Nikon","E2100" },
        -: 8375:    {  4771840,2064,1541, 0, 0, 0, 1, 6,0xe1,0,1,"Nikon","E990" },
        -: 8376:    {  4775936,2064,1542, 0, 0, 0, 0,30,0x94,0,1,"Nikon","E3700" },
        -: 8377:    {  5865472,2288,1709, 0, 0, 0, 1, 6,0xb4,0,1,"Nikon","E4500" },
        -: 8378:    {  5869568,2288,1710, 0, 0, 0, 0, 6,0x16,0,1,"Nikon","E4300" },
        -: 8379:    {  7438336,2576,1925, 0, 0, 0, 1, 6,0xb4,0,1,"Nikon","E5000" },
        -: 8380:    {  8998912,2832,2118, 0, 0, 0, 0,30,0x94,7,1,"Nikon","COOLPIX S6" },
        -: 8381:    {  5939200,2304,1718, 0, 0, 0, 0,30,0x16,0,0,"Olympus","C770UZ" },
        -: 8382:    {  3178560,2064,1540, 0, 0, 0, 0, 0,0x94,0,1,"Pentax","Optio S" },
        -: 8383:    {  4841984,2090,1544, 0, 0,22, 0, 0,0x94,7,1,"Pentax","Optio S" },
        -: 8384:    {  6114240,2346,1737, 0, 0,22, 0, 0,0x94,7,1,"Pentax","Optio S4" },
        -: 8385:    { 10702848,3072,2322, 0, 0, 0,21,30,0x94,0,1,"Pentax","Optio 750Z" },
        -: 8386:    {  4147200,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,"Photron","BC2-HD" },
        -: 8387:    {  4151666,1920,1080, 0, 0, 0, 0, 0,0x49,0,0,"Photron","BC2-HD",8 },
        -: 8388:    { 13248000,2208,3000, 0, 0, 0, 0,13,0x61,0,0,"Pixelink","A782" },
        -: 8389:    {  6291456,2048,1536, 0, 0, 0, 0,96,0x61,0,0,"RoverShot","3320AF" },
        -: 8390:    {   311696, 644, 484, 0, 0, 0, 0, 0,0x16,0,8,"ST Micro","STV680 VGA" },
        -: 8391:    { 16098048,3288,2448, 0, 0,24, 0, 9,0x94,0,1,"Samsung","S85" },
        -: 8392:    { 16215552,3312,2448, 0, 0,48, 0, 9,0x94,0,1,"Samsung","S85" },
        -: 8393:    { 20487168,3648,2808, 0, 0, 0, 0,13,0x94,5,1,"Samsung","WB550" },
        -: 8394:    { 24000000,4000,3000, 0, 0, 0, 0,13,0x94,5,1,"Samsung","WB550" },
        -: 8395:    { 12582980,3072,2048, 0, 0, 0, 0,33,0x61,0,0,"Sinar","",68 },
        -: 8396:    { 33292868,4080,4080, 0, 0, 0, 0,33,0x61,0,0,"Sinar","",68 },
        -: 8397:    { 44390468,4080,5440, 0, 0, 0, 0,33,0x61,0,0,"Sinar","",68 },
        -: 8398:    {  1409024,1376,1024, 0, 0, 1, 0, 0,0x49,0,0,"Sony","XCD-SX910CR" },
        -: 8399:    {  2818048,1376,1024, 0, 0, 1, 0,97,0x49,0,0,"Sony","XCD-SX910CR" },
        -: 8400:  };
        -: 8401:  static const char *corp[] =
        -: 8402:    { "AgfaPhoto", "Canon", "Casio", "Epson", "Fujifilm",
        -: 8403:      "Mamiya", "Minolta", "Motorola", "Kodak", "Konica", "Leica",
        -: 8404:      "Nikon", "Nokia", "Olympus", "Ricoh", "Pentax", "Phase One",
        -: 8405:      "Samsung", "Sigma", "Sinar", "Sony" };
        -: 8406:  char head[32], *cp;
        -: 8407:  int hlen, flen, fsize, zero_fsize=1, i, c;
        -: 8408:  struct jhead jh;
        -: 8409:
        1: 8410:  tiff_flip = flip = filters = UINT_MAX;	/* unknown */
        1: 8411:  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;
        1: 8412:  maximum = height = width = top_margin = left_margin = 0;
        1: 8413:  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;
        1: 8414:  iso_speed = shutter = aperture = focal_len = unique_id = 0;
        1: 8415:  tiff_nifds = 0;
        1: 8416:  memset (tiff_ifd, 0, sizeof tiff_ifd);
        1: 8417:  memset (gpsdata, 0, sizeof gpsdata);
        1: 8418:  memset (cblack, 0, sizeof cblack);
        1: 8419:  memset (white, 0, sizeof white);
        1: 8420:  memset (mask, 0, sizeof mask);
        1: 8421:  thumb_offset = thumb_length = thumb_width = thumb_height = 0;
        1: 8422:  load_raw = thumb_load_raw = 0;
        1: 8423:  write_thumb = &CLASS jpeg_thumb;
        1: 8424:  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;
        1: 8425:  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;
        1: 8426:  timestamp = shot_order = tiff_samples = black = is_foveon = 0;
        1: 8427:  mix_green = profile_length = data_error = zero_is_bad = 0;
        1: 8428:  pixel_aspect = is_raw = raw_color = 1;
        1: 8429:  tile_width = tile_length = 0;
        5: 8430:  for (i=0; i < 4; i++) {
        4: 8431:    cam_mul[i] = i == 1;
        4: 8432:    pre_mul[i] = i < 3;
        4: 8433:    FORC3 cmatrix[c][i] = 0;
       12: 8434:    FORC3 rgb_cam[c][i] = c == i;
        -: 8435:  }
        1: 8436:  colors = 3;
        1: 8437:  for (i=0; i < 0x10000; i++) curve[i] = i;
        -: 8438:
        1: 8439:  order = get2();
        1: 8440:  hlen = get4();
        1: 8441:  fseek (ifp, 0, SEEK_SET);
        1: 8442:  fread (head, 1, 32, ifp);
        1: 8443:  fseek (ifp, 0, SEEK_END);
        1: 8444:  flen = fsize = ftell(ifp);
        1: 8445:  if ((cp = (char *) memmem (head, 32, "MMMM", 4)) ||
        -: 8446:      (cp = (char *) memmem (head, 32, "IIII", 4))) {
    #####: 8447:    parse_phase_one (cp-head);
    #####: 8448:    if (cp-head && parse_tiff(0)) apply_tiff();
        1: 8449:  } else if (order == 0x4949 || order == 0x4d4d) {
        1: 8450:    if (!memcmp (head+6,"HEAPCCDR",8)) {
    #####: 8451:      data_offset = hlen;
    #####: 8452:      parse_ciff (hlen, flen-hlen, 0);
    #####: 8453:      load_raw = &CLASS canon_load_raw;
        1: 8454:    } else if (parse_tiff(0)) apply_tiff();
    #####: 8455:  } else if (!memcmp (head,"\xff\xd8\xff\xe1",4) &&
    #####: 8456:	     !memcmp (head+6,"Exif",4)) {
    #####: 8457:    fseek (ifp, 4, SEEK_SET);
    #####: 8458:    data_offset = 4 + get2();
    #####: 8459:    fseek (ifp, data_offset, SEEK_SET);
    #####: 8460:    if (fgetc(ifp) != 0xff)
    #####: 8461:      parse_tiff(12);
    #####: 8462:    thumb_offset = 0;
    #####: 8463:  } else if (!memcmp (head+25,"ARECOYK",7)) {
    #####: 8464:    strcpy (make, "Contax");
    #####: 8465:    strcpy (model,"N Digital");
    #####: 8466:    fseek (ifp, 33, SEEK_SET);
    #####: 8467:    get_timestamp(1);
    #####: 8468:    fseek (ifp, 60, SEEK_SET);
    #####: 8469:    FORC4 cam_mul[c ^ (c >> 1)] = get4();
    #####: 8470:  } else if (!strcmp (head, "PXN")) {
    #####: 8471:    strcpy (make, "Logitech");
    #####: 8472:    strcpy (model,"Fotoman Pixtura");
    #####: 8473:  } else if (!strcmp (head, "qktk")) {
    #####: 8474:    strcpy (make, "Apple");
    #####: 8475:    strcpy (model,"QuickTake 100");
    #####: 8476:    load_raw = &CLASS quicktake_100_load_raw;
    #####: 8477:  } else if (!strcmp (head, "qktn")) {
    #####: 8478:    strcpy (make, "Apple");
    #####: 8479:    strcpy (model,"QuickTake 150");
    #####: 8480:    load_raw = &CLASS kodak_radc_load_raw;
    #####: 8481:  } else if (!memcmp (head,"FUJIFILM",8)) {
    #####: 8482:    fseek (ifp, 84, SEEK_SET);
    #####: 8483:    thumb_offset = get4();
    #####: 8484:    thumb_length = get4();
    #####: 8485:    fseek (ifp, 92, SEEK_SET);
    #####: 8486:    parse_fuji (get4());
    #####: 8487:    if (thumb_offset > 120) {
    #####: 8488:      fseek (ifp, 120, SEEK_SET);
    #####: 8489:      is_raw += (i = get4()) && 1;
    #####: 8490:      if (is_raw == 2 && shot_select)
    #####: 8491:	parse_fuji (i);
        -: 8492:    }
    #####: 8493:    load_raw = &CLASS unpacked_load_raw;
    #####: 8494:    fseek (ifp, 100+28*(shot_select > 0), SEEK_SET);
    #####: 8495:    parse_tiff (data_offset = get4());
    #####: 8496:    parse_tiff (thumb_offset+12);
    #####: 8497:    apply_tiff();
    #####: 8498:  } else if (!memcmp (head,"RIFF",4)) {
    #####: 8499:    fseek (ifp, 0, SEEK_SET);
    #####: 8500:    parse_riff();
    #####: 8501:  } else if (!memcmp (head+4,"ftypqt   ",9)) {
    #####: 8502:    fseek (ifp, 0, SEEK_SET);
    #####: 8503:    parse_qt (fsize);
    #####: 8504:    is_raw = 0;
    #####: 8505:  } else if (!memcmp (head,"\0\001\0\001\0@",6)) {
    #####: 8506:    fseek (ifp, 6, SEEK_SET);
    #####: 8507:    fread (make, 1, 8, ifp);
    #####: 8508:    fread (model, 1, 8, ifp);
    #####: 8509:    fread (model2, 1, 16, ifp);
    #####: 8510:    data_offset = get2();
    #####: 8511:    get2();
    #####: 8512:    raw_width = get2();
    #####: 8513:    raw_height = get2();
    #####: 8514:    load_raw = &CLASS nokia_load_raw;
    #####: 8515:    filters = 0x61616161;
    #####: 8516:  } else if (!memcmp (head,"NOKIARAW",8)) {
    #####: 8517:    strcpy (make, "NOKIA");
    #####: 8518:    order = 0x4949;
    #####: 8519:    fseek (ifp, 300, SEEK_SET);
    #####: 8520:    data_offset = get4();
    #####: 8521:    i = get4();
    #####: 8522:    width = get2();
    #####: 8523:    height = get2();
    #####: 8524:    switch (tiff_bps = i*8 / (width * height)) {
    #####: 8525:      case  8: load_raw = &CLASS eight_bit_load_raw;  break;
    #####: 8526:      case 10: load_raw = &CLASS nokia_load_raw;
        -: 8527:    }
    #####: 8528:    raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);
    #####: 8529:    mask[0][3] = 1;
    #####: 8530:    filters = 0x61616161;
    #####: 8531:  } else if (!memcmp (head,"ARRI",4)) {
    #####: 8532:    order = 0x4949;
    #####: 8533:    fseek (ifp, 20, SEEK_SET);
    #####: 8534:    width = get4();
    #####: 8535:    height = get4();
    #####: 8536:    strcpy (make, "ARRI");
    #####: 8537:    fseek (ifp, 668, SEEK_SET);
    #####: 8538:    fread (model, 1, 64, ifp);
    #####: 8539:    data_offset = 4096;
    #####: 8540:    load_raw = &CLASS packed_load_raw;
    #####: 8541:    load_flags = 88;
    #####: 8542:    filters = 0x61616161;
    #####: 8543:  } else if (!memcmp (head,"XPDS",4)) {
    #####: 8544:    order = 0x4949;
    #####: 8545:    fseek (ifp, 0x800, SEEK_SET);
    #####: 8546:    fread (make, 1, 41, ifp);
    #####: 8547:    raw_height = get2();
    #####: 8548:    raw_width  = get2();
    #####: 8549:    fseek (ifp, 56, SEEK_CUR);
    #####: 8550:    fread (model, 1, 30, ifp);
    #####: 8551:    data_offset = 0x10000;
    #####: 8552:    load_raw = &CLASS canon_rmf_load_raw;
    #####: 8553:    gamma_curve (0, 12.25, 1, 1023);
    #####: 8554:  } else if (!memcmp (head+4,"RED1",4)) {
    #####: 8555:    strcpy (make, "Red");
    #####: 8556:    strcpy (model,"One");
    #####: 8557:    parse_redcine();
    #####: 8558:    load_raw = &CLASS redcine_load_raw;
    #####: 8559:    gamma_curve (1/2.4, 12.92, 1, 4095);
    #####: 8560:    filters = 0x49494949;
    #####: 8561:  } else if (!memcmp (head,"DSC-Image",9))
    #####: 8562:    parse_rollei();
    #####: 8563:  else if (!memcmp (head,"PWAD",4))
    #####: 8564:    parse_sinar_ia();
    #####: 8565:  else if (!memcmp (head,"\0MRM",4))
    #####: 8566:    parse_minolta(0);
    #####: 8567:  else if (!memcmp (head,"FOVb",4))
    #####: 8568:    parse_foveon();
    #####: 8569:  else if (!memcmp (head,"CI",2))
    #####: 8570:    parse_cine();
        1: 8571:  if (make[0] == 0)
    #####: 8572:    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)
    #####: 8573:      if (fsize == table[i].fsize) {
    #####: 8574:	strcpy (make,  table[i].make );
    #####: 8575:	strcpy (model, table[i].model);
    #####: 8576:	flip = table[i].flags >> 2;
    #####: 8577:	zero_is_bad = table[i].flags & 2;
    #####: 8578:	if (table[i].flags & 1)
    #####: 8579:	  parse_external_jpeg();
    #####: 8580:	data_offset = table[i].offset;
    #####: 8581:	raw_width   = table[i].rw;
    #####: 8582:	raw_height  = table[i].rh;
    #####: 8583:	left_margin = table[i].lm;
    #####: 8584:	 top_margin = table[i].tm;
    #####: 8585:	width  = raw_width - left_margin - table[i].rm;
    #####: 8586:	height = raw_height - top_margin - table[i].bm;
    #####: 8587:	filters = 0x1010101 * table[i].cf;
    #####: 8588:	colors = 4 - !((filters & filters >> 1) & 0x5555);
    #####: 8589:	load_flags = table[i].lf;
    #####: 8590:	switch (tiff_bps = (fsize-data_offset)*8 / (raw_width*raw_height)) {
    #####: 8591:	  case 6:
    #####: 8592:	    load_raw = &CLASS minolta_rd175_load_raw;  break;
    #####: 8593:	  case 8:
    #####: 8594:	    load_raw = &CLASS eight_bit_load_raw;  break;
    #####: 8595:	  case 10: case 12:
    #####: 8596:	    load_flags |= 128;
    #####: 8597:	    load_raw = &CLASS packed_load_raw;     break;
    #####: 8598:	  case 16:
    #####: 8599:	    order = 0x4949 | 0x404 * (load_flags & 1);
    #####: 8600:	    tiff_bps -= load_flags >> 4;
    #####: 8601:	    tiff_bps -= load_flags = load_flags >> 1 & 7;
    #####: 8602:	    load_raw = &CLASS unpacked_load_raw;
        -: 8603:	}
    #####: 8604:	maximum = (1 << tiff_bps) - (1 << table[i].max);
        -: 8605:      }
        -: 8606:  if (zero_fsize) fsize = 0;
        1: 8607:  if (make[0] == 0) parse_smal (0, flen);
        1: 8608:  if (make[0] == 0) {
    #####: 8609:    parse_jpeg(0);
    #####: 8610:    if (!(strncmp(model,"ov",2) && strncmp(model,"RP_OV",5)) &&
    #####: 8611:	!fseek (ifp, -6404096, SEEK_END) &&
    #####: 8612:	fread (head, 1, 32, ifp) && !strcmp(head,"BRCMn")) {
    #####: 8613:      strcpy (make, "OmniVision");
    #####: 8614:      data_offset = ftell(ifp) + 0x8000-32;
    #####: 8615:      width = raw_width;
    #####: 8616:      raw_width = 2611;
    #####: 8617:      load_raw = &CLASS nokia_load_raw;
    #####: 8618:      filters = 0x16161616;
    #####: 8619:    } else is_raw = 0;
        -: 8620:  }
        -: 8621:
       21: 8622:  for (i=0; i < sizeof corp / sizeof *corp; i++)
       21: 8623:    if (strcasestr (make, corp[i]))	/* Simplify company names */
        1: 8624:	    strcpy (make, corp[i]);
        1: 8625:  if ((!strcmp(make,"Kodak") || !strcmp(make,"Leica")) &&
    #####: 8626:	((cp = strcasestr(model," DIGITAL CAMERA")) ||
        -: 8627:	 (cp = strstr(model,"FILE VERSION"))))
    #####: 8628:     *cp = 0;
        1: 8629:  if (!strncasecmp(model,"PENTAX",6))
    #####: 8630:    strcpy (make, "Pentax");
        1: 8631:  cp = make + strlen(make);		/* Remove trailing spaces */
        1: 8632:  while (*--cp == ' ') *cp = 0;
        1: 8633:  cp = model + strlen(model);
        1: 8634:  while (*--cp == ' ') *cp = 0;
        1: 8635:  i = strlen(make);			/* Remove make from model */
        1: 8636:  if (!strncasecmp (model, make, i) && model[i++] == ' ')
        1: 8637:    memmove (model, model+i, 64-i);
        1: 8638:  if (!strncmp (model,"FinePix ",8))
    #####: 8639:    strcpy (model, model+8);
        1: 8640:  if (!strncmp (model,"Digital Camera ",15))
    #####: 8641:    strcpy (model, model+15);
        1: 8642:  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;
        1: 8643:  if (!is_raw) goto notraw;
        -: 8644:
        1: 8645:  if (!height) height = raw_height;
        1: 8646:  if (!width)  width  = raw_width;
        1: 8647:  if (height == 2624 && width == 3936)	/* Pentax K10D and Samsung GX10 */
    #####: 8648:    { height  = 2616;   width  = 3896; }
        1: 8649:  if (height == 3136 && width == 4864)  /* Pentax K20D and Samsung GX20 */
    #####: 8650:    { height  = 3124;   width  = 4688; filters = 0x16161616; }
        1: 8651:  if (width == 4352 && (!strcmp(model,"K-r") || !strcmp(model,"K-x")))
    #####: 8652:    {			width  = 4309; filters = 0x16161616; }
        1: 8653:  if (width >= 4960 && !strncmp(model,"K-5",3))
    #####: 8654:    { left_margin = 10; width  = 4950; filters = 0x16161616; }
        1: 8655:  if (width == 4736 && !strcmp(model,"K-7"))
    #####: 8656:    { height  = 3122;   width  = 4684; filters = 0x16161616; top_margin = 2; }
        1: 8657:  if (width == 6080 && !strcmp(model,"K-3"))
    #####: 8658:    { left_margin = 4;  width  = 6040; }
        1: 8659:  if (width == 7424 && !strcmp(model,"645D"))
    #####: 8660:    { height  = 5502;   width  = 7328; filters = 0x61616161; top_margin = 29;
    #####: 8661:      left_margin = 48; }
        1: 8662:  if (height == 3014 && width == 4096)	/* Ricoh GX200 */
    #####: 8663:			width  = 4014;
        1: 8664:  if (dng_version) {
    #####: 8665:    if (filters == UINT_MAX) filters = 0;
    #####: 8666:    if (filters) is_raw *= tiff_samples;
    #####: 8667:    else	 colors  = tiff_samples;
    #####: 8668:    switch (tiff_compress) {
    #####: 8669:      case 0:
    #####: 8670:      case 1:     load_raw = &CLASS   packed_dng_load_raw;  break;
    #####: 8671:      case 7:     load_raw = &CLASS lossless_dng_load_raw;  break;
    #####: 8672:      case 34892: load_raw = &CLASS    lossy_dng_load_raw;  break;
    #####: 8673:      default:    load_raw = 0;
        -: 8674:    }
        -: 8675:    goto dng_skip;
        -: 8676:  }
        1: 8677:  if (!strcmp(make,"Canon") && !fsize && tiff_bps != 15) {
        1: 8678:    if (!load_raw)
    #####: 8679:      load_raw = &CLASS lossless_jpeg_load_raw;
       43: 8680:    for (i=0; i < sizeof canon / sizeof *canon; i++)
       43: 8681:      if (raw_width == canon[i][0] && raw_height == canon[i][1]) {
        1: 8682:	width  = raw_width - (left_margin = canon[i][2]);
        1: 8683:	height = raw_height - (top_margin = canon[i][3]);
        1: 8684:	width  -= canon[i][4];
        1: 8685:	height -= canon[i][5];
        1: 8686:	mask[0][1] =  canon[i][6];
        1: 8687:	mask[0][3] = -canon[i][7];
        1: 8688:	mask[1][1] =  canon[i][8];
        1: 8689:	mask[1][3] = -canon[i][9];
        1: 8690:	if (canon[i][10]) filters = canon[i][10] * 0x01010101;
        -: 8691:      }
        1: 8692:    if ((unique_id | 0x20000) == 0x2720000) {
    #####: 8693:      left_margin = 8;
    #####: 8694:      top_margin = 16;
        -: 8695:    }
        -: 8696:  }
       43: 8697:  for (i=0; i < sizeof unique / sizeof *unique; i++)
       43: 8698:    if (unique_id == 0x80000000 + unique[i].id) {
        1: 8699:      adobe_coeff ("Canon", unique[i].model);
        1: 8700:      if (model[4] == 'K' && strlen(model) == 8)
    #####: 8701:	strcpy (model, unique[i].model);
        -: 8702:    }
       58: 8703:  for (i=0; i < sizeof sonique / sizeof *sonique; i++)
       58: 8704:    if (unique_id == sonique[i].id)
    #####: 8705:      strcpy (model, sonique[i].model);
        1: 8706:  if (!strcmp(make,"Nikon")) {
    #####: 8707:    if (!load_raw)
    #####: 8708:      load_raw = &CLASS packed_load_raw;
    #####: 8709:    if (model[0] == 'E')
    #####: 8710:      load_flags |= !data_offset << 2 | 2;
        -: 8711:  }
        -: 8712:
        -: 8713:/* Set parameters based on camera name (for non-DNG files). */
        -: 8714:
        1: 8715:  if (!strcmp(model,"KAI-0340")
    #####: 8716:	&& find_green (16, 16, 3840, 5120) < 25) {
    #####: 8717:    height = 480;
    #####: 8718:    top_margin = filters = 0;
    #####: 8719:    strcpy (model,"C603");
        -: 8720:  }
        1: 8721:  if (!strcmp(make,"Sony") && raw_width > 3888)
    #####: 8722:    black = 128 << (tiff_bps - 12);
        1: 8723:  if (is_foveon) {
    #####: 8724:    if (height*2 < width) pixel_aspect = 0.5;
    #####: 8725:    if (height   > width) pixel_aspect = 2;
    #####: 8726:    filters = 0;
        -: 8727:    simple_coeff(0);
        1: 8728:  } else if (!strcmp(make,"Canon") && tiff_bps == 15) {
    #####: 8729:    switch (width) {
    #####: 8730:      case 3344: width -= 66;
    #####: 8731:      case 3872: width -= 6;
        -: 8732:    }
    #####: 8733:    if (height > width) {
    #####: 8734:      SWAP(height,width);
    #####: 8735:      SWAP(raw_height,raw_width);
        -: 8736:    }
    #####: 8737:    if (width == 7200 && height == 3888) {
    #####: 8738:      raw_width  = width  = 6480;
    #####: 8739:      raw_height = height = 4320;
        -: 8740:    }
    #####: 8741:    filters = 0;
    #####: 8742:    tiff_samples = colors = 3;
    #####: 8743:    load_raw = &CLASS canon_sraw_load_raw;
        1: 8744:  } else if (!strcmp(model,"PowerShot 600")) {
    #####: 8745:    height = 613;
    #####: 8746:    width  = 854;
    #####: 8747:    raw_width = 896;
    #####: 8748:    colors = 4;
    #####: 8749:    filters = 0xe1e4e1e4;
    #####: 8750:    load_raw = &CLASS canon_600_load_raw;
        2: 8751:  } else if (!strcmp(model,"PowerShot A5") ||
        1: 8752:	     !strcmp(model,"PowerShot A5 Zoom")) {
    #####: 8753:    height = 773;
    #####: 8754:    width  = 960;
    #####: 8755:    raw_width = 992;
    #####: 8756:    pixel_aspect = 256/235.0;
    #####: 8757:    filters = 0x1e4e1e4e;
    #####: 8758:    goto canon_a5;
        1: 8759:  } else if (!strcmp(model,"PowerShot A50")) {
    #####: 8760:    height =  968;
    #####: 8761:    width  = 1290;
    #####: 8762:    raw_width = 1320;
    #####: 8763:    filters = 0x1b4e4b1e;
    #####: 8764:    goto canon_a5;
        1: 8765:  } else if (!strcmp(model,"PowerShot Pro70")) {
    #####: 8766:    height = 1024;
    #####: 8767:    width  = 1552;
    #####: 8768:    filters = 0x1e4b4e1b;
    #####: 8769:canon_a5:
    #####: 8770:    colors = 4;
    #####: 8771:    tiff_bps = 10;
    #####: 8772:    load_raw = &CLASS packed_load_raw;
    #####: 8773:    load_flags = 40;
        2: 8774:  } else if (!strcmp(model,"PowerShot Pro90 IS") ||
        1: 8775:	     !strcmp(model,"PowerShot G1")) {
    #####: 8776:    colors = 4;
    #####: 8777:    filters = 0xb4b4b4b4;
        1: 8778:  } else if (!strcmp(model,"PowerShot A610")) {
    #####: 8779:    if (canon_s2is()) strcpy (model+10, "S2 IS");
        1: 8780:  } else if (!strcmp(model,"PowerShot SX220 HS")) {
    #####: 8781:    mask[1][3] = -4;
        1: 8782:  } else if (!strcmp(model,"EOS D2000C")) {
    #####: 8783:    filters = 0x61616161;
    #####: 8784:    black = curve[200];
        1: 8785:  } else if (!strcmp(model,"D1")) {
    #####: 8786:    cam_mul[0] *= 256/527.0;
    #####: 8787:    cam_mul[2] *= 256/317.0;
        1: 8788:  } else if (!strcmp(model,"D1X")) {
    #####: 8789:    width -= 4;
    #####: 8790:    pixel_aspect = 0.5;
        2: 8791:  } else if (!strcmp(model,"D40X") ||
        2: 8792:	     !strcmp(model,"D60")  ||
        2: 8793:	     !strcmp(model,"D80")  ||
        1: 8794:	     !strcmp(model,"D3000")) {
    #####: 8795:    height -= 3;
    #####: 8796:    width  -= 4;
        2: 8797:  } else if (!strcmp(model,"D3")   ||
        2: 8798:	     !strcmp(model,"D3S")  ||
        1: 8799:	     !strcmp(model,"D700")) {
    #####: 8800:    width -= 4;
    #####: 8801:    left_margin = 2;
        1: 8802:  } else if (!strcmp(model,"D3100")) {
    #####: 8803:    width -= 28;
    #####: 8804:    left_margin = 6;
        2: 8805:  } else if (!strcmp(model,"D5000") ||
        1: 8806:	     !strcmp(model,"D90")) {
    #####: 8807:    width -= 42;
        2: 8808:  } else if (!strcmp(model,"D5100") ||
        2: 8809:	     !strcmp(model,"D7000") ||
        1: 8810:	     !strcmp(model,"COOLPIX A")) {
    #####: 8811:    width -= 44;
        2: 8812:  } else if (!strcmp(model,"D3200") ||
        2: 8813:	    !strncmp(model,"D6",2)  ||
        1: 8814:	    !strncmp(model,"D800",4)) {
    #####: 8815:    width -= 46;
        2: 8816:  } else if (!strcmp(model,"D4") ||
        1: 8817:	     !strcmp(model,"Df")) {
    #####: 8818:    width -= 52;
    #####: 8819:    left_margin = 2;
        2: 8820:  } else if (!strncmp(model,"D40",3) ||
        2: 8821:	     !strncmp(model,"D50",3) ||
        1: 8822:	     !strncmp(model,"D70",3)) {
    #####: 8823:    width--;
        1: 8824:  } else if (!strcmp(model,"D100")) {
    #####: 8825:    if (load_flags)
    #####: 8826:      raw_width = (width += 3) + 3;
        1: 8827:  } else if (!strcmp(model,"D200")) {
    #####: 8828:    left_margin = 1;
    #####: 8829:    width -= 4;
    #####: 8830:    filters = 0x94949494;
        1: 8831:  } else if (!strncmp(model,"D2H",3)) {
    #####: 8832:    left_margin = 6;
    #####: 8833:    width -= 14;
        1: 8834:  } else if (!strncmp(model,"D2X",3)) {
    #####: 8835:    if (width == 3264) width -= 32;
    #####: 8836:    else width -= 8;
        1: 8837:  } else if (!strncmp(model,"D300",4)) {
    #####: 8838:    width -= 32;
        1: 8839:  } else if (!strncmp(model,"COOLPIX P",9) && raw_width != 4032) {
    #####: 8840:    load_flags = 24;
    #####: 8841:    filters = 0x94949494;
    #####: 8842:    if (model[9] == '7' && iso_speed >= 400)
    #####: 8843:      black = 255;
        1: 8844:  } else if (!strncmp(model,"1 ",2)) {
    #####: 8845:    height -= 2;
        1: 8846:  } else if (fsize == 1581060) {
        -: 8847:    simple_coeff(3);
    #####: 8848:    pre_mul[0] = 1.2085;
    #####: 8849:    pre_mul[1] = 1.0943;
    #####: 8850:    pre_mul[3] = 1.1103;
        1: 8851:  } else if (fsize == 3178560) {
    #####: 8852:    cam_mul[0] *= 4;
    #####: 8853:    cam_mul[2] *= 4;
        1: 8854:  } else if (fsize == 4771840) {
    #####: 8855:    if (!timestamp && nikon_e995())
    #####: 8856:      strcpy (model, "E995");
    #####: 8857:    if (strcmp(model,"E995")) {
    #####: 8858:      filters = 0xb4b4b4b4;
        -: 8859:      simple_coeff(3);
    #####: 8860:      pre_mul[0] = 1.196;
    #####: 8861:      pre_mul[1] = 1.246;
    #####: 8862:      pre_mul[2] = 1.018;
        -: 8863:    }
        1: 8864:  } else if (fsize == 2940928) {
    #####: 8865:    if (!timestamp && !nikon_e2100())
    #####: 8866:      strcpy (model,"E2500");
    #####: 8867:    if (!strcmp(model,"E2500")) {
    #####: 8868:      height -= 2;
    #####: 8869:      load_flags = 6;
    #####: 8870:      colors = 4;
    #####: 8871:      filters = 0x4b4b4b4b;
        -: 8872:    }
        1: 8873:  } else if (fsize == 4775936) {
    #####: 8874:    if (!timestamp) nikon_3700();
    #####: 8875:    if (model[0] == 'E' && atoi(model+1) < 3700)
    #####: 8876:      filters = 0x49494949;
    #####: 8877:    if (!strcmp(model,"Optio 33WR")) {
    #####: 8878:      flip = 1;
    #####: 8879:      filters = 0x16161616;
        -: 8880:    }
    #####: 8881:    if (make[0] == 'O') {
    #####: 8882:      i = find_green (12, 32, 1188864, 3576832);
    #####: 8883:      c = find_green (12, 32, 2383920, 2387016);
    #####: 8884:      if (abs(i) < abs(c)) {
        -: 8885:	SWAP(i,c);
    #####: 8886:	load_flags = 24;
        -: 8887:      }
    #####: 8888:      if (i < 0) filters = 0x61616161;
        -: 8889:    }
        1: 8890:  } else if (fsize == 5869568) {
    #####: 8891:    if (!timestamp && minolta_z2()) {
    #####: 8892:      strcpy (make, "Minolta");
    #####: 8893:      strcpy (model,"DiMAGE Z2");
        -: 8894:    }
    #####: 8895:    load_flags = 6 + 24*(make[0] == 'M');
        1: 8896:  } else if (fsize == 6291456) {
    #####: 8897:    fseek (ifp, 0x300000, SEEK_SET);
    #####: 8898:    if ((order = guess_byte_order(0x10000)) == 0x4d4d) {
    #####: 8899:      height -= (top_margin = 16);
    #####: 8900:      width -= (left_margin = 28);
    #####: 8901:      maximum = 0xf5c0;
    #####: 8902:      strcpy (make, "ISG");
    #####: 8903:      model[0] = 0;
        -: 8904:    }
        1: 8905:  } else if (!strcmp(make,"Fujifilm")) {
    #####: 8906:    if (!strcmp(model+7,"S2Pro")) {
    #####: 8907:      strcpy (model,"S2Pro");
    #####: 8908:      height = 2144;
    #####: 8909:      width  = 2880;
    #####: 8910:      flip = 6;
    #####: 8911:    } else if (load_raw != &CLASS packed_load_raw)
    #####: 8912:      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;
    #####: 8913:    top_margin = (raw_height - height) >> 2 << 1;
    #####: 8914:    left_margin = (raw_width - width ) >> 2 << 1;
    #####: 8915:    if (width == 2848 || width == 3664) filters = 0x16161616;
    #####: 8916:    if (width == 4032 || width == 4952 || width == 6032) left_margin = 0;
    #####: 8917:    if (width == 3328 && (width -= 66)) left_margin = 34;
    #####: 8918:    if (width == 4936) left_margin = 4;
    #####: 8919:    if (!strcmp(model,"HS50EXR") ||
    #####: 8920:	!strcmp(model,"F900EXR")) {
    #####: 8921:      width += 2;
    #####: 8922:      left_margin = 0;
    #####: 8923:      filters = 0x16161616;
        -: 8924:    }
    #####: 8925:    if (fuji_layout) raw_width *= is_raw;
    #####: 8926:    if (filters == 9)
    #####: 8927:      FORC(36) ((char *)xtrans)[c] =
    #####: 8928:	xtrans_abs[(c/6+top_margin) % 6][(c+left_margin) % 6];
        1: 8929:  } else if (!strcmp(model,"KD-400Z")) {
    #####: 8930:    height = 1712;
    #####: 8931:    width  = 2312;
    #####: 8932:    raw_width = 2336;
    #####: 8933:    goto konica_400z;
        1: 8934:  } else if (!strcmp(model,"KD-510Z")) {
        -: 8935:    goto konica_510z;
        1: 8936:  } else if (!strcasecmp(make,"Minolta")) {
    #####: 8937:    if (!load_raw && (maximum = 0xfff))
    #####: 8938:      load_raw = &CLASS unpacked_load_raw;
    #####: 8939:    if (!strncmp(model,"DiMAGE A",8)) {
    #####: 8940:      if (!strcmp(model,"DiMAGE A200"))
    #####: 8941:	filters = 0x49494949;
    #####: 8942:      tiff_bps = 12;
    #####: 8943:      load_raw = &CLASS packed_load_raw;
    #####: 8944:    } else if (!strncmp(model,"ALPHA",5) ||
    #####: 8945:	       !strncmp(model,"DYNAX",5) ||
    #####: 8946:	       !strncmp(model,"MAXXUM",6)) {
    #####: 8947:      sprintf (model+20, "DYNAX %-10s", model+6+(model[0]=='M'));
    #####: 8948:      adobe_coeff (make, model+20);
    #####: 8949:      load_raw = &CLASS packed_load_raw;
    #####: 8950:    } else if (!strncmp(model,"DiMAGE G",8)) {
    #####: 8951:      if (model[8] == '4') {
    #####: 8952:	height = 1716;
    #####: 8953:	width  = 2304;
    #####: 8954:      } else if (model[8] == '5') {
    #####: 8955:konica_510z:
    #####: 8956:	height = 1956;
    #####: 8957:	width  = 2607;
    #####: 8958:	raw_width = 2624;
    #####: 8959:      } else if (model[8] == '6') {
    #####: 8960:	height = 2136;
    #####: 8961:	width  = 2848;
        -: 8962:      }
    #####: 8963:      data_offset += 14;
    #####: 8964:      filters = 0x61616161;
    #####: 8965:konica_400z:
    #####: 8966:      load_raw = &CLASS unpacked_load_raw;
    #####: 8967:      maximum = 0x3df;
    #####: 8968:      order = 0x4d4d;
        -: 8969:    }
        1: 8970:  } else if (!strcmp(model,"*ist D")) {
    #####: 8971:    load_raw = &CLASS unpacked_load_raw;
    #####: 8972:    data_error = -1;
        1: 8973:  } else if (!strcmp(model,"*ist DS")) {
    #####: 8974:    height -= 2;
        1: 8975:  } else if (!strcmp(make,"Samsung") && raw_width == 4704) {
    #####: 8976:    height -= top_margin = 8;
    #####: 8977:    width -= 2 * (left_margin = 8);
    #####: 8978:    load_flags = 32;
        1: 8979:  } else if (!strcmp(make,"Samsung") && raw_height == 3714) {
    #####: 8980:    height -= top_margin = 18;
    #####: 8981:    left_margin = raw_width - (width = 5536);
    #####: 8982:    if (raw_width != 5600)
    #####: 8983:      left_margin = top_margin = 0;
    #####: 8984:    filters = 0x61616161;
    #####: 8985:    colors = 3;
        1: 8986:  } else if (!strcmp(make,"Samsung") && raw_width == 5632) {
    #####: 8987:    order = 0x4949;
    #####: 8988:    height = 3694;
    #####: 8989:    top_margin = 2;
    #####: 8990:    width  = 5574 - (left_margin = 32 + tiff_bps);
    #####: 8991:    if (tiff_bps == 12) load_flags = 80;
        1: 8992:  } else if (!strcmp(make,"Samsung") && raw_width == 5664) {
    #####: 8993:    height -= top_margin = 17;
    #####: 8994:    left_margin = 96;
    #####: 8995:    width = 5544;
    #####: 8996:    filters = 0x49494949;
        1: 8997:  } else if (!strcmp(make,"Samsung") && raw_width == 6496) {
    #####: 8998:    filters = 0x61616161;
    #####: 8999:    black = 1 << (tiff_bps - 7);
        1: 9000:  } else if (!strcmp(model,"EX1")) {
    #####: 9001:    order = 0x4949;
    #####: 9002:    height -= 20;
    #####: 9003:    top_margin = 2;
    #####: 9004:    if ((width -= 6) > 3682) {
    #####: 9005:      height -= 10;
    #####: 9006:      width  -= 46;
    #####: 9007:      top_margin = 8;
        -: 9008:    }
        1: 9009:  } else if (!strcmp(model,"WB2000")) {
    #####: 9010:    order = 0x4949;
    #####: 9011:    height -= 3;
    #####: 9012:    top_margin = 2;
    #####: 9013:    if ((width -= 10) > 3718) {
    #####: 9014:      height -= 28;
    #####: 9015:      width  -= 56;
    #####: 9016:      top_margin = 8;
        -: 9017:    }
        1: 9018:  } else if (strstr(model,"WB550")) {
    #####: 9019:    strcpy (model, "WB550");
        1: 9020:  } else if (!strcmp(model,"EX2F")) {
    #####: 9021:    height = 3045;
    #####: 9022:    width  = 4070;
    #####: 9023:    top_margin = 3;
    #####: 9024:    order = 0x4949;
    #####: 9025:    filters = 0x49494949;
    #####: 9026:    load_raw = &CLASS unpacked_load_raw;
        1: 9027:  } else if (!strcmp(model,"STV680 VGA")) {
    #####: 9028:    black = 16;
        1: 9029:  } else if (!strcmp(model,"N95")) {
    #####: 9030:    height = raw_height - (top_margin = 2);
        1: 9031:  } else if (!strcmp(model,"640x480")) {
    #####: 9032:    gamma_curve (0.45, 4.5, 1, 255);
        1: 9033:  } else if (!strcmp(make,"Hasselblad")) {
    #####: 9034:    if (load_raw == &CLASS lossless_jpeg_load_raw)
    #####: 9035:      load_raw = &CLASS hasselblad_load_raw;
    #####: 9036:    if (raw_width == 7262) {
    #####: 9037:      height = 5444;
    #####: 9038:      width  = 7248;
    #####: 9039:      top_margin  = 4;
    #####: 9040:      left_margin = 7;
    #####: 9041:      filters = 0x61616161;
    #####: 9042:    } else if (raw_width == 7410 || raw_width == 8282) {
    #####: 9043:      height -= 84;
    #####: 9044:      width  -= 82;
    #####: 9045:      top_margin  = 4;
    #####: 9046:      left_margin = 41;
    #####: 9047:      filters = 0x61616161;
    #####: 9048:    } else if (raw_width == 9044) {
    #####: 9049:      height = 6716;
    #####: 9050:      width  = 8964;
    #####: 9051:      top_margin  = 8;
    #####: 9052:      left_margin = 40;
    #####: 9053:      black += load_flags = 256;
    #####: 9054:      maximum = 0x8101;
    #####: 9055:    } else if (raw_width == 4090) {
    #####: 9056:      strcpy (model, "V96C");
    #####: 9057:      height -= (top_margin = 6);
    #####: 9058:      width -= (left_margin = 3) + 7;
    #####: 9059:      filters = 0x61616161;
        -: 9060:    }
    #####: 9061:    if (tiff_samples > 1) {
    #####: 9062:      is_raw = tiff_samples+1;
    #####: 9063:      if (!shot_select && !half_size) filters = 0;
        -: 9064:    }
        1: 9065:  } else if (!strcmp(make,"Sinar")) {
    #####: 9066:    if (!load_raw) load_raw = &CLASS unpacked_load_raw;
    #####: 9067:    if (is_raw > 1 && !shot_select && !half_size) filters = 0;
    #####: 9068:    maximum = 0x3fff;
        1: 9069:  } else if (!strcmp(make,"Leaf")) {
    #####: 9070:    maximum = 0x3fff;
    #####: 9071:    fseek (ifp, data_offset, SEEK_SET);
    #####: 9072:    if (ljpeg_start (&jh, 1) && jh.bits == 15)
    #####: 9073:      maximum = 0x1fff;
    #####: 9074:    if (tiff_samples > 1) filters = 0;
    #####: 9075:    if (tiff_samples > 1 || tile_length < raw_height) {
    #####: 9076:      load_raw = &CLASS leaf_hdr_load_raw;
    #####: 9077:      raw_width = tile_width;
        -: 9078:    }
    #####: 9079:    if ((width | height) == 2048) {
    #####: 9080:      if (tiff_samples == 1) {
    #####: 9081:	filters = 1;
    #####: 9082:	strcpy (cdesc, "RBTG");
    #####: 9083:	strcpy (model, "CatchLight");
    #####: 9084:	top_margin =  8; left_margin = 18; height = 2032; width = 2016;
        -: 9085:      } else {
    #####: 9086:	strcpy (model, "DCB2");
    #####: 9087:	top_margin = 10; left_margin = 16; height = 2028; width = 2022;
        -: 9088:      }
    #####: 9089:    } else if (width+height == 3144+2060) {
    #####: 9090:      if (!model[0]) strcpy (model, "Cantare");
    #####: 9091:      if (width > height) {
    #####: 9092:	 top_margin = 6; left_margin = 32; height = 2048;  width = 3072;
    #####: 9093:	filters = 0x61616161;
        -: 9094:      } else {
    #####: 9095:	left_margin = 6;  top_margin = 32;  width = 2048; height = 3072;
    #####: 9096:	filters = 0x16161616;
        -: 9097:      }
    #####: 9098:      if (!cam_mul[0] || model[0] == 'V') filters = 0;
    #####: 9099:      else is_raw = tiff_samples;
    #####: 9100:    } else if (width == 2116) {
    #####: 9101:      strcpy (model, "Valeo 6");
    #####: 9102:      height -= 2 * (top_margin = 30);
    #####: 9103:      width -= 2 * (left_margin = 55);
    #####: 9104:      filters = 0x49494949;
    #####: 9105:    } else if (width == 3171) {
    #####: 9106:      strcpy (model, "Valeo 6");
    #####: 9107:      height -= 2 * (top_margin = 24);
    #####: 9108:      width -= 2 * (left_margin = 24);
    #####: 9109:      filters = 0x16161616;
        -: 9110:    }
        1: 9111:  } else if (!strcmp(make,"Leica") || !strcmp(make,"Panasonic")) {
    #####: 9112:    if ((flen - data_offset) / (raw_width*8/7) == raw_height)
    #####: 9113:      load_raw = &CLASS panasonic_load_raw;
    #####: 9114:    if (!load_raw) {
    #####: 9115:      load_raw = &CLASS unpacked_load_raw;
    #####: 9116:      load_flags = 4;
        -: 9117:    }
    #####: 9118:    zero_is_bad = 1;
    #####: 9119:    if ((height += 12) > raw_height) height = raw_height;
    #####: 9120:    for (i=0; i < sizeof pana / sizeof *pana; i++)
    #####: 9121:      if (raw_width == pana[i][0] && raw_height == pana[i][1]) {
    #####: 9122:	left_margin = pana[i][2];
    #####: 9123:	 top_margin = pana[i][3];
    #####: 9124:	     width += pana[i][4];
    #####: 9125:	    height += pana[i][5];
        -: 9126:      }
    #####: 9127:    filters = 0x01010101 * (uchar) "\x94\x61\x49\x16"
    #####: 9128:	[((filters-1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];
        1: 9129:  } else if (!strcmp(model,"C770UZ")) {
    #####: 9130:    height = 1718;
    #####: 9131:    width  = 2304;
    #####: 9132:    filters = 0x16161616;
    #####: 9133:    load_raw = &CLASS packed_load_raw;
    #####: 9134:    load_flags = 30;
        1: 9135:  } else if (!strcmp(make,"Olympus")) {
    #####: 9136:    height += height & 1;
    #####: 9137:    if (exif_cfa) filters = exif_cfa;
    #####: 9138:    if (width == 4100) width -= 4;
    #####: 9139:    if (width == 4080) width -= 24;
    #####: 9140:    if (width == 9280) { width -= 6; height -= 6; }
    #####: 9141:    if (load_raw == &CLASS unpacked_load_raw)
    #####: 9142:      load_flags = 4;
    #####: 9143:    tiff_bps = 12;
    #####: 9144:    if (!strcmp(model,"E-300") ||
    #####: 9145:	!strcmp(model,"E-500")) {
    #####: 9146:      width -= 20;
    #####: 9147:      if (load_raw == &CLASS unpacked_load_raw) {
    #####: 9148:	maximum = 0xfc3;
    #####: 9149:	memset (cblack, 0, sizeof cblack);
        -: 9150:      }
    #####: 9151:    } else if (!strcmp(model,"E-330")) {
    #####: 9152:      width -= 30;
    #####: 9153:      if (load_raw == &CLASS unpacked_load_raw)
    #####: 9154:	maximum = 0xf79;
    #####: 9155:    } else if (!strcmp(model,"SP550UZ")) {
    #####: 9156:      thumb_length = flen - (thumb_offset = 0xa39800);
    #####: 9157:      thumb_height = 480;
    #####: 9158:      thumb_width  = 640;
    #####: 9159:    } else if (!strcmp(model,"TG-4")) {
    #####: 9160:      width -= 16;
        -: 9161:    }
        1: 9162:  } else if (!strcmp(model,"N Digital")) {
    #####: 9163:    height = 2047;
    #####: 9164:    width  = 3072;
    #####: 9165:    filters = 0x61616161;
    #####: 9166:    data_offset = 0x1a00;
    #####: 9167:    load_raw = &CLASS packed_load_raw;
        1: 9168:  } else if (!strcmp(model,"DSC-F828")) {
    #####: 9169:    width = 3288;
    #####: 9170:    left_margin = 5;
    #####: 9171:    mask[1][3] = -17;
    #####: 9172:    data_offset = 862144;
    #####: 9173:    load_raw = &CLASS sony_load_raw;
    #####: 9174:    filters = 0x9c9c9c9c;
    #####: 9175:    colors = 4;
    #####: 9176:    strcpy (cdesc, "RGBE");
        1: 9177:  } else if (!strcmp(model,"DSC-V3")) {
    #####: 9178:    width = 3109;
    #####: 9179:    left_margin = 59;
    #####: 9180:    mask[0][1] = 9;
    #####: 9181:    data_offset = 787392;
    #####: 9182:    load_raw = &CLASS sony_load_raw;
        1: 9183:  } else if (!strcmp(make,"Sony") && raw_width == 3984) {
    #####: 9184:    width = 3925;
    #####: 9185:    order = 0x4d4d;
        1: 9186:  } else if (!strcmp(make,"Sony") && raw_width == 4288) {
    #####: 9187:    width -= 32;
        1: 9188:  } else if (!strcmp(make,"Sony") && raw_width == 4600) {
    #####: 9189:    if (!strcmp(model,"DSLR-A350"))
    #####: 9190:      height -= 4;
    #####: 9191:    black = 0;
        1: 9192:  } else if (!strcmp(make,"Sony") && raw_width == 4928) {
    #####: 9193:    if (height < 3280) width -= 8;
        1: 9194:  } else if (!strcmp(make,"Sony") && raw_width == 5504) {
    #####: 9195:    width -= height > 3664 ? 8 : 32;
    #####: 9196:    if (!strncmp(model,"DSC",3))
    #####: 9197:      black = 200 << (tiff_bps - 12);
        1: 9198:  } else if (!strcmp(make,"Sony") && raw_width == 6048) {
    #####: 9199:    width -= 24;
    #####: 9200:    if (strstr(model,"RX1") || strstr(model,"A99"))
    #####: 9201:      width -= 6;
        1: 9202:  } else if (!strcmp(make,"Sony") && raw_width == 7392) {
    #####: 9203:    width -= 30;
        1: 9204:  } else if (!strcmp(make,"Sony") && raw_width == 8000) {
    #####: 9205:    width -= 32;
    #####: 9206:    if (!strncmp(model,"DSC",3)) {
    #####: 9207:      tiff_bps = 14;
    #####: 9208:      load_raw = &CLASS unpacked_load_raw;
    #####: 9209:      black = 512;
        -: 9210:    }
        1: 9211:  } else if (!strcmp(model,"DSLR-A100")) {
    #####: 9212:    if (width == 3880) {
    #####: 9213:      height--;
    #####: 9214:      width = ++raw_width;
        -: 9215:    } else {
    #####: 9216:      height -= 4;
    #####: 9217:      width  -= 4;
    #####: 9218:      order = 0x4d4d;
    #####: 9219:      load_flags = 2;
        -: 9220:    }
    #####: 9221:    filters = 0x61616161;
        1: 9222:  } else if (!strcmp(model,"PIXL")) {
    #####: 9223:    height -= top_margin = 4;
    #####: 9224:    width -= left_margin = 32;
    #####: 9225:    gamma_curve (0, 7, 1, 255);
        1: 9226:  } else if (!strcmp(model,"C603") || !strcmp(model,"C330")
        1: 9227:	|| !strcmp(model,"12MP")) {
    #####: 9228:    order = 0x4949;
    #####: 9229:    if (filters && data_offset) {
    #####: 9230:      fseek (ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);
    #####: 9231:      read_shorts (curve, 256);
    #####: 9232:    } else gamma_curve (0, 3.875, 1, 255);
    #####: 9233:    load_raw  =  filters   ? &CLASS eight_bit_load_raw :
    #####: 9234:      strcmp(model,"C330") ? &CLASS kodak_c603_load_raw :
        -: 9235:			     &CLASS kodak_c330_load_raw;
    #####: 9236:    load_flags = tiff_bps > 16;
    #####: 9237:    tiff_bps = 8;
        1: 9238:  } else if (!strncasecmp(model,"EasyShare",9)) {
    #####: 9239:    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;
    #####: 9240:    load_raw = &CLASS packed_load_raw;
        1: 9241:  } else if (!strcasecmp(make,"Kodak")) {
    #####: 9242:    if (filters == UINT_MAX) filters = 0x61616161;
    #####: 9243:    if (!strncmp(model,"NC2000",6) ||
    #####: 9244:	!strncmp(model,"EOSDCS",6) ||
    #####: 9245:	!strncmp(model,"DCS4",4)) {
    #####: 9246:      width -= 4;
    #####: 9247:      left_margin = 2;
    #####: 9248:      if (model[6] == ' ') model[6] = 0;
    #####: 9249:      if (!strcmp(model,"DCS460A")) goto bw;
    #####: 9250:    } else if (!strcmp(model,"DCS660M")) {
    #####: 9251:      black = 214;
    #####: 9252:      goto bw;
    #####: 9253:    } else if (!strcmp(model,"DCS760M")) {
    #####: 9254:bw:   colors = 1;
    #####: 9255:      filters = 0;
        -: 9256:    }
    #####: 9257:    if (!strcmp(model+4,"20X"))
    #####: 9258:      strcpy (cdesc, "MYCY");
    #####: 9259:    if (strstr(model,"DC25")) {
    #####: 9260:      strcpy (model, "DC25");
    #####: 9261:      data_offset = 15424;
        -: 9262:    }
    #####: 9263:    if (!strncmp(model,"DC2",3)) {
    #####: 9264:      raw_height = 2 + (height = 242);
    #####: 9265:      if (flen < 100000) {
    #####: 9266:	raw_width = 256; width = 249;
    #####: 9267:	pixel_aspect = (4.0*height) / (3.0*width);
        -: 9268:      } else {
    #####: 9269:	raw_width = 512; width = 501;
    #####: 9270:	pixel_aspect = (493.0*height) / (373.0*width);
        -: 9271:      }
    #####: 9272:      top_margin = left_margin = 1;
    #####: 9273:      colors = 4;
    #####: 9274:      filters = 0x8d8d8d8d;
        -: 9275:      simple_coeff(1);
    #####: 9276:      pre_mul[1] = 1.179;
    #####: 9277:      pre_mul[2] = 1.209;
    #####: 9278:      pre_mul[3] = 1.036;
    #####: 9279:      load_raw = &CLASS eight_bit_load_raw;
    #####: 9280:    } else if (!strcmp(model,"40")) {
    #####: 9281:      strcpy (model, "DC40");
    #####: 9282:      height = 512;
    #####: 9283:      width  = 768;
    #####: 9284:      data_offset = 1152;
    #####: 9285:      load_raw = &CLASS kodak_radc_load_raw;
    #####: 9286:      tiff_bps = 12;
    #####: 9287:    } else if (strstr(model,"DC50")) {
    #####: 9288:      strcpy (model, "DC50");
    #####: 9289:      height = 512;
    #####: 9290:      width  = 768;
    #####: 9291:      data_offset = 19712;
    #####: 9292:      load_raw = &CLASS kodak_radc_load_raw;
    #####: 9293:    } else if (strstr(model,"DC120")) {
    #####: 9294:      strcpy (model, "DC120");
    #####: 9295:      height = 976;
    #####: 9296:      width  = 848;
    #####: 9297:      pixel_aspect = height/0.75/width;
    #####: 9298:      load_raw = tiff_compress == 7 ?
    #####: 9299:	&CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;
    #####: 9300:    } else if (!strcmp(model,"DCS200")) {
    #####: 9301:      thumb_height = 128;
    #####: 9302:      thumb_width  = 192;
    #####: 9303:      thumb_offset = 6144;
    #####: 9304:      thumb_misc   = 360;
    #####: 9305:      write_thumb = &CLASS layer_thumb;
    #####: 9306:      black = 17;
        -: 9307:    }
        1: 9308:  } else if (!strcmp(model,"Fotoman Pixtura")) {
    #####: 9309:    height = 512;
    #####: 9310:    width  = 768;
    #####: 9311:    data_offset = 3632;
    #####: 9312:    load_raw = &CLASS kodak_radc_load_raw;
    #####: 9313:    filters = 0x61616161;
        -: 9314:    simple_coeff(2);
        1: 9315:  } else if (!strncmp(model,"QuickTake",9)) {
    #####: 9316:    if (head[5]) strcpy (model+10, "200");
    #####: 9317:    fseek (ifp, 544, SEEK_SET);
    #####: 9318:    height = get2();
    #####: 9319:    width  = get2();
    #####: 9320:    data_offset = (get4(),get2()) == 30 ? 738:736;
    #####: 9321:    if (height > width) {
    #####: 9322:      SWAP(height,width);
    #####: 9323:      fseek (ifp, data_offset-6, SEEK_SET);
    #####: 9324:      flip = ~get2() & 3 ? 5:6;
        -: 9325:    }
    #####: 9326:    filters = 0x61616161;
        1: 9327:  } else if (!strcmp(make,"Rollei") && !load_raw) {
    #####: 9328:    switch (raw_width) {
    #####: 9329:      case 1316:
    #####: 9330:	height = 1030;
    #####: 9331:	width  = 1300;
    #####: 9332:	top_margin  = 1;
    #####: 9333:	left_margin = 6;
    #####: 9334:	break;
    #####: 9335:      case 2568:
    #####: 9336:	height = 1960;
    #####: 9337:	width  = 2560;
    #####: 9338:	top_margin  = 2;
    #####: 9339:	left_margin = 8;
        -: 9340:    }
    #####: 9341:    filters = 0x16161616;
    #####: 9342:    load_raw = &CLASS rollei_load_raw;
        -: 9343:  }
        1: 9344:  if (!model[0])
    #####: 9345:    sprintf (model, "%dx%d", width, height);
        1: 9346:  if (filters == UINT_MAX) filters = 0x94949494;
        2: 9347:  if (thumb_offset && !thumb_height) {
    #####: 9348:    fseek (ifp, thumb_offset, SEEK_SET);
    #####: 9349:    if (ljpeg_start (&jh, 1)) {
    #####: 9350:      thumb_width  = jh.wide;
    #####: 9351:      thumb_height = jh.high;
        -: 9352:    }
        -: 9353:  }
        2: 9354:dng_skip:
        1: 9355:  if ((use_camera_matrix & (use_camera_wb || dng_version))
    #####: 9356:	&& cmatrix[0][0] > 0.125) {
    #####: 9357:    memcpy (rgb_cam, cmatrix, sizeof cmatrix);
    #####: 9358:    raw_color = 0;
        -: 9359:  }
        1: 9360:  if (raw_color) adobe_coeff (make, model);
        1: 9361:  if (load_raw == &CLASS kodak_radc_load_raw)
    #####: 9362:    if (raw_color) adobe_coeff ("Apple","Quicktake");
        1: 9363:  if (fuji_width) {
    #####: 9364:    fuji_width = width >> !fuji_layout;
    #####: 9365:    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;
    #####: 9366:    width = (height >> fuji_layout) + fuji_width;
    #####: 9367:    height = width - 1;
    #####: 9368:    pixel_aspect = 1;
        -: 9369:  } else {
        1: 9370:    if (raw_height < height) raw_height = height;
        1: 9371:    if (raw_width  < width ) raw_width  = width;
        -: 9372:  }
        1: 9373:  if (!tiff_bps) tiff_bps = 12;
        1: 9374:  if (!maximum) maximum = (1 << tiff_bps) - 1;
        2: 9375:  if (!load_raw || height < 22 || width < 22 ||
        2: 9376:	tiff_bps > 16 || tiff_samples > 6 || colors > 4)
    #####: 9377:    is_raw = 0;
        -: 9378:#ifdef NO_JASPER
        -: 9379:  if (load_raw == &CLASS redcine_load_raw) {
        -: 9380:    fprintf (stderr,_("%s: You must link dcraw with %s!!\n"),
        -: 9381:	ifname, "libjasper");
        -: 9382:    is_raw = 0;
        -: 9383:  }
        -: 9384:#endif
        -: 9385:#ifdef NO_JPEG
        -: 9386:  if (load_raw == &CLASS kodak_jpeg_load_raw ||
        -: 9387:      load_raw == &CLASS lossy_dng_load_raw) {
        -: 9388:    fprintf (stderr,_("%s: You must link dcraw with %s!!\n"),
        -: 9389:	ifname, "libjpeg");
        -: 9390:    is_raw = 0;
        -: 9391:  }
        -: 9392:#endif
        1: 9393:  if (!cdesc[0])
        1: 9394:    strcpy (cdesc, colors == 3 ? "RGBG":"GMCY");
        1: 9395:  if (!raw_height) raw_height = height;
        1: 9396:  if (!raw_width ) raw_width  = width;
        2: 9397:  if (filters > 999 && colors == 3)
        3: 9398:    filters |= ((filters >> 2 & 0x22222222) |
        2: 9399:		(filters << 2 & 0x88888888)) & filters << 1;
        1: 9400:notraw:
        1: 9401:  if (flip == UINT_MAX) flip = tiff_flip;
        1: 9402:  if (flip == UINT_MAX) flip = 0;
        1: 9403:}
        -: 9404:
        -: 9405:#ifndef NO_LCMS
    #####: 9406:void CLASS apply_profile (const char *input, const char *output)
        -: 9407:{
        -: 9408:  char *prof;
        -: 9409:  cmsHPROFILE hInProfile=0, hOutProfile=0;
        -: 9410:  cmsHTRANSFORM hTransform;
        -: 9411:  FILE *fp;
        -: 9412:  unsigned size;
        -: 9413:
    #####: 9414:  if (strcmp (input, "embed"))
    #####: 9415:    hInProfile = cmsOpenProfileFromFile (input, "r");
    #####: 9416:  else if (profile_length) {
    #####: 9417:    prof = (char *) malloc (profile_length);
    #####: 9418:    merror (prof, "apply_profile()");
    #####: 9419:    fseek (ifp, profile_offset, SEEK_SET);
    #####: 9420:    fread (prof, 1, profile_length, ifp);
    #####: 9421:    hInProfile = cmsOpenProfileFromMem (prof, profile_length);
    #####: 9422:    free (prof);
        -: 9423:  } else
    #####: 9424:    fprintf (stderr,_("%s has no embedded profile.\n"), ifname);
    #####: 9425:  if (!hInProfile) return;
    #####: 9426:  if (!output)
    #####: 9427:    hOutProfile = cmsCreate_sRGBProfile();
    #####: 9428:  else if ((fp = fopen (output, "rb"))) {
    #####: 9429:    fread (&size, 4, 1, fp);
    #####: 9430:    fseek (fp, 0, SEEK_SET);
    #####: 9431:    oprof = (unsigned *) malloc (size = ntohl(size));
    #####: 9432:    merror (oprof, "apply_profile()");
    #####: 9433:    fread (oprof, 1, size, fp);
    #####: 9434:    fclose (fp);
    #####: 9435:    if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {
    #####: 9436:      free (oprof);
    #####: 9437:      oprof = 0;
        -: 9438:    }
        -: 9439:  } else
    #####: 9440:    fprintf (stderr,_("Cannot open file %s!\n"), output);
    #####: 9441:  if (!hOutProfile) goto quit;
    #####: 9442:  if (verbose)
    #####: 9443:    fprintf (stderr,_("Applying color profile...\n"));
    #####: 9444:  hTransform = cmsCreateTransform (hInProfile, TYPE_RGBA_16,
        -: 9445:	hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);
    #####: 9446:  cmsDoTransform (hTransform, image, image, width*height);
    #####: 9447:  raw_color = 1;		/* Don't use rgb_cam with a profile */
    #####: 9448:  cmsDeleteTransform (hTransform);
    #####: 9449:  cmsCloseProfile (hOutProfile);
    #####: 9450:quit:
    #####: 9451:  cmsCloseProfile (hInProfile);
        -: 9452:}
        -: 9453:#endif
        -: 9454:
        1: 9455:void CLASS convert_to_rgb()
        -: 9456:{
        -: 9457:  int row, col, c, i, j, k;
        -: 9458:  ushort *img;
        -: 9459:  float out[3], out_cam[3][4];
        -: 9460:  double num, inverse[3][3];
        -: 9461:  static const double xyzd50_srgb[3][3] =
        -: 9462:  { { 0.436083, 0.385083, 0.143055 },
        -: 9463:    { 0.222507, 0.716888, 0.060608 },
        -: 9464:    { 0.013930, 0.097097, 0.714022 } };
        -: 9465:  static const double rgb_rgb[3][3] =
        -: 9466:  { { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };
        -: 9467:  static const double adobe_rgb[3][3] =
        -: 9468:  { { 0.715146, 0.284856, 0.000000 },
        -: 9469:    { 0.000000, 1.000000, 0.000000 },
        -: 9470:    { 0.000000, 0.041166, 0.958839 } };
        -: 9471:  static const double wide_rgb[3][3] =
        -: 9472:  { { 0.593087, 0.404710, 0.002206 },
        -: 9473:    { 0.095413, 0.843149, 0.061439 },
        -: 9474:    { 0.011621, 0.069091, 0.919288 } };
        -: 9475:  static const double prophoto_rgb[3][3] =
        -: 9476:  { { 0.529317, 0.330092, 0.140588 },
        -: 9477:    { 0.098368, 0.873465, 0.028169 },
        -: 9478:    { 0.016879, 0.117663, 0.865457 } };
        -: 9479:  static const double aces_rgb[3][3] =
        -: 9480:  { { 0.432996, 0.375380, 0.189317 },
        -: 9481:    { 0.089427, 0.816523, 0.102989 },
        -: 9482:    { 0.019165, 0.118150, 0.941914 } };
        -: 9483:  static const double (*out_rgb[])[3] =
        -: 9484:  { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb };
        -: 9485:  static const char *name[] =
        -: 9486:  { "sRGB", "Adobe RGB (1998)", "WideGamut D65", "ProPhoto D65", "XYZ", "ACES" };
        -: 9487:  static const unsigned phead[] =
        -: 9488:  { 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,
        -: 9489:    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };
        1: 9490:  unsigned pbody[] =
        -: 9491:  { 10, 0x63707274, 0, 36,	/* cprt */
        -: 9492:	0x64657363, 0, 40,	/* desc */
        -: 9493:	0x77747074, 0, 20,	/* wtpt */
        -: 9494:	0x626b7074, 0, 20,	/* bkpt */
        -: 9495:	0x72545243, 0, 14,	/* rTRC */
        -: 9496:	0x67545243, 0, 14,	/* gTRC */
        -: 9497:	0x62545243, 0, 14,	/* bTRC */
        -: 9498:	0x7258595a, 0, 20,	/* rXYZ */
        -: 9499:	0x6758595a, 0, 20,	/* gXYZ */
        -: 9500:	0x6258595a, 0, 20 };	/* bXYZ */
        -: 9501:  static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };
        1: 9502:  unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };
        -: 9503:
        1: 9504:  gamma_curve (gamm[0], gamm[1], 0, 0);
        1: 9505:  memcpy (out_cam, rgb_cam, sizeof out_cam);
        4: 9506:  raw_color |= colors == 1 || document_mode ||
        3: 9507:		output_color < 1 || output_color > 6;
        1: 9508:  if (!raw_color) {
        1: 9509:    oprof = (unsigned *) calloc (phead[0], 1);
        1: 9510:    merror (oprof, "convert_to_rgb()");
        1: 9511:    memcpy (oprof, phead, sizeof phead);
        1: 9512:    if (output_color == 5) oprof[4] = oprof[5];
        1: 9513:    oprof[0] = 132 + 12*pbody[0];
       12: 9514:    for (i=0; i < pbody[0]; i++) {
       10: 9515:      oprof[oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;
       10: 9516:      pbody[i*3+2] = oprof[0];
       10: 9517:      oprof[0] += (pbody[i*3+3] + 3) & -4;
        -: 9518:    }
        1: 9519:    memcpy (oprof+32, pbody, sizeof pbody);
        1: 9520:    oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;
        1: 9521:    memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);
        1: 9522:    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;
        4: 9523:    for (i=4; i < 7; i++)
        3: 9524:      memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);
        1: 9525:    pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);
        4: 9526:    for (i=0; i < 3; i++)
        9: 9527:      for (j=0; j < 3; j++) {
       27: 9528:	for (num = k=0; k < 3; k++)
       27: 9529:	  num += xyzd50_srgb[i][k] * inverse[j][k];
        9: 9530:	oprof[pbody[j*3+23]/4+i+2] = num * 0x10000 + 0.5;
        -: 9531:      }
      256: 9532:    for (i=0; i < phead[0]/4; i++)
      512: 9533:      oprof[i] = htonl(oprof[i]);
        1: 9534:    strcpy ((char *)oprof+pbody[2]+8, "auto-generated by dcraw");
        1: 9535:    strcpy ((char *)oprof+pbody[5]+12, name[output_color-1]);
        4: 9536:    for (i=0; i < 3; i++)
        9: 9537:      for (j=0; j < colors; j++)
       36: 9538:	for (out_cam[i][j] = k=0; k < 3; k++)
       27: 9539:	  out_cam[i][j] += out_rgb[output_color-1][i][k] * rgb_cam[k][j];
        -: 9540:  }
        1: 9541:  if (verbose)
    #####: 9542:    fprintf (stderr, raw_color ? _("Building histograms...\n") :
    #####: 9543:	_("Converting to %s colorspace...\n"), name[output_color-1]);
        -: 9544:
        1: 9545:  memset (histogram, 0, sizeof histogram);
     3483: 9546:  for (img=image[0], row=0; row < height; row++)
 18169076: 9547:    for (col=0; col < width; col++, img+=4) {
 18169076: 9548:      if (!raw_color) {
 18169076: 9549:	out[0] = out[1] = out[2] = 0;
 72676304: 9550:	FORCC {
 54507228: 9551:	  out[0] += out_cam[0][c] * img[c];
 54507228: 9552:	  out[1] += out_cam[1][c] * img[c];
 54507228: 9553:	  out[2] += out_cam[2][c] * img[c];
        -: 9554:	}
 54507228: 9555:	FORC3 img[c] = CLIP((int) out[c]);
        -: 9556:      }
    #####: 9557:      else if (document_mode)
    #####: 9558:	img[0] = img[fcol(row,col)];
 54507228: 9559:      FORCC histogram[c][img[c] >> 3]++;
        -: 9560:    }
        1: 9561:  if (colors == 4 && output_color) colors = 3;
        1: 9562:  if (document_mode && filters) colors = 1;
        1: 9563:}
        -: 9564:
        1: 9565:void CLASS fuji_rotate()
        -: 9566:{
        -: 9567:  int i, row, col;
        -: 9568:  double step;
        -: 9569:  float r, c, fr, fc;
        -: 9570:  unsigned ur, uc;
        -: 9571:  ushort wide, high, (*img)[4], (*pix)[4];
        -: 9572:
        1: 9573:  if (!fuji_width) return;
    #####: 9574:  if (verbose)
    #####: 9575:    fprintf (stderr,_("Rotating image 45 degrees...\n"));
    #####: 9576:  fuji_width = (fuji_width - 1 + shrink) >> shrink;
        -: 9577:  step = sqrt(0.5);
    #####: 9578:  wide = fuji_width / step;
    #####: 9579:  high = (height - fuji_width) / step;
    #####: 9580:  img = (ushort (*)[4]) calloc (high, wide*sizeof *img);
    #####: 9581:  merror (img, "fuji_rotate()");
        -: 9582:
    #####: 9583:  for (row=0; row < high; row++)
    #####: 9584:    for (col=0; col < wide; col++) {
    #####: 9585:      ur = r = fuji_width + (row-col)*step;
    #####: 9586:      uc = c = (row+col)*step;
    #####: 9587:      if (ur > height-2 || uc > width-2) continue;
    #####: 9588:      fr = r - ur;
    #####: 9589:      fc = c - uc;
    #####: 9590:      pix = image + ur*width + uc;
    #####: 9591:      for (i=0; i < colors; i++)
    #####: 9592:	img[row*wide+col][i] =
    #####: 9593:	  (pix[    0][i]*(1-fc) + pix[      1][i]*fc) * (1-fr) +
    #####: 9594:	  (pix[width][i]*(1-fc) + pix[width+1][i]*fc) * fr;
        -: 9595:    }
    #####: 9596:  free (image);
    #####: 9597:  width  = wide;
    #####: 9598:  height = high;
    #####: 9599:  image  = img;
    #####: 9600:  fuji_width = 0;
        -: 9601:}
        -: 9602:
        1: 9603:void CLASS stretch()
        -: 9604:{
        -: 9605:  ushort newdim, (*img)[4], *pix0, *pix1;
        -: 9606:  int row, col, c;
        -: 9607:  double rc, frac;
        -: 9608:
        1: 9609:  if (pixel_aspect == 1) return;
    #####: 9610:  if (verbose) fprintf (stderr,_("Stretching the image...\n"));
    #####: 9611:  if (pixel_aspect < 1) {
    #####: 9612:    newdim = height / pixel_aspect + 0.5;
    #####: 9613:    img = (ushort (*)[4]) calloc (width, newdim*sizeof *img);
    #####: 9614:    merror (img, "stretch()");
    #####: 9615:    for (rc=row=0; row < newdim; row++, rc+=pixel_aspect) {
    #####: 9616:      frac = rc - (c = rc);
    #####: 9617:      pix0 = pix1 = image[c*width];
    #####: 9618:      if (c+1 < height) pix1 += width*4;
    #####: 9619:      for (col=0; col < width; col++, pix0+=4, pix1+=4)
    #####: 9620:	FORCC img[row*width+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;
        -: 9621:    }
    #####: 9622:    height = newdim;
        -: 9623:  } else {
    #####: 9624:    newdim = width * pixel_aspect + 0.5;
    #####: 9625:    img = (ushort (*)[4]) calloc (height, newdim*sizeof *img);
    #####: 9626:    merror (img, "stretch()");
    #####: 9627:    for (rc=col=0; col < newdim; col++, rc+=1/pixel_aspect) {
    #####: 9628:      frac = rc - (c = rc);
    #####: 9629:      pix0 = pix1 = image[c];
    #####: 9630:      if (c+1 < width) pix1 += 4;
    #####: 9631:      for (row=0; row < height; row++, pix0+=width*4, pix1+=width*4)
    #####: 9632:	FORCC img[row*newdim+col][c] = pix0[c]*(1-frac) + pix1[c]*frac + 0.5;
        -: 9633:    }
    #####: 9634:    width = newdim;
        -: 9635:  }
    #####: 9636:  free (image);
    #####: 9637:  image = img;
        -: 9638:}
        -: 9639:
        4: 9640:int CLASS flip_index (int row, int col)
        -: 9641:{
        4: 9642:  if (flip & 4) SWAP(row,col);
        4: 9643:  if (flip & 2) row = iheight - 1 - row;
        4: 9644:  if (flip & 1) col = iwidth  - 1 - col;
        4: 9645:  return row * iwidth + col;
        -: 9646:}
        -: 9647:
        -: 9648:struct tiff_tag {
        -: 9649:  ushort tag, type;
        -: 9650:  int count;
        -: 9651:  union { char c[4]; short s[2]; int i; } val;
        -: 9652:};
        -: 9653:
        -: 9654:struct tiff_hdr {
        -: 9655:  ushort order, magic;
        -: 9656:  int ifd;
        -: 9657:  ushort pad, ntag;
        -: 9658:  struct tiff_tag tag[23];
        -: 9659:  int nextifd;
        -: 9660:  ushort pad2, nexif;
        -: 9661:  struct tiff_tag exif[4];
        -: 9662:  ushort pad3, ngps;
        -: 9663:  struct tiff_tag gpst[10];
        -: 9664:  short bps[4];
        -: 9665:  int rat[10];
        -: 9666:  unsigned gps[26];
        -: 9667:  char desc[512], make[64], model[64], soft[32], date[20], artist[64];
        -: 9668:};
        -: 9669:
    #####: 9670:void CLASS tiff_set (struct tiff_hdr *th, ushort *ntag,
        -: 9671:	ushort tag, ushort type, int count, int val)
        -: 9672:{
        -: 9673:  struct tiff_tag *tt;
        -: 9674:  int c;
        -: 9675:
    #####: 9676:  tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;
    #####: 9677:  tt->val.i = val;
    #####: 9678:  if (type == 1 && count <= 4)
    #####: 9679:    FORC(4) tt->val.c[c] = val >> (c << 3);
    #####: 9680:  else if (type == 2) {
    #####: 9681:    count = strnlen((char *)th + val, count-1) + 1;
    #####: 9682:    if (count <= 4)
    #####: 9683:      FORC(4) tt->val.c[c] = ((char *)th)[val+c];
    #####: 9684:  } else if (type == 3 && count <= 2)
    #####: 9685:    FORC(2) tt->val.s[c] = val >> (c << 4);
    #####: 9686:  tt->count = count;
    #####: 9687:  tt->type = type;
    #####: 9688:  tt->tag = tag;
    #####: 9689:}
        -: 9690:
        -: 9691:#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)
        -: 9692:
    #####: 9693:void CLASS tiff_head (struct tiff_hdr *th, int full)
        -: 9694:{
        -: 9695:  int c, psize=0;
        -: 9696:  struct tm *t;
        -: 9697:
    #####: 9698:  memset (th, 0, sizeof *th);
    #####: 9699:  th->order = htonl(0x4d4d4949) >> 16;
    #####: 9700:  th->magic = 42;
    #####: 9701:  th->ifd = 10;
    #####: 9702:  th->rat[0] = th->rat[2] = 300;
    #####: 9703:  th->rat[1] = th->rat[3] = 1;
    #####: 9704:  FORC(6) th->rat[4+c] = 1000000;
    #####: 9705:  th->rat[4] *= shutter;
    #####: 9706:  th->rat[6] *= aperture;
    #####: 9707:  th->rat[8] *= focal_len;
    #####: 9708:  strncpy (th->desc, desc, 512);
    #####: 9709:  strncpy (th->make, make, 64);
    #####: 9710:  strncpy (th->model, model, 64);
    #####: 9711:  strcpy (th->soft, "dcraw v"DCRAW_VERSION);
    #####: 9712:  t = localtime (&timestamp);
    #####: 9713:  sprintf (th->date, "%04d:%02d:%02d %02d:%02d:%02d",
    #####: 9714:      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);
    #####: 9715:  strncpy (th->artist, artist, 64);
    #####: 9716:  if (full) {
    #####: 9717:    tiff_set (th, &th->ntag, 254, 4, 1, 0);
    #####: 9718:    tiff_set (th, &th->ntag, 256, 4, 1, width);
    #####: 9719:    tiff_set (th, &th->ntag, 257, 4, 1, height);
    #####: 9720:    tiff_set (th, &th->ntag, 258, 3, colors, output_bps);
    #####: 9721:    if (colors > 2)
    #####: 9722:      th->tag[th->ntag-1].val.i = TOFF(th->bps);
    #####: 9723:    FORC4 th->bps[c] = output_bps;
    #####: 9724:    tiff_set (th, &th->ntag, 259, 3, 1, 1);
    #####: 9725:    tiff_set (th, &th->ntag, 262, 3, 1, 1 + (colors > 1));
        -: 9726:  }
    #####: 9727:  tiff_set (th, &th->ntag, 270, 2, 512, TOFF(th->desc));
    #####: 9728:  tiff_set (th, &th->ntag, 271, 2, 64, TOFF(th->make));
    #####: 9729:  tiff_set (th, &th->ntag, 272, 2, 64, TOFF(th->model));
    #####: 9730:  if (full) {
    #####: 9731:    if (oprof) psize = ntohl(oprof[0]);
    #####: 9732:    tiff_set (th, &th->ntag, 273, 4, 1, sizeof *th + psize);
    #####: 9733:    tiff_set (th, &th->ntag, 277, 3, 1, colors);
    #####: 9734:    tiff_set (th, &th->ntag, 278, 4, 1, height);
    #####: 9735:    tiff_set (th, &th->ntag, 279, 4, 1, height*width*colors*output_bps/8);
        -: 9736:  } else
    #####: 9737:    tiff_set (th, &th->ntag, 274, 3, 1, "12435867"[flip]-'0');
    #####: 9738:  tiff_set (th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));
    #####: 9739:  tiff_set (th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));
    #####: 9740:  tiff_set (th, &th->ntag, 284, 3, 1, 1);
    #####: 9741:  tiff_set (th, &th->ntag, 296, 3, 1, 2);
    #####: 9742:  tiff_set (th, &th->ntag, 305, 2, 32, TOFF(th->soft));
    #####: 9743:  tiff_set (th, &th->ntag, 306, 2, 20, TOFF(th->date));
    #####: 9744:  tiff_set (th, &th->ntag, 315, 2, 64, TOFF(th->artist));
    #####: 9745:  tiff_set (th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));
    #####: 9746:  if (psize) tiff_set (th, &th->ntag, 34675, 7, psize, sizeof *th);
    #####: 9747:  tiff_set (th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));
    #####: 9748:  tiff_set (th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));
    #####: 9749:  tiff_set (th, &th->nexif, 34855, 3, 1, iso_speed);
    #####: 9750:  tiff_set (th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));
    #####: 9751:  if (gpsdata[1]) {
    #####: 9752:    tiff_set (th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));
    #####: 9753:    tiff_set (th, &th->ngps,  0, 1,  4, 0x202);
    #####: 9754:    tiff_set (th, &th->ngps,  1, 2,  2, gpsdata[29]);
    #####: 9755:    tiff_set (th, &th->ngps,  2, 5,  3, TOFF(th->gps[0]));
    #####: 9756:    tiff_set (th, &th->ngps,  3, 2,  2, gpsdata[30]);
    #####: 9757:    tiff_set (th, &th->ngps,  4, 5,  3, TOFF(th->gps[6]));
    #####: 9758:    tiff_set (th, &th->ngps,  5, 1,  1, gpsdata[31]);
    #####: 9759:    tiff_set (th, &th->ngps,  6, 5,  1, TOFF(th->gps[18]));
    #####: 9760:    tiff_set (th, &th->ngps,  7, 5,  3, TOFF(th->gps[12]));
    #####: 9761:    tiff_set (th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));
    #####: 9762:    tiff_set (th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));
    #####: 9763:    memcpy (th->gps, gpsdata, sizeof th->gps);
        -: 9764:  }
    #####: 9765:}
        -: 9766:
    #####: 9767:void CLASS jpeg_thumb()
        -: 9768:{
        -: 9769:  char *thumb;
        -: 9770:  ushort exif[5];
        -: 9771:  struct tiff_hdr th;
        -: 9772:
    #####: 9773:  thumb = (char *) malloc (thumb_length);
    #####: 9774:  merror (thumb, "jpeg_thumb()");
    #####: 9775:  fread (thumb, 1, thumb_length, ifp);
    #####: 9776:  fputc (0xff, ofp);
    #####: 9777:  fputc (0xd8, ofp);
    #####: 9778:  if (strcmp (thumb+6, "Exif")) {
    #####: 9779:    memcpy (exif, "\xff\xe1  Exif\0\0", 10);
    #####: 9780:    exif[1] = htons (8 + sizeof th);
    #####: 9781:    fwrite (exif, 1, sizeof exif, ofp);
    #####: 9782:    tiff_head (&th, 0);
    #####: 9783:    fwrite (&th, 1, sizeof th, ofp);
        -: 9784:  }
    #####: 9785:  fwrite (thumb+2, 1, thumb_length-2, ofp);
    #####: 9786:  free (thumb);
    #####: 9787:}
        -: 9788:
        1: 9789:void CLASS write_ppm_tiff()
        -: 9790:{
        -: 9791:  struct tiff_hdr th;
        -: 9792:  uchar *ppm;
        -: 9793:  ushort *ppm2;
        -: 9794:  int c, row, col, soff, rstep, cstep;
        -: 9795:  int perc, val, total, white=0x2000;
        -: 9796:
        1: 9797:  perc = width * height * 0.01;		/* 99th percentile white level */
        1: 9798:  if (fuji_width) perc /= 2;
        1: 9799:  if (!((highlight & ~2) || no_auto_bright))
        3: 9800:    for (white=c=0; c < colors; c++) {
    14753: 9801:      for (val=0x2000, total=0; --val > 32; )
    14753: 9802:	if ((total += histogram[c][val]) > perc) break;
        3: 9803:      if (white < val) white = val;
        -: 9804:    }
        1: 9805:  gamma_curve (gamm[0], gamm[1], 2, (white << 3)/bright);
        1: 9806:  iheight = height;
        1: 9807:  iwidth  = width;
        1: 9808:  if (flip & 4) SWAP(height,width);
        1: 9809:  ppm = (uchar *) calloc (width, colors*output_bps/8);
        -: 9810:  ppm2 = (ushort *) ppm;
        1: 9811:  merror (ppm, "write_ppm_tiff()");
        1: 9812:  if (output_tiff) {
    #####: 9813:    tiff_head (&th, 1);
    #####: 9814:    fwrite (&th, sizeof th, 1, ofp);
    #####: 9815:    if (oprof)
    #####: 9816:      fwrite (oprof, ntohl(oprof[0]), 1, ofp);
        1: 9817:  } else if (colors > 3)
    #####: 9818:    fprintf (ofp,
        -: 9819:      "P7\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
    #####: 9820:	width, height, colors, (1 << output_bps)-1, cdesc);
        -: 9821:  else
        2: 9822:    fprintf (ofp, "P%d\n%d %d\n%d\n",
        2: 9823:	colors/2+5, width, height, (1 << output_bps)-1);
        1: 9824:  soff  = flip_index (0, 0);
        1: 9825:  cstep = flip_index (0, 1) - soff;
        1: 9826:  rstep = flip_index (1, 0) - flip_index (0, width);
     3483: 9827:  for (row=0; row < height; row++, soff += rstep) {
 18169076: 9828:    for (col=0; col < width; col++, soff += cstep)
 18169076: 9829:      if (output_bps == 8)
 54507228: 9830:	   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;
    #####: 9831:      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];
     3482: 9832:    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)
    #####: 9833:      swab (ppm2, ppm2, width*colors*2);
     3482: 9834:    fwrite (ppm, colors*output_bps/8, width, ofp);
        -: 9835:  }
        1: 9836:  free (ppm);
        1: 9837:}
        -: 9838:
        1: 9839:int CLASS main (int argc, const char **argv)
        -: 9840:{
        1: 9841:  int arg, status=0, quality, i, c;
        1: 9842:  int timestamp_only=0, thumbnail_only=0, identify_only=0;
        1: 9843:  int user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;
        1: 9844:  int use_fuji_rotate=1, write_to_stdout=0, read_from_stdin=0;
        1: 9845:  const char *sp, *bpfile=0, *dark_frame=0, *write_ext;
        -: 9846:  char opm, opt, *ofname, *cp;
        -: 9847:  struct utimbuf ut;
        -: 9848:#ifndef NO_LCMS
        1: 9849:  const char *cam_profile=0, *out_profile=0;
        -: 9850:#endif
        -: 9851:
        -: 9852:#ifndef LOCALTIME
        1: 9853:  putenv ((char *) "TZ=UTC");
        -: 9854:#endif
        -: 9855:#ifdef LOCALEDIR
        -: 9856:  setlocale (LC_CTYPE, "");
        -: 9857:  setlocale (LC_MESSAGES, "");
        -: 9858:  bindtextdomain ("dcraw", LOCALEDIR);
        -: 9859:  textdomain ("dcraw");
        -: 9860:#endif
        -: 9861:
        1: 9862:  if (argc == 1) {
    #####: 9863:    printf(_("\nRaw photo decoder \"dcraw\" v%s"), DCRAW_VERSION);
    #####: 9864:    printf(_("\nby Dave Coffin, dcoffin a cybercom o net\n"));
    #####: 9865:    printf(_("\nUsage:  %s [OPTION]... [FILE]...\n\n"), argv[0]);
    #####: 9866:    puts(_("-v        Print verbose messages"));
    #####: 9867:    puts(_("-c        Write image data to standard output"));
    #####: 9868:    puts(_("-e        Extract embedded thumbnail image"));
    #####: 9869:    puts(_("-i        Identify files without decoding them"));
    #####: 9870:    puts(_("-i -v     Identify files and show metadata"));
    #####: 9871:    puts(_("-z        Change file dates to camera timestamp"));
    #####: 9872:    puts(_("-w        Use camera white balance, if possible"));
    #####: 9873:    puts(_("-a        Average the whole image for white balance"));
    #####: 9874:    puts(_("-A <x y w h> Average a grey box for white balance"));
    #####: 9875:    puts(_("-r <r g b g> Set custom white balance"));
    #####: 9876:    puts(_("+M/-M     Use/don't use an embedded color matrix"));
    #####: 9877:    puts(_("-C <r b>  Correct chromatic aberration"));
    #####: 9878:    puts(_("-P <file> Fix the dead pixels listed in this file"));
    #####: 9879:    puts(_("-K <file> Subtract dark frame (16-bit raw PGM)"));
    #####: 9880:    puts(_("-k <num>  Set the darkness level"));
    #####: 9881:    puts(_("-S <num>  Set the saturation level"));
    #####: 9882:    puts(_("-n <num>  Set threshold for wavelet denoising"));
    #####: 9883:    puts(_("-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)"));
    #####: 9884:    puts(_("-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)"));
    #####: 9885:    puts(_("-o [0-6]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ,ACES)"));
        -: 9886:#ifndef NO_LCMS
    #####: 9887:    puts(_("-o <file> Apply output ICC profile from file"));
    #####: 9888:    puts(_("-p <file> Apply camera ICC profile from file or \"embed\""));
        -: 9889:#endif
    #####: 9890:    puts(_("-d        Document mode (no color, no interpolation)"));
    #####: 9891:    puts(_("-D        Document mode without scaling (totally raw)"));
    #####: 9892:    puts(_("-j        Don't stretch or rotate raw pixels"));
    #####: 9893:    puts(_("-W        Don't automatically brighten the image"));
    #####: 9894:    puts(_("-b <num>  Adjust brightness (default = 1.0)"));
    #####: 9895:    puts(_("-g <p ts> Set custom gamma curve (default = 2.222 4.5)"));
    #####: 9896:    puts(_("-q [0-3]  Set the interpolation quality"));
    #####: 9897:    puts(_("-h        Half-size color image (twice as fast as \"-q 0\")"));
    #####: 9898:    puts(_("-f        Interpolate RGGB as four colors"));
    #####: 9899:    puts(_("-m <num>  Apply a 3x3 median filter to R-G and B-G"));
    #####: 9900:    puts(_("-s [0..N-1] Select one raw image or \"all\" from each file"));
    #####: 9901:    puts(_("-6        Write 16-bit instead of 8-bit"));
    #####: 9902:    puts(_("-4        Linear 16-bit, same as \"-6 -W -g 1 1\""));
    #####: 9903:    puts(_("-T        Write TIFF instead of PPM"));
    #####: 9904:    puts("");
        -: 9905:    return 1;
        -: 9906:  }
        1: 9907:  argv[argc] = "";
        5: 9908:  for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) {
        3: 9909:    opt = argv[arg++][1];
        3: 9910:    if ((cp = (char *) strchr (sp="nbrkStqmHACg", opt)))
        6: 9911:      for (i=0; i < "114111111422"[cp-sp]-'0'; i++)
        6: 9912:	if (!isdigit(argv[arg+i][0])) {
    #####: 9913:	  fprintf (stderr,_("Non-numeric argument to \"-%c\"\n"), opt);
        -: 9914:	  return 1;
        -: 9915:	}
        3: 9916:    switch (opt) {
    #####: 9917:      case 'n':  threshold   = atof(argv[arg++]);  break;
    #####: 9918:      case 'b':  bright      = atof(argv[arg++]);  break;
        -: 9919:      case 'r':
        8: 9920:	   FORC4 user_mul[c] = atof(argv[arg++]);  break;
    #####: 9921:      case 'C':  aber[0] = 1 / atof(argv[arg++]);
    #####: 9922:		 aber[2] = 1 / atof(argv[arg++]);  break;
    #####: 9923:      case 'g':  gamm[0] =     atof(argv[arg++]);
    #####: 9924:		 gamm[1] =     atof(argv[arg++]);
    #####: 9925:		 if (gamm[0]) gamm[0] = 1/gamm[0]; break;
    #####: 9926:      case 'k':  user_black  = atoi(argv[arg++]);  break;
    #####: 9927:      case 'S':  user_sat    = atoi(argv[arg++]);  break;
    #####: 9928:      case 't':  user_flip   = atoi(argv[arg++]);  break;
        2: 9929:      case 'q':  user_qual   = atoi(argv[arg++]);  break;
    #####: 9930:      case 'm':  med_passes  = atoi(argv[arg++]);  break;
        2: 9931:      case 'H':  highlight   = atoi(argv[arg++]);  break;
    #####: 9932:      case 's':
    #####: 9933:	shot_select = abs(atoi(argv[arg]));
    #####: 9934:	multi_out = !strcmp(argv[arg++],"all");
    #####: 9935:	break;
    #####: 9936:      case 'o':
    #####: 9937:	if (isdigit(argv[arg][0]) && !argv[arg][1])
    #####: 9938:	  output_color = atoi(argv[arg++]);
        -: 9939:#ifndef NO_LCMS
    #####: 9940:	else     out_profile = argv[arg++];
        -: 9941:	break;
    #####: 9942:      case 'p':  cam_profile = argv[arg++];
        -: 9943:#endif
    #####: 9944:	break;
    #####: 9945:      case 'P':  bpfile     = argv[arg++];  break;
    #####: 9946:      case 'K':  dark_frame = argv[arg++];  break;
        -: 9947:      case 'z':  timestamp_only    = 1;  break;
    #####: 9948:      case 'e':  thumbnail_only    = 1;  break;
    #####: 9949:      case 'i':  identify_only     = 1;  break;
    #####: 9950:      case 'c':  write_to_stdout   = 1;  break;
    #####: 9951:      case 'v':  verbose           = 1;  break;
    #####: 9952:      case 'h':  half_size         = 1;  break;
    #####: 9953:      case 'f':  four_color_rgb    = 1;  break;
    #####: 9954:      case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);
    #####: 9955:      case 'a':  use_auto_wb       = 1;  break;
    #####: 9956:      case 'w':  use_camera_wb     = 1;  break;
    #####: 9957:      case 'M':  use_camera_matrix = 3 * (opm == '+');  break;
    #####: 9958:      case 'I':  read_from_stdin   = 1;  break;
    #####: 9959:      case 'E':  document_mode++;
    #####: 9960:      case 'D':  document_mode++;
    #####: 9961:      case 'd':  document_mode++;
        -: 9962:      case 'j':  use_fuji_rotate   = 0;  break;
    #####: 9963:      case 'W':  no_auto_bright    = 1;  break;
    #####: 9964:      case 'T':  output_tiff       = 1;  break;
    #####: 9965:      case '4':  gamm[0] = gamm[1] =
    #####: 9966:		 no_auto_bright    = 1;
    #####: 9967:      case '6':  output_bps       = 16;  break;
    #####: 9968:      default:
    #####: 9969:	fprintf (stderr,_("Unknown option \"-%c\".\n"), opt);
        -: 9970:	return 1;
        -: 9971:    }
        -: 9972:  }
        1: 9973:  if (arg == argc) {
    #####: 9974:    fprintf (stderr,_("No files to process.\n"));
        -: 9975:    return 1;
        -: 9976:  }
        1: 9977:  if (write_to_stdout) {
    #####: 9978:    if (isatty(1)) {
    #####: 9979:      fprintf (stderr,_("Will not write an image to the terminal!\n"));
        -: 9980:      return 1;
        -: 9981:    }
        -: 9982:#if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)
        -: 9983:    if (setmode(1,O_BINARY) < 0) {
        -: 9984:      perror ("setmode()");
        -: 9985:      return 1;
        -: 9986:    }
        -: 9987:#endif
        -: 9988:  }
        1: 9989:  for ( ; arg < argc; arg++) {
        -: 9990:    status = 1;
        1: 9991:    raw_image = 0;
        1: 9992:    image = 0;
        1: 9993:    oprof = 0;
        1: 9994:    meta_data = ofname = 0;
        1: 9995:    ofp = stdout;
        1: 9996:    if (setjmp (failure)) {
    #####: 9997:      if (fileno(ifp) > 2) fclose(ifp);
    #####: 9998:      if (fileno(ofp) > 2) fclose(ofp);
        -: 9999:      status = 1;
        -:10000:      goto cleanup;
        -:10001:    }
        1:10002:    ifname = argv[arg];
        1:10003:    if (!(ifp = fopen (ifname, "rb"))) {
    #####:10004:      perror (ifname);
    #####:10005:      continue;
        -:10006:    }
        1:10007:    status = (identify(),!is_raw);
        1:10008:    if (user_flip >= 0)
    #####:10009:      flip = user_flip;
        1:10010:    switch ((flip+3600) % 360) {
    #####:10011:      case 270:  flip = 5;  break;
    #####:10012:      case 180:  flip = 3;  break;
    #####:10013:      case  90:  flip = 6;
        -:10014:    }
        1:10015:    if (timestamp_only) {
    #####:10016:      if ((status = !timestamp))
    #####:10017:	fprintf (stderr,_("%s has no timestamp.\n"), ifname);
    #####:10018:      else if (identify_only)
    #####:10019:	printf ("%10ld%10d %s\n", (long) timestamp, shot_order, ifname);
        -:10020:      else {
    #####:10021:	if (verbose)
    #####:10022:	  fprintf (stderr,_("%s time set to %d.\n"), ifname, (int) timestamp);
    #####:10023:	ut.actime = ut.modtime = timestamp;
    #####:10024:	utime (ifname, &ut);
        -:10025:      }
        -:10026:      goto next;
        -:10027:    }
        1:10028:    write_fun = &CLASS write_ppm_tiff;
        1:10029:    if (thumbnail_only) {
    #####:10030:      if ((status = !thumb_offset)) {
    #####:10031:	fprintf (stderr,_("%s has no thumbnail.\n"), ifname);
        -:10032:	goto next;
    #####:10033:      } else if (thumb_load_raw) {
    #####:10034:	load_raw = thumb_load_raw;
    #####:10035:	data_offset = thumb_offset;
    #####:10036:	height = thumb_height;
    #####:10037:	width  = thumb_width;
    #####:10038:	filters = 0;
    #####:10039:	colors = 3;
        -:10040:      } else {
    #####:10041:	fseek (ifp, thumb_offset, SEEK_SET);
    #####:10042:	write_fun = write_thumb;
    #####:10043:	goto thumbnail;
        -:10044:      }
        -:10045:    }
        1:10046:    if (load_raw == &CLASS kodak_ycbcr_load_raw) {
    #####:10047:      height += height & 1;
    #####:10048:      width  += width  & 1;
        -:10049:    }
        1:10050:    if (identify_only && verbose && make[0]) {
    #####:10051:      printf (_("\nFilename: %s\n"), ifname);
    #####:10052:      printf (_("Timestamp: %s"), ctime(&timestamp));
    #####:10053:      printf (_("Camera: %s %s\n"), make, model);
    #####:10054:      if (artist[0])
    #####:10055:	printf (_("Owner: %s\n"), artist);
    #####:10056:      if (dng_version) {
    #####:10057:	printf (_("DNG Version: "));
    #####:10058:	for (i=24; i >= 0; i -= 8)
    #####:10059:	  printf ("%d%c", dng_version >> i & 255, i ? '.':'\n');
        -:10060:      }
    #####:10061:      printf (_("ISO speed: %d\n"), (int) iso_speed);
    #####:10062:      printf (_("Shutter: "));
    #####:10063:      if (shutter > 0 && shutter < 1)
    #####:10064:	shutter = (printf ("1/"), 1 / shutter);
    #####:10065:      printf (_("%0.1f sec\n"), shutter);
    #####:10066:      printf (_("Aperture: f/%0.1f\n"), aperture);
    #####:10067:      printf (_("Focal length: %0.1f mm\n"), focal_len);
    #####:10068:      printf (_("Embedded ICC profile: %s\n"), profile_length ? _("yes"):_("no"));
    #####:10069:      printf (_("Number of raw images: %d\n"), is_raw);
    #####:10070:      if (pixel_aspect != 1)
    #####:10071:	printf (_("Pixel Aspect Ratio: %0.6f\n"), pixel_aspect);
    #####:10072:      if (thumb_offset)
    #####:10073:	printf (_("Thumb size:  %4d x %d\n"), thumb_width, thumb_height);
    #####:10074:      printf (_("Full size:   %4d x %d\n"), raw_width, raw_height);
        1:10075:    } else if (!is_raw)
    #####:10076:      fprintf (stderr,_("Cannot decode file %s\n"), ifname);
        1:10077:    if (!is_raw) goto next;
        3:10078:    shrink = filters && (half_size || (!identify_only &&
        2:10079:	(threshold || aber[0] != 1 || aber[2] != 1)));
        1:10080:    iheight = (height + shrink) >> shrink;
        1:10081:    iwidth  = (width  + shrink) >> shrink;
        1:10082:    if (identify_only) {
    #####:10083:      if (verbose) {
    #####:10084:	if (document_mode == 3) {
    #####:10085:	  top_margin = left_margin = fuji_width = 0;
    #####:10086:	  height = raw_height;
    #####:10087:	  width  = raw_width;
        -:10088:	}
    #####:10089:	iheight = (height + shrink) >> shrink;
    #####:10090:	iwidth  = (width  + shrink) >> shrink;
    #####:10091:	if (use_fuji_rotate) {
    #####:10092:	  if (fuji_width) {
    #####:10093:	    fuji_width = (fuji_width - 1 + shrink) >> shrink;
    #####:10094:	    iwidth = fuji_width / sqrt(0.5);
    #####:10095:	    iheight = (iheight - fuji_width) / sqrt(0.5);
        -:10096:	  } else {
    #####:10097:	    if (pixel_aspect < 1) iheight = iheight / pixel_aspect + 0.5;
    #####:10098:	    if (pixel_aspect > 1) iwidth  = iwidth  * pixel_aspect + 0.5;
        -:10099:	  }
        -:10100:	}
    #####:10101:	if (flip & 4)
    #####:10102:	  SWAP(iheight,iwidth);
    #####:10103:	printf (_("Image size:  %4d x %d\n"), width, height);
    #####:10104:	printf (_("Output size: %4d x %d\n"), iwidth, iheight);
    #####:10105:	printf (_("Raw colors: %d"), colors);
    #####:10106:	if (filters) {
        -:10107:	  int fhigh = 2, fwide = 2;
    #####:10108:	  if ((filters ^ (filters >>  8)) & 0xff)   fhigh = 4;
    #####:10109:	  if ((filters ^ (filters >> 16)) & 0xffff) fhigh = 8;
    #####:10110:	  if (filters == 1) fhigh = fwide = 16;
    #####:10111:	  if (filters == 9) fhigh = fwide = 6;
    #####:10112:	  printf (_("\nFilter pattern: "));
    #####:10113:	  for (i=0; i < fhigh; i++)
    #####:10114:	    for (c = i && putchar('/') && 0; c < fwide; c++)
    #####:10115:	      putchar (cdesc[fcol(i,c)]);
        -:10116:	}
    #####:10117:	printf (_("\nDaylight multipliers:"));
    #####:10118:	FORCC printf (" %f", pre_mul[c]);
    #####:10119:	if (cam_mul[0] > 0) {
    #####:10120:	  printf (_("\nCamera multipliers:"));
    #####:10121:	  FORC4 printf (" %f", cam_mul[c]);
        -:10122:	}
        -:10123:	putchar ('\n');
        -:10124:      } else
    #####:10125:	printf (_("%s is a %s %s image.\n"), ifname, make, model);
    #####:10126:next:
    #####:10127:      fclose(ifp);
    #####:10128:      continue;
        -:10129:    }
        1:10130:    if (meta_length) {
    #####:10131:      meta_data = (char *) malloc (meta_length);
    #####:10132:      merror (meta_data, "main()");
        -:10133:    }
        1:10134:    if (filters || colors == 1) {
        1:10135:      raw_image = (ushort *) calloc ((raw_height+7), raw_width*2);
        1:10136:      merror (raw_image, "main()");
        -:10137:    } else {
    #####:10138:      image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);
    #####:10139:      merror (image, "main()");
        -:10140:    }
        1:10141:    if (verbose)
    #####:10142:      fprintf (stderr,_("Loading %s %s image from %s ...\n"),
        -:10143:	make, model, ifname);
        1:10144:    if (shot_select >= is_raw)
    #####:10145:      fprintf (stderr,_("%s: \"-s %d\" requests a nonexistent image!\n"),
        -:10146:	ifname, shot_select);
        1:10147:    fseeko (ifp, data_offset, SEEK_SET);
        1:10148:    if (raw_image && read_from_stdin)
    #####:10149:      fread (raw_image, 2, raw_height*raw_width, stdin);
        1:10150:    else (*load_raw)();
        1:10151:    if (document_mode == 3) {
    #####:10152:      top_margin = left_margin = fuji_width = 0;
    #####:10153:      height = raw_height;
    #####:10154:      width  = raw_width;
        -:10155:    }
        1:10156:    iheight = (height + shrink) >> shrink;
        1:10157:    iwidth  = (width  + shrink) >> shrink;
        1:10158:    if (raw_image) {
        1:10159:      image = (ushort (*)[4]) calloc (iheight, iwidth*sizeof *image);
        1:10160:      merror (image, "main()");
        1:10161:      crop_masked_pixels();
        1:10162:      free (raw_image);
        -:10163:    }
        1:10164:    if (zero_is_bad) remove_zeroes();
        1:10165:    bad_pixels (bpfile);
        1:10166:    if (dark_frame) subtract (dark_frame);
        1:10167:    quality = 2 + !fuji_width;
        1:10168:    if (user_qual >= 0) quality = user_qual;
        1:10169:    i = cblack[3];
        1:10170:    FORC3 if (i > cblack[c]) i = cblack[c];
        4:10171:    FORC4 cblack[c] -= i;
        1:10172:    black += i;
        1:10173:    i = cblack[6];
        1:10174:    FORC (cblack[4] * cblack[5])
    #####:10175:      if (i > cblack[6+c]) i = cblack[6+c];
    #####:10176:    FORC (cblack[4] * cblack[5])
    #####:10177:      cblack[6+c] -= i;
        1:10178:    black += i;
        1:10179:    if (user_black >= 0) black = user_black;
        4:10180:    FORC4 cblack[c] += black;
        1:10181:    if (user_sat > 0) maximum = user_sat;
        -:10182:#ifdef COLORCHECK
        -:10183:    colorcheck();
        -:10184:#endif
        1:10185:    if (is_foveon) {
    #####:10186:      if (document_mode || load_raw == &CLASS foveon_dp_load_raw) {
    #####:10187:	for (i=0; i < height*width*4; i++)
    #####:10188:	  if ((short) image[0][i] < 0) image[0][i] = 0;
    #####:10189:      } else foveon_interpolate();
        1:10190:    } else if (document_mode < 2)
        1:10191:      scale_colors();
        1:10192:    pre_interpolate();
        1:10193:    if (filters && !document_mode) {
        1:10194:      if (quality == 0)
        1:10195:	lin_interpolate();
    #####:10196:      else if (quality == 1 || colors > 3)
    #####:10197:	vng_interpolate();
    #####:10198:      else if (quality == 2 && filters > 1000)
    #####:10199:	ppg_interpolate();
    #####:10200:      else if (filters == 9)
    #####:10201:	xtrans_interpolate (quality*2-3);
        -:10202:      else
    #####:10203:	ahd_interpolate();
        -:10204:    }
        1:10205:    if (mix_green)
    #####:10206:      for (colors=3, i=0; i < height*width; i++)
    #####:10207:	image[i][1] = (image[i][1] + image[i][3]) >> 1;
        1:10208:    if (!is_foveon && colors == 3) median_filter();
        1:10209:    if (!is_foveon && highlight == 2) blend_highlights();
        1:10210:    if (!is_foveon && highlight > 2) recover_highlights();
        1:10211:    if (use_fuji_rotate) fuji_rotate();
        -:10212:#ifndef NO_LCMS
        1:10213:    if (cam_profile) apply_profile (cam_profile, out_profile);
        -:10214:#endif
        1:10215:    convert_to_rgb();
        2:10216:    if (use_fuji_rotate) stretch();
        1:10217:thumbnail:
        1:10218:    if (write_fun == &CLASS jpeg_thumb)
        -:10219:      write_ext = ".jpg";
        1:10220:    else if (output_tiff && write_fun == &CLASS write_ppm_tiff)
        -:10221:      write_ext = ".tiff";
        -:10222:    else
        1:10223:      write_ext = ".pgm\0.ppm\0.ppm\0.pam" + colors*5-5;
        1:10224:    ofname = (char *) malloc (strlen(ifname) + 64);
        1:10225:    merror (ofname, "main()");
        1:10226:    if (write_to_stdout)
    #####:10227:      strcpy (ofname,_("standard output"));
        -:10228:    else {
        1:10229:      strcpy (ofname, ifname);
        1:10230:      if ((cp = strrchr (ofname, '.'))) *cp = 0;
        1:10231:      if (multi_out)
    #####:10232:	sprintf (ofname+strlen(ofname), "_%0*d",
        -:10233:		snprintf(0,0,"%d",is_raw-1), shot_select);
        1:10234:      if (thumbnail_only)
    #####:10235:	strcat (ofname, ".thumb");
        1:10236:      strcat (ofname, write_ext);
        1:10237:      ofp = fopen (ofname, "wb");
        1:10238:      if (!ofp) {
    #####:10239:	status = 1;
    #####:10240:	perror (ofname);
        -:10241:	goto cleanup;
        -:10242:      }
        -:10243:    }
        1:10244:    if (verbose)
    #####:10245:      fprintf (stderr,_("Writing data to %s ...\n"), ofname);
        1:10246:    (*write_fun)();
        1:10247:    fclose(ifp);
        2:10248:    if (ofp != stdout) fclose(ofp);
        1:10249:cleanup:
        1:10250:    if (meta_data) free (meta_data);
        1:10251:    if (ofname) free (ofname);
        1:10252:    if (oprof) free (oprof);
        1:10253:    if (image) free (image);
        1:10254:    if (multi_out) {
    #####:10255:      if (++shot_select < is_raw) arg--;
    #####:10256:      else shot_select = 0;
        -:10257:    }
        -:10258:  }
        -:10259:  return status;
        -:10260:}
